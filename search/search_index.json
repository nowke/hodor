{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"My personal musings - where I learn and experiment Computer Science Experiments \u00b6 SICP Algorithms CLRS Problems","title":"Home"},{"location":"#experiments","text":"SICP Algorithms CLRS Problems","title":"Experiments"},{"location":"CLRS/","text":"CLRS Programs \u00b6 Exercises and programs from Introduction to Algorithms by CLRS book Chapters \u00b6 Chapter 1 - Role of algorithms in computing Chapter 2 - Getting Started","title":"CLRS Programs"},{"location":"CLRS/#clrs-programs","text":"Exercises and programs from Introduction to Algorithms by CLRS book","title":"CLRS Programs"},{"location":"CLRS/#chapters","text":"Chapter 1 - Role of algorithms in computing Chapter 2 - Getting Started","title":"Chapters"},{"location":"CLRS/ch01-role-of-algorithms-in-computing/exercise-1.1.1/","text":"Give a real-world example that requires sorting or a real-world example that requires computing a convex hull. Sorting Retrieve blog posts from database sorted by date Show list of files present in a folder sorted by name World population statistics report - sorted by count per country Convex hull Collision detection Detecting human faces - Algorithm for detecting human faces based on convex-hull Geographic Information System (GIS) - Calculate the minimum bounding geometry for the selected points.","title":"Exercise 1.1.1"},{"location":"CLRS/ch01-role-of-algorithms-in-computing/exercise-1.1.2/","text":"Other than speed, what other measures of efficiency might one use in a real-world setting? Memory usage (measured by space complexity) Power consumption","title":"Exercise 1.1.2"},{"location":"CLRS/ch01-role-of-algorithms-in-computing/exercise-1.1.3/","text":"Select a data structure that you have seen previously, and discuss its strengths and limitations. Stack Strengths Fast access of top element (constant time) Push and pop operations are constant time Best suited for recursive algorithms Limitations Fixed size - causes overflow if more than allocated elements are inserted Only one element can be accessed at a time (i.e. top element)","title":"Exercise 1.1.3"},{"location":"CLRS/ch01-role-of-algorithms-in-computing/exercise-1.1.4/","text":"How are the shortest-path and traveling-salesman problems given above similar? How are they different? Shortest path (SP) and Travelling salesman problems (TSP) are modelled using graphs and involve minimizing the distance. TSP involves minimizing path which must include a set of vertices, whereas SP involves minimizing path between only two vertices (start and end)","title":"Exercise 1.1.4"},{"location":"CLRS/ch01-role-of-algorithms-in-computing/exercise-1.1.5/","text":"Come up with a real-world problem in which only the best solution will do. Then come up with one in which a solution that is \"approximately\" the best is good enough. Authentication based on fingerprint should have the best solution implemented. A false authentication cannot be tolerated. Whereas, finding shortest path between two points can return a solution which is approximately short.","title":"Exercise 1.1.5"},{"location":"CLRS/ch01-role-of-algorithms-in-computing/exercise-1.2.1/","text":"Give an example of an application that requires algorithmic content at the application level, and discuss the function of the algorithms involved. Netflix gives recommendations for user on the home page based on user's history. This requires recommendation algorithm to be run in background or pre-compute the results.","title":"Exercise 1.2.1"},{"location":"CLRS/ch01-role-of-algorithms-in-computing/exercise-1.2.2/","text":"Suppose we are comparing implementations of insertion sort and merge sort on the same machine. For inputs of size n n , insertion sort runs in 8n^2 8n^2 steps, while merge sort runs in 64n \\cdot \\log_{2}n 64n \\cdot \\log_{2}n steps. For which values of n n does insertion sort beat merge sort? Insertion sort is slower than merge sort for values n \\mid 8n^2 < 64n \\cdot log_2 n n \\mid 8n^2 < 64n \\cdot log_2 n . To find n n , 8n^2 < 64n \\cdot log_2 n 8n^2 < 64n \\cdot log_2 n n < 8 \\cdot log_2 n n < 8 \\cdot log_2 n 2^{\\frac {n}{8}} < n 2^{\\frac {n}{8}} < n Trying values for n n , n=48 \\Rightarrow 2^{\\frac {48}{8}} = 64 > 48 n=48 \\Rightarrow 2^{\\frac {48}{8}} = 64 > 48 n=44 \\Rightarrow 2^{\\frac {44}{8}} = 45.2548 > 44 n=44 \\Rightarrow 2^{\\frac {44}{8}} = 45.2548 > 44 n=43 \\Rightarrow 2^{\\frac {43}{8}} = 41.5 < 43 n=43 \\Rightarrow 2^{\\frac {43}{8}} = 41.5 < 43 Hence, for n<=43 n<=43 , insertion sort beats merge sort","title":"Exercise 1.2.2"},{"location":"CLRS/ch01-role-of-algorithms-in-computing/exercise-1.2.3/","text":"What is the smallest value of n n such that an algorithm whose running time is 100n^2 100n^2 runs faster than an algorithm whose running time is 2^n 2^n on the same machine? To find n n , 100n^2 < 2^n 100n^2 < 2^n Trying values for n n , $$ n = 14 \\Rightarrow 100 \\cdot 14^2 = 19600 > 2^{14} $$ n = 15 \\Rightarrow 100 \\cdot 15^2 = 22500 < 2^{15} n = 15 \\Rightarrow 100 \\cdot 15^2 = 22500 < 2^{15} Hence, smallest value of n n is n=15 n=15","title":"Exercise 1.2.3"},{"location":"CLRS/ch01-role-of-algorithms-in-computing/problems/","text":"Problem 1.1 \u00b6 For each function f(n) f(n) and time t t in the following table, determine the largest size n n of a problem that can be solved in time t t , assuming that the algorithm to solve the problem takes f(n) f(n) microseconds. 1 second 1 minute 1 hour 1 day 1 month 1 year 1 century log_2{n} log_2{n} 2^{10^6} 2^{10^6} 2^{6 \\times 10^7} 2^{6 \\times 10^7} 2^{3.6 \\times 10^9} 2^{3.6 \\times 10^9} 2^{8.64 \\times 10^{10}} 2^{8.64 \\times 10^{10}} 2^{2.592 \\times 10^{12}} 2^{2.592 \\times 10^{12}} 2^{3.1536 \\times 10^{13}} 2^{3.1536 \\times 10^{13}} 2^{3.1536 \\times 10^{15}} 2^{3.1536 \\times 10^{15}} \\sqrt{n} \\sqrt{n} 10^{12} 10^{12} 3.6 \\times 10^{15} 3.6 \\times 10^{15} 1.296 \\times 10^{19} 1.296 \\times 10^{19} 7.465 \\times 10^{21} 7.465 \\times 10^{21} 6.72 \\times 10^{24} 6.72 \\times 10^{24} 9.92 \\times 10^{26} 9.92 \\times 10^{26} 9.92 \\times 10^{30} 9.92 \\times 10^{30} n n 10^6 10^6 6 \\times 10^7 6 \\times 10^7 3.6 \\times 10^9 3.6 \\times 10^9 8.64 \\times 10^{10} 8.64 \\times 10^{10} 2.59 \\times 10^{12} 2.59 \\times 10^{12} 3.15 \\times 10^{13} 3.15 \\times 10^{13} 3.15 \\times 10^{15} 3.15 \\times 10^{15} n \\cdot log_2{n} n \\cdot log_2{n} 62746 62746 28014174 28014174 1.33 \\times 10^8 1.33 \\times 10^8 2.755 \\times 10^{9} 2.755 \\times 10^{9} 7.187 \\times 10^{10} 7.187 \\times 10^{10} 7.97 \\times 10^{11} 7.97 \\times 10^{11} 6.86 \\times 10^{13} 6.86 \\times 10^{13} n^2 n^2 1,000 1,000 7,745 7,745 60,000 60,000 293,938 293,938 1,609,968 1,609,968 5,615,692 5,615,692 56,156,922 56,156,922 n^3 n^3 100 100 391 391 1,532 1,532 4,420 4,420 13,736 13,736 31,593 31,593 146,645 146,645 2^n 2^n 19 19 25 25 31 31 36 36 41 41 44 44 51 51 n! n! 9 9 11 11 12 12 13 13 15 15 16 16 17 17 For log_2{n} log_2{n} , answer is calculated as follows 1 second $$ log_2{n} = 1 \\times 10^6 $$ n = 2^{10^6} n = 2^{10^6} 1 minute $$ log_2{n} = 60 \\times 10^6 $$ n = 2^{6 \\times 10^7} n = 2^{6 \\times 10^7} Similar procedure is used for \\sqrt{n}, n, n^2, n^3 \\sqrt{n}, n, n^2, n^3 and 2^n 2^n For n \\times log_2{n} n \\times log_2{n} , Fixed-point iteration can be used as $$ f(n) = n \\times log_2{n} $$ n \\rightarrow \\frac{f(n)}{log_2{n}} n \\rightarrow \\frac{f(n)}{log_2{n}} import math def fixed_point_iter ( fn , first_guess , tolerance = 0.00001 ): guess = first_guess while abs ( guess - fn ( guess )) > tolerance : guess = fn ( guess ) return guess def get_n_for_n_log_n ( time ): log2 = math . log ( 2 ) return math . floor ( fixed_point_iter ( lambda x : time / ( math . log ( x ) / log2 ), 100 , tolerance = 1 ) ) For 1 second, time = 10**6 get_n_for_n_log_n ( 10 ** 6 ) 62745 We can also use scipy.optimize.fixed_point function. from scipy.optimize import fixed_point def get_n_for_n_log_n ( time ): log2 = math . log ( 2 ) return math . floor ( fixed_point ( lambda x : time / ( math . log ( x ) / log2 ), [ 100 ], xtol = 0.001 ) ) We can retrieve all values: time_map = { \"1 second\" : 10 ** 6 , \"1 minute\" : 60 * 10 ** 6 , \"1 hour\" : 60 * 60 * 10 ** 6 , \"1 day\" : 24 * 60 * 60 * 10 ** 6 , \"1 month\" : 30 * 24 * 60 * 60 * 10 ** 6 , \"1 year\" : 365 * 24 * 60 * 60 * 10 ** 6 , \"1 century\" : 100 * 365 * 24 * 60 * 60 * 10 ** 6 } for label , time in time_map . items (): n = get_n_for_n_log_n ( time ) print ( f 'For {label}, n = {n}' ) For 1 second, n = 62746 For 1 minute, n = 2801417 For 1 hour, n = 133378059 For 1 day, n = 2755147515 For 1 month, n = 71870856441 For 1 year, n = 797633893656 For 1 century, n = 68610956766262 For n! n! , we can simply try values since we do not cross 20! 20!","title":"Problems"},{"location":"CLRS/ch01-role-of-algorithms-in-computing/problems/#problem-11","text":"For each function f(n) f(n) and time t t in the following table, determine the largest size n n of a problem that can be solved in time t t , assuming that the algorithm to solve the problem takes f(n) f(n) microseconds. 1 second 1 minute 1 hour 1 day 1 month 1 year 1 century log_2{n} log_2{n} 2^{10^6} 2^{10^6} 2^{6 \\times 10^7} 2^{6 \\times 10^7} 2^{3.6 \\times 10^9} 2^{3.6 \\times 10^9} 2^{8.64 \\times 10^{10}} 2^{8.64 \\times 10^{10}} 2^{2.592 \\times 10^{12}} 2^{2.592 \\times 10^{12}} 2^{3.1536 \\times 10^{13}} 2^{3.1536 \\times 10^{13}} 2^{3.1536 \\times 10^{15}} 2^{3.1536 \\times 10^{15}} \\sqrt{n} \\sqrt{n} 10^{12} 10^{12} 3.6 \\times 10^{15} 3.6 \\times 10^{15} 1.296 \\times 10^{19} 1.296 \\times 10^{19} 7.465 \\times 10^{21} 7.465 \\times 10^{21} 6.72 \\times 10^{24} 6.72 \\times 10^{24} 9.92 \\times 10^{26} 9.92 \\times 10^{26} 9.92 \\times 10^{30} 9.92 \\times 10^{30} n n 10^6 10^6 6 \\times 10^7 6 \\times 10^7 3.6 \\times 10^9 3.6 \\times 10^9 8.64 \\times 10^{10} 8.64 \\times 10^{10} 2.59 \\times 10^{12} 2.59 \\times 10^{12} 3.15 \\times 10^{13} 3.15 \\times 10^{13} 3.15 \\times 10^{15} 3.15 \\times 10^{15} n \\cdot log_2{n} n \\cdot log_2{n} 62746 62746 28014174 28014174 1.33 \\times 10^8 1.33 \\times 10^8 2.755 \\times 10^{9} 2.755 \\times 10^{9} 7.187 \\times 10^{10} 7.187 \\times 10^{10} 7.97 \\times 10^{11} 7.97 \\times 10^{11} 6.86 \\times 10^{13} 6.86 \\times 10^{13} n^2 n^2 1,000 1,000 7,745 7,745 60,000 60,000 293,938 293,938 1,609,968 1,609,968 5,615,692 5,615,692 56,156,922 56,156,922 n^3 n^3 100 100 391 391 1,532 1,532 4,420 4,420 13,736 13,736 31,593 31,593 146,645 146,645 2^n 2^n 19 19 25 25 31 31 36 36 41 41 44 44 51 51 n! n! 9 9 11 11 12 12 13 13 15 15 16 16 17 17 For log_2{n} log_2{n} , answer is calculated as follows 1 second $$ log_2{n} = 1 \\times 10^6 $$ n = 2^{10^6} n = 2^{10^6} 1 minute $$ log_2{n} = 60 \\times 10^6 $$ n = 2^{6 \\times 10^7} n = 2^{6 \\times 10^7} Similar procedure is used for \\sqrt{n}, n, n^2, n^3 \\sqrt{n}, n, n^2, n^3 and 2^n 2^n For n \\times log_2{n} n \\times log_2{n} , Fixed-point iteration can be used as $$ f(n) = n \\times log_2{n} $$ n \\rightarrow \\frac{f(n)}{log_2{n}} n \\rightarrow \\frac{f(n)}{log_2{n}} import math def fixed_point_iter ( fn , first_guess , tolerance = 0.00001 ): guess = first_guess while abs ( guess - fn ( guess )) > tolerance : guess = fn ( guess ) return guess def get_n_for_n_log_n ( time ): log2 = math . log ( 2 ) return math . floor ( fixed_point_iter ( lambda x : time / ( math . log ( x ) / log2 ), 100 , tolerance = 1 ) ) For 1 second, time = 10**6 get_n_for_n_log_n ( 10 ** 6 ) 62745 We can also use scipy.optimize.fixed_point function. from scipy.optimize import fixed_point def get_n_for_n_log_n ( time ): log2 = math . log ( 2 ) return math . floor ( fixed_point ( lambda x : time / ( math . log ( x ) / log2 ), [ 100 ], xtol = 0.001 ) ) We can retrieve all values: time_map = { \"1 second\" : 10 ** 6 , \"1 minute\" : 60 * 10 ** 6 , \"1 hour\" : 60 * 60 * 10 ** 6 , \"1 day\" : 24 * 60 * 60 * 10 ** 6 , \"1 month\" : 30 * 24 * 60 * 60 * 10 ** 6 , \"1 year\" : 365 * 24 * 60 * 60 * 10 ** 6 , \"1 century\" : 100 * 365 * 24 * 60 * 60 * 10 ** 6 } for label , time in time_map . items (): n = get_n_for_n_log_n ( time ) print ( f 'For {label}, n = {n}' ) For 1 second, n = 62746 For 1 minute, n = 2801417 For 1 hour, n = 133378059 For 1 day, n = 2755147515 For 1 month, n = 71870856441 For 1 year, n = 797633893656 For 1 century, n = 68610956766262 For n! n! , we can simply try values since we do not cross 20! 20!","title":"Problem 1.1"},{"location":"CLRS/ch02-getting-started/exercise-2.1/","text":"Exercise 2.1-1 \u00b6 Using Figure 2.2 as a model, illustrate the operation of INSERTION-SORT on the array A = [31, 41, 59, 26, 41, 58] . Iteration 1 1 2 3 4 5 6 [31 41 59 26 41 58] Iteration 2 1 2 3 4 5 6 [31 41 59 26 41 58] Iteration 3 1 2 3 4 5 6 [31 41 59 26 41 58] Iteration 4 1 2 3 4 5 6 [26 31 41 59 41 58] Iteration 5 1 2 3 4 5 6 [26 31 41 41 59 58] Iteration 6 1 2 3 4 5 6 [26 31 41 41 58 59] Exercise 2.1-2 \u00b6 Rewrite the INSERTION-SORT procedure to sort into nonincreasing instead of non-decreasing order. NON-INCREASING INSERTION-SORT(A) 1 for j = 2 to A.length 2 key = A[j] 3 // Insert A[j] into the sorted sequence A[1..j-1] 4 i = j -1 5 while i > 0 and A[i] < key 6 A[i+1] = A[i] 7 i = i - 1 8 A[i+1] = key Python code def insertion_sort ( A ): \"\"\"Sorts the array `A` in descending order using `Insertion sort` algorithm Args: A: Array of numbers to be sorted Returns: Array of numbers in sorted, descending order \"\"\" for j in range ( 1 , len ( A )): key = A [ j ] # Insert A[j] into the sorted sequence A[0..j-1] i = j - 1 while i > - 1 and A [ i ] < key : A [ i + 1 ] = A [ i ] i = i - 1 A [ i + 1 ] = key return A tests = [ [ 31 , 41 , 59 , 26 , 41 , 58 ], [], [ 40 , 20 ], [ 1 ], [ 10 , 9 , 8 , 7 ], [ 7 , 8 , 9 , 10 ] ] for input_array in tests : print ( f 'Input: {input_array}' ) output_array = insertion_sort ( input_array ) print ( f 'Sorted: {output_array} \\n ' ) Input: [31, 41, 59, 26, 41, 58] Sorted: [59, 58, 41, 41, 31, 26] Input: [] Sorted: [] Input: [40, 20] Sorted: [40, 20] Input: [1] Sorted: [1] Input: [10, 9, 8, 7] Sorted: [10, 9, 8, 7] Input: [7, 8, 9, 10] Sorted: [10, 9, 8, 7] Exercise 2.1-3 \u00b6 Consider the searching problem : Input : A sequence of n numbers A = \\langle a_1, a_2, ... , a_n \\rangle A = \\langle a_1, a_2, ... , a_n \\rangle and a value v Output : An index i such that v=A[i] v=A[i] or the special value NIL if v does not appear in A . Write pseudocode for linear search , which scans through the sequence, looking for v . Using a loop invariant, prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties. Pseudocode LINEAR-SEARCH(A, V) 1 i = NIL 2 for j = 1 to A.length 3 if A[j] = v 4 i = j 5 return i 6 return i Proof using Loop invariant Invariant : At any point of time, the variable i holds the value of the index, till the point array has been scanned. Initialization : Before the loop starts, the value of i is NIL , which is the right value since the array has not yet been searched, and assumed value is NIL Maintenance : At each iteration, if v is equal to current element in A , value of that index j is assigned to i , which is the correct value to be returned. If not, value of i is still NIL . Termination : If the loop is termintaed, it means that v is not found in A, and hence value of i remains NIL . Hence the algorithm is correct Python Program def linear_search ( A , v ): \"\"\"Performs a linear search for `v` in array `A` Args: A: Array of numbers v: Number to be searched in `A` Returns: Index of the array A, if v is found in A `None` if v is not found in A \"\"\" for j in range ( 0 , len ( A )): if A [ j ] == v : return j return None tests = [ [[ 31 , 41 , 59 , 26 , 41 , 58 ], 41 ], [[ 35 , 43 , 19 ], 20 ], [[], 5 ], [[ 1 ], 1 ], [[ 3 ], - 5 ], [[ 5 , 7 , 8 ], 5 ], [[ 5 , 7 , 8 ], 8 ] ] for A , v in tests : print ( f 'Input: A = {A}, v = {v}' ) index = linear_search ( A , v ) print ( f 'Index: {index} \\n ' ) Input: A = [31, 41, 59, 26, 41, 58], v = 41 Index: 1 Input: A = [35, 43, 19], v = 20 Index: None Input: A = [], v = 5 Index: None Input: A = [1], v = 1 Index: 0 Input: A = [3], v = -5 Index: None Input: A = [5, 7, 8], v = 5 Index: 0 Input: A = [5, 7, 8], v = 8 Index: 2 Exercise 2.1-4 \u00b6 Consider the problem of adding two n -bit binary integers, stored in two n -element arrays A and B . The sum of the two integers should be stored in binary form in an (n + 1) -element array C . State the problem formally and write pseudocode for adding the two integers. Input : Arrays A and B of length n containing binary digits 0 and 1 of two numbers a and b Output : Array C of length n + 1 containing binary digits of a + b Pseudocode ADD BINARY INTEGERS(A, B) 1 carry = 0 2 for i = n downto 1 3 sum = A[i] + B[i] + carry 4 C[i + 1] = sum (mod 2) 5 if sum > 1 6 carry = 1 7 else 8 carry = 0 9 C[1] = carry Python code def add_binary_integers ( A , B ): \"\"\"Adds two binary integers Args: A: Array of 0 and 1 representing binary digits B: Array of 0 and 1 representing binary digits Returns: C: Array of 0 and 1 representing binary digits of A+B \"\"\" carry = 0 n = len ( A ) C = [ 0 for x in range ( n + 1 )] for i in range ( len ( A ) - 1 , - 1 , - 1 ): s = A [ i ] + B [ i ] + carry C [ i + 1 ] = s % 2 if s > 1 : carry = 1 else : carry = 0 C [ 0 ] = carry return C tests = [ { \"A\" : [ 0 , 0 , 0 ], \"B\" : [ 0 , 0 , 0 ], \"a\" : 0 , \"b\" : 0 , \"c\" : 0 }, { \"A\" : [ 0 , 0 , 1 ], \"B\" : [ 0 , 1 , 0 ], \"a\" : 1 , \"b\" : 2 , \"c\" : 3 }, { \"A\" : [ 1 , 1 , 1 ], \"B\" : [ 1 , 1 , 1 ], \"a\" : 7 , \"b\" : 7 , \"c\" : 14 }, { \"A\" : [ 1 ], \"B\" : [ 1 ], \"a\" : 1 , \"b\" : 1 , \"c\" : 2 }, ] for test in tests : A , B , a , b , c = test [ \"A\" ], test [ \"B\" ], test [ \"a\" ], test [ \"b\" ], test [ \"c\" ] C = add_binary_integers ( A , B ) print ( f 'A = {A}, a = {a}' ) print ( f 'B = {B}, b = {b}' ) print ( f 'C = {C}, c = {c} \\n ' ) A = [0, 0, 0], a = 0 B = [0, 0, 0], b = 0 C = [0, 0, 0, 0], c = 0 A = [0, 0, 1], a = 1 B = [0, 1, 0], b = 2 C = [0, 0, 1, 1], c = 3 A = [1, 1, 1], a = 7 B = [1, 1, 1], b = 7 C = [1, 1, 1, 0], c = 14 A = [1], a = 1 B = [1], b = 1 C = [1, 0], c = 2","title":"Exercise 2.1"},{"location":"CLRS/ch02-getting-started/exercise-2.1/#exercise-21-1","text":"Using Figure 2.2 as a model, illustrate the operation of INSERTION-SORT on the array A = [31, 41, 59, 26, 41, 58] . Iteration 1 1 2 3 4 5 6 [31 41 59 26 41 58] Iteration 2 1 2 3 4 5 6 [31 41 59 26 41 58] Iteration 3 1 2 3 4 5 6 [31 41 59 26 41 58] Iteration 4 1 2 3 4 5 6 [26 31 41 59 41 58] Iteration 5 1 2 3 4 5 6 [26 31 41 41 59 58] Iteration 6 1 2 3 4 5 6 [26 31 41 41 58 59]","title":"Exercise 2.1-1"},{"location":"CLRS/ch02-getting-started/exercise-2.1/#exercise-21-2","text":"Rewrite the INSERTION-SORT procedure to sort into nonincreasing instead of non-decreasing order. NON-INCREASING INSERTION-SORT(A) 1 for j = 2 to A.length 2 key = A[j] 3 // Insert A[j] into the sorted sequence A[1..j-1] 4 i = j -1 5 while i > 0 and A[i] < key 6 A[i+1] = A[i] 7 i = i - 1 8 A[i+1] = key Python code def insertion_sort ( A ): \"\"\"Sorts the array `A` in descending order using `Insertion sort` algorithm Args: A: Array of numbers to be sorted Returns: Array of numbers in sorted, descending order \"\"\" for j in range ( 1 , len ( A )): key = A [ j ] # Insert A[j] into the sorted sequence A[0..j-1] i = j - 1 while i > - 1 and A [ i ] < key : A [ i + 1 ] = A [ i ] i = i - 1 A [ i + 1 ] = key return A tests = [ [ 31 , 41 , 59 , 26 , 41 , 58 ], [], [ 40 , 20 ], [ 1 ], [ 10 , 9 , 8 , 7 ], [ 7 , 8 , 9 , 10 ] ] for input_array in tests : print ( f 'Input: {input_array}' ) output_array = insertion_sort ( input_array ) print ( f 'Sorted: {output_array} \\n ' ) Input: [31, 41, 59, 26, 41, 58] Sorted: [59, 58, 41, 41, 31, 26] Input: [] Sorted: [] Input: [40, 20] Sorted: [40, 20] Input: [1] Sorted: [1] Input: [10, 9, 8, 7] Sorted: [10, 9, 8, 7] Input: [7, 8, 9, 10] Sorted: [10, 9, 8, 7]","title":"Exercise 2.1-2"},{"location":"CLRS/ch02-getting-started/exercise-2.1/#exercise-21-3","text":"Consider the searching problem : Input : A sequence of n numbers A = \\langle a_1, a_2, ... , a_n \\rangle A = \\langle a_1, a_2, ... , a_n \\rangle and a value v Output : An index i such that v=A[i] v=A[i] or the special value NIL if v does not appear in A . Write pseudocode for linear search , which scans through the sequence, looking for v . Using a loop invariant, prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties. Pseudocode LINEAR-SEARCH(A, V) 1 i = NIL 2 for j = 1 to A.length 3 if A[j] = v 4 i = j 5 return i 6 return i Proof using Loop invariant Invariant : At any point of time, the variable i holds the value of the index, till the point array has been scanned. Initialization : Before the loop starts, the value of i is NIL , which is the right value since the array has not yet been searched, and assumed value is NIL Maintenance : At each iteration, if v is equal to current element in A , value of that index j is assigned to i , which is the correct value to be returned. If not, value of i is still NIL . Termination : If the loop is termintaed, it means that v is not found in A, and hence value of i remains NIL . Hence the algorithm is correct Python Program def linear_search ( A , v ): \"\"\"Performs a linear search for `v` in array `A` Args: A: Array of numbers v: Number to be searched in `A` Returns: Index of the array A, if v is found in A `None` if v is not found in A \"\"\" for j in range ( 0 , len ( A )): if A [ j ] == v : return j return None tests = [ [[ 31 , 41 , 59 , 26 , 41 , 58 ], 41 ], [[ 35 , 43 , 19 ], 20 ], [[], 5 ], [[ 1 ], 1 ], [[ 3 ], - 5 ], [[ 5 , 7 , 8 ], 5 ], [[ 5 , 7 , 8 ], 8 ] ] for A , v in tests : print ( f 'Input: A = {A}, v = {v}' ) index = linear_search ( A , v ) print ( f 'Index: {index} \\n ' ) Input: A = [31, 41, 59, 26, 41, 58], v = 41 Index: 1 Input: A = [35, 43, 19], v = 20 Index: None Input: A = [], v = 5 Index: None Input: A = [1], v = 1 Index: 0 Input: A = [3], v = -5 Index: None Input: A = [5, 7, 8], v = 5 Index: 0 Input: A = [5, 7, 8], v = 8 Index: 2","title":"Exercise 2.1-3"},{"location":"CLRS/ch02-getting-started/exercise-2.1/#exercise-21-4","text":"Consider the problem of adding two n -bit binary integers, stored in two n -element arrays A and B . The sum of the two integers should be stored in binary form in an (n + 1) -element array C . State the problem formally and write pseudocode for adding the two integers. Input : Arrays A and B of length n containing binary digits 0 and 1 of two numbers a and b Output : Array C of length n + 1 containing binary digits of a + b Pseudocode ADD BINARY INTEGERS(A, B) 1 carry = 0 2 for i = n downto 1 3 sum = A[i] + B[i] + carry 4 C[i + 1] = sum (mod 2) 5 if sum > 1 6 carry = 1 7 else 8 carry = 0 9 C[1] = carry Python code def add_binary_integers ( A , B ): \"\"\"Adds two binary integers Args: A: Array of 0 and 1 representing binary digits B: Array of 0 and 1 representing binary digits Returns: C: Array of 0 and 1 representing binary digits of A+B \"\"\" carry = 0 n = len ( A ) C = [ 0 for x in range ( n + 1 )] for i in range ( len ( A ) - 1 , - 1 , - 1 ): s = A [ i ] + B [ i ] + carry C [ i + 1 ] = s % 2 if s > 1 : carry = 1 else : carry = 0 C [ 0 ] = carry return C tests = [ { \"A\" : [ 0 , 0 , 0 ], \"B\" : [ 0 , 0 , 0 ], \"a\" : 0 , \"b\" : 0 , \"c\" : 0 }, { \"A\" : [ 0 , 0 , 1 ], \"B\" : [ 0 , 1 , 0 ], \"a\" : 1 , \"b\" : 2 , \"c\" : 3 }, { \"A\" : [ 1 , 1 , 1 ], \"B\" : [ 1 , 1 , 1 ], \"a\" : 7 , \"b\" : 7 , \"c\" : 14 }, { \"A\" : [ 1 ], \"B\" : [ 1 ], \"a\" : 1 , \"b\" : 1 , \"c\" : 2 }, ] for test in tests : A , B , a , b , c = test [ \"A\" ], test [ \"B\" ], test [ \"a\" ], test [ \"b\" ], test [ \"c\" ] C = add_binary_integers ( A , B ) print ( f 'A = {A}, a = {a}' ) print ( f 'B = {B}, b = {b}' ) print ( f 'C = {C}, c = {c} \\n ' ) A = [0, 0, 0], a = 0 B = [0, 0, 0], b = 0 C = [0, 0, 0, 0], c = 0 A = [0, 0, 1], a = 1 B = [0, 1, 0], b = 2 C = [0, 0, 1, 1], c = 3 A = [1, 1, 1], a = 7 B = [1, 1, 1], b = 7 C = [1, 1, 1, 0], c = 14 A = [1], a = 1 B = [1], b = 1 C = [1, 0], c = 2","title":"Exercise 2.1-4"},{"location":"CLRS/ch02-getting-started/exercise-2.2/","text":"Exercise 2.2-1 \u00b6 Express the function n^3/1000 - 100n^2 - 100n + 3 n^3/1000 - 100n^2 - 100n + 3 in terms of \\Theta \\Theta -notation n^3/1000 - 100n^2 - 100n + 3 = \\Theta(n^3) n^3/1000 - 100n^2 - 100n + 3 = \\Theta(n^3) Exercise 2.2-2 \u00b6 Consider sorting n numbers stored in array A by first finding the smallest element of A and exchanging it with the element in A[1] . Then find the second smallest element of A , and exchange it with A[2] . Continue in this manner for the first n - 1 elements of A . Write pseudocode for this algorithm, which is known as selection sort . What loop invariant does this algorithm maintain? Why does it need to run for only the first n - 1 elements, rather than for all n elements? Give the best-case and worst-case running times of selection sort in \\Theta \\Theta -notation. Pseudocode SELECTION-SORT(A) 1 for i = 1 to n - 1 2 min = i 3 for j = i + 1 to n 4 if A[j] < min 5 min = A[j] 6 swap(A[min], A[i]) Loop Invariant : At each iteration i , subarray A[1..i-1] is in sorted order. The algorithm need to run only for the first n - 1 elements because, after completing n - 1 iterations, the subarray A[1..n-1] contains the first n - 1 smallest elements of the array A . Hence the last element A[n] is always the maximum element which is already in the right place. For selection sort , the best case and worst case running time are \\Theta(n^2) \\Theta(n^2) . This is because, both the outer and inner loops are executed regardless of the elements. Python code def selection_sort ( A ): \"\"\"Sorts the array `A` in ascending order using `Selection sort` algorithm Args: A: Array of numbers to be sorted Returns: Array of numbers in sorted, ascending order \"\"\" for i in range ( 0 , len ( A ) - 1 ): min_index = i for j in range ( i + 1 , len ( A )): if A [ j ] < A [ min_index ]: min_index = j A [ min_index ], A [ i ] = A [ i ], A [ min_index ] # Swap return A tests = [ [ 31 , 41 , 59 , 26 , 41 , 58 ], [], [ 40 , 20 ], [ 1 ], [ 10 , 9 , 8 , 7 ], [ 7 , 8 , 9 , 10 ] ] for input_array in tests : print ( f 'Input: {input_array}' ) output_array = selection_sort ( input_array ) print ( f 'Sorted: {output_array} \\n ' ) Input: [31, 41, 59, 26, 41, 58] Sorted: [26, 31, 41, 41, 58, 59] Input: [] Sorted: [] Input: [40, 20] Sorted: [20, 40] Input: [1] Sorted: [1] Input: [10, 9, 8, 7] Sorted: [7, 8, 9, 10] Input: [7, 8, 9, 10] Sorted: [7, 8, 9, 10] Exercise 2.2-3 \u00b6 Consider linear search again (see Exercise 2.1-3). How many elements of the input sequence need to be checked on the average, assuming that the element being searched for is equally likely to be any element in the array? How about in the worst case? What are the average-case and worst-case running times of linear search in \\Theta \\Theta -notation? Justify your answers. For simplicity assume that, average case means the element is found midway. If there are n elements in the array A , then on an average n/2 elements need to be checked. If the value we are looking for is not present in the array, we would have to scan the entire array. Hence worst case , we need to check all the n elements. Let us calculate the running time of Linear search LINE cost times 1 i = NIL c1 1 2 for j = 1 to A.length c2 n+1 3 if A[j] = v c3 n 4 i = j c4 1 or 0 5 return i c5 1 or 0 6 return i c6 1 For worst case , T(n) = c_1 + (n+1)\\cdot c_2 + n\\cdot c_3 + 1 T(n) = c_1 + (n+1)\\cdot c_2 + n\\cdot c_3 + 1 = (c_2 + c_3)n + (c1 + c2 + c3 + 1) = (c_2 + c_3)n + (c1 + c2 + c3 + 1) T(n) = \\Theta(n) T(n) = \\Theta(n) For average case T(n) = c_1 + (\\frac{n+1}{2})\\cdot c_2 + \\frac{n}{2} \\cdot c_3 + 1 + 1 T(n) = c_1 + (\\frac{n+1}{2})\\cdot c_2 + \\frac{n}{2} \\cdot c_3 + 1 + 1 = (\\frac{c_2 + c_3}{2})\\cdot n + (c_1 + \\frac{c_2}{2} + 2) = (\\frac{c_2 + c_3}{2})\\cdot n + (c_1 + \\frac{c_2}{2} + 2) T(n) = \\Theta(n) T(n) = \\Theta(n) Exercise 2.2-4 \u00b6 How can we modify almost any algorithm to have a good best-case running time? To achieve good best-case running time, predefine or generate an output before running the actual steps. Check if the output satisfies the goal or termination invariant. For example, in Insertion sort, predefine output same as input. In best case, it would already be in sorted order.","title":"Exercise 2.2"},{"location":"CLRS/ch02-getting-started/exercise-2.2/#exercise-22-1","text":"Express the function n^3/1000 - 100n^2 - 100n + 3 n^3/1000 - 100n^2 - 100n + 3 in terms of \\Theta \\Theta -notation n^3/1000 - 100n^2 - 100n + 3 = \\Theta(n^3) n^3/1000 - 100n^2 - 100n + 3 = \\Theta(n^3)","title":"Exercise 2.2-1"},{"location":"CLRS/ch02-getting-started/exercise-2.2/#exercise-22-2","text":"Consider sorting n numbers stored in array A by first finding the smallest element of A and exchanging it with the element in A[1] . Then find the second smallest element of A , and exchange it with A[2] . Continue in this manner for the first n - 1 elements of A . Write pseudocode for this algorithm, which is known as selection sort . What loop invariant does this algorithm maintain? Why does it need to run for only the first n - 1 elements, rather than for all n elements? Give the best-case and worst-case running times of selection sort in \\Theta \\Theta -notation. Pseudocode SELECTION-SORT(A) 1 for i = 1 to n - 1 2 min = i 3 for j = i + 1 to n 4 if A[j] < min 5 min = A[j] 6 swap(A[min], A[i]) Loop Invariant : At each iteration i , subarray A[1..i-1] is in sorted order. The algorithm need to run only for the first n - 1 elements because, after completing n - 1 iterations, the subarray A[1..n-1] contains the first n - 1 smallest elements of the array A . Hence the last element A[n] is always the maximum element which is already in the right place. For selection sort , the best case and worst case running time are \\Theta(n^2) \\Theta(n^2) . This is because, both the outer and inner loops are executed regardless of the elements. Python code def selection_sort ( A ): \"\"\"Sorts the array `A` in ascending order using `Selection sort` algorithm Args: A: Array of numbers to be sorted Returns: Array of numbers in sorted, ascending order \"\"\" for i in range ( 0 , len ( A ) - 1 ): min_index = i for j in range ( i + 1 , len ( A )): if A [ j ] < A [ min_index ]: min_index = j A [ min_index ], A [ i ] = A [ i ], A [ min_index ] # Swap return A tests = [ [ 31 , 41 , 59 , 26 , 41 , 58 ], [], [ 40 , 20 ], [ 1 ], [ 10 , 9 , 8 , 7 ], [ 7 , 8 , 9 , 10 ] ] for input_array in tests : print ( f 'Input: {input_array}' ) output_array = selection_sort ( input_array ) print ( f 'Sorted: {output_array} \\n ' ) Input: [31, 41, 59, 26, 41, 58] Sorted: [26, 31, 41, 41, 58, 59] Input: [] Sorted: [] Input: [40, 20] Sorted: [20, 40] Input: [1] Sorted: [1] Input: [10, 9, 8, 7] Sorted: [7, 8, 9, 10] Input: [7, 8, 9, 10] Sorted: [7, 8, 9, 10]","title":"Exercise 2.2-2"},{"location":"CLRS/ch02-getting-started/exercise-2.2/#exercise-22-3","text":"Consider linear search again (see Exercise 2.1-3). How many elements of the input sequence need to be checked on the average, assuming that the element being searched for is equally likely to be any element in the array? How about in the worst case? What are the average-case and worst-case running times of linear search in \\Theta \\Theta -notation? Justify your answers. For simplicity assume that, average case means the element is found midway. If there are n elements in the array A , then on an average n/2 elements need to be checked. If the value we are looking for is not present in the array, we would have to scan the entire array. Hence worst case , we need to check all the n elements. Let us calculate the running time of Linear search LINE cost times 1 i = NIL c1 1 2 for j = 1 to A.length c2 n+1 3 if A[j] = v c3 n 4 i = j c4 1 or 0 5 return i c5 1 or 0 6 return i c6 1 For worst case , T(n) = c_1 + (n+1)\\cdot c_2 + n\\cdot c_3 + 1 T(n) = c_1 + (n+1)\\cdot c_2 + n\\cdot c_3 + 1 = (c_2 + c_3)n + (c1 + c2 + c3 + 1) = (c_2 + c_3)n + (c1 + c2 + c3 + 1) T(n) = \\Theta(n) T(n) = \\Theta(n) For average case T(n) = c_1 + (\\frac{n+1}{2})\\cdot c_2 + \\frac{n}{2} \\cdot c_3 + 1 + 1 T(n) = c_1 + (\\frac{n+1}{2})\\cdot c_2 + \\frac{n}{2} \\cdot c_3 + 1 + 1 = (\\frac{c_2 + c_3}{2})\\cdot n + (c_1 + \\frac{c_2}{2} + 2) = (\\frac{c_2 + c_3}{2})\\cdot n + (c_1 + \\frac{c_2}{2} + 2) T(n) = \\Theta(n) T(n) = \\Theta(n)","title":"Exercise 2.2-3"},{"location":"CLRS/ch02-getting-started/exercise-2.2/#exercise-22-4","text":"How can we modify almost any algorithm to have a good best-case running time? To achieve good best-case running time, predefine or generate an output before running the actual steps. Check if the output satisfies the goal or termination invariant. For example, in Insertion sort, predefine output same as input. In best case, it would already be in sorted order.","title":"Exercise 2.2-4"},{"location":"CLRS/ch02-getting-started/exercise-2.3/","text":"Exercise 2.3-1 \u00b6 Using Figure 2.4 as a model, illustrate the operation of merge sort on the array A = [3, 41, 52, 26, 38, 57, 9, 49]. Exercise 2.3-2 \u00b6 Rewrite the MERGE procedure so that it does not use sentinels, instead stopping once either array L or R has had all its elements copied back to A and then copying the remainder of the other array back into A . Pseudocode MERGE(A, p, q, r) 1 n1 = q - p + 1 2 n2 = r - q 3 let L[1..n1+1] and R[1..n2+1] be new arrays 4 for i = 1 to n1 5 L[i] = A[p+i-1] 6 for j = 1 to n2 7 R[j] = A[q+j] 10 i = 1 11 j = 1 12 k = p 13 while i != n1 + 1 and j != n2 + 1 14 if L[i] <= R[j] 15 A[k] = L[i] 16 i = i + 1 17 else 18 A[k] = R[j] 19 j = j + 1 20 k = k + 1 21 if i = n1 + 1 22 for s = j to n2 23 A[k] = R[s] 24 k = k + 1 25 if j = n2 + 1 26 for s = i to n1 27 A[k] = L[s] 28 k = k + 1 Python code def merge ( A , p , q , r ): \"\"\"Merges sorted subarrays This procedure assumes that the subarrays A[p..q] and A[q+1..r] are sorted. Merges the subarrays to form single sorted subarray A[p..r] Args: A: Array to be sorted p: Index of start of first subarray q: Index of end of first subarray r: Index of end of second subarray \"\"\" n1 = q - p + 1 # length of subarray A[p..q] n2 = r - q # length of subarray A[q+1..r] # Initialize arrays L and R L = [ A [ p + i ] for i in range ( 0 , n1 )] R = [ A [ q + j + 1 ] for j in range ( 0 , n2 )] # Construct A[p..r] from L and R in sorted order i , j , k = 0 , 0 , p while i != n1 and j != n2 : if L [ i ] <= R [ j ]: A [ k ] = L [ i ] i += 1 else : A [ k ] = R [ j ] j += 1 k += 1 if i == n1 : for s in range ( j , n2 ): A [ k ] = R [ s ] k += 1 if j == n2 : for s in range ( i , n1 ): A [ k ] = L [ s ] k += 1 return A def merge_sort ( A ): \"\"\"Sorts the array `A` in ascending order using `Merge sort` algorithm Args: A: Array of numbers to be sorted Returns: Array of numbers in sorted, ascending order \"\"\" # Recursively callable method def merge_sort_r ( A , p , r ): if p < r : q = ( p + r ) // 2 merge_sort_r ( A , p , q ) # Sort first half merge_sort_r ( A , q + 1 , r ) # Sort second half merge ( A , p , q , r ) # Merge first and second half merge_sort_r ( A , 0 , len ( A ) - 1 ) return A tests = [ [ 31 , 41 , 59 , 26 , 41 , 58 ], [], [ 40 , 20 ], [ 1 ], [ 10 , 9 , 8 , 7 ], [ 7 , 8 , 9 , 10 ] ] for input_array in tests : print ( f 'Input: {input_array}' ) output_array = merge_sort ( input_array ) print ( f 'Sorted: {output_array} \\n ' ) Input: [31, 41, 59, 26, 41, 58] Sorted: [26, 31, 41, 41, 58, 59] Input: [] Sorted: [] Input: [40, 20] Sorted: [20, 40] Input: [1] Sorted: [1] Input: [10, 9, 8, 7] Sorted: [7, 8, 9, 10] Input: [7, 8, 9, 10] Sorted: [7, 8, 9, 10] Exercise 2.3-3 \u00b6 Use mathematical induction to show that when n is an exact power of 2, the solution of the recurrence: T(n) = \\left\\{ \\begin{array}{l} 2 & \\text{if } n=2\\\\ 2T(n/2)+n & \\text{if } n = 2^k, \\text{ for } k > 1 \\end{array} \\right. T(n) = \\left\\{ \\begin{array}{l} 2 & \\text{if } n=2\\\\ 2T(n/2)+n & \\text{if } n = 2^k, \\text{ for } k > 1 \\end{array} \\right. is T(n) = n \\text{ lg } n T(n) = n \\text{ lg } n Proof by mathematical induction For, n = 2 T(n) = nlog_2{n} = 2 log_2{2} = 2 T(n) = nlog_2{n} = 2 log_2{2} = 2 Hence, the equation is true for n = 2 (base case) Also, if n = 2^k n = 2^k , assume it is true for k . For k+1 , T(2^{k+1}) = 2T(\\frac{2^{k+1}}{2}) + 2^{k+1} \\\\ = 2T(2^k) + 2^{k+1} T(2^{k+1}) = 2T(\\frac{2^{k+1}}{2}) + 2^{k+1} \\\\ = 2T(2^k) + 2^{k+1} Substituting for T(2^k) T(2^k) , = 2(2^k \\cdot log_2{2^k}) + 2^{k+1} \\\\ = k \\cdot 2^{k+1} + 2^{k+1} \\\\ = (k + 1) \\cdot 2^{k+1} \\\\ = n \\cdot log_2{n} = 2(2^k \\cdot log_2{2^k}) + 2^{k+1} \\\\ = k \\cdot 2^{k+1} + 2^{k+1} \\\\ = (k + 1) \\cdot 2^{k+1} \\\\ = n \\cdot log_2{n} Hence, by Mathametical Induction, the equation is true for all n = 2^k, \\text{ for } k > 1 n = 2^k, \\text{ for } k > 1 Exercise 2.3-4 \u00b6 We can express insertion sort as a recursive procedure as follows. In order to sort A[1..n] , we recursively sort A[1..n-1] and then insert A[n] into the sorted array A[1..n-1] . Write a recurrence for the running time of this recursive version of insertion sort. To sort array A[1..n-1] , it takes \\Theta(n) \\Theta(n) time. Hence, T(n) = \\left\\{ \\begin{array}{l} \\Theta(1) & \\text{if } n=1\\\\ T(n-1) + \\Theta(n) & \\text{if } n > 1 \\end{array} \\right. T(n) = \\left\\{ \\begin{array}{l} \\Theta(1) & \\text{if } n=1\\\\ T(n-1) + \\Theta(n) & \\text{if } n > 1 \\end{array} \\right. which gives, $$ T(n) = \\Theta(n^2) $$ Python code (recursive) def insertion_sort ( A ): \"\"\"Sorts the array `A` in ascending order using `Insertion sort` algorithm, recursively Args: A: Array of numbers to be sorted Returns: Array of numbers in sorted, ascending order \"\"\" def rec ( A , n ): if n == 2 and A [ 0 ] > A [ 1 ]: A [ 0 ], A [ 1 ] = A [ 1 ], A [ 0 ] elif n > 2 : # (i) Sort A[1 .. n - 1] recursively rec ( A , n - 1 ) # (ii) Insert A[n] into sorted array A[1 .. n - 1] key = A [ n - 1 ] # nth element i = n - 2 while i > - 1 and A [ i ] > key : A [ i + 1 ] = A [ i ] i = i - 1 A [ i + 1 ] = key rec ( A , len ( A )) return A tests = [ [ 31 , 41 , 59 , 26 , 41 , 58 ], [], [ 40 , 20 ], [ 1 ], [ 10 , 9 , 8 , 7 ], [ 7 , 8 , 9 , 10 ] ] for input_array in tests : print ( f 'Input: {input_array}' ) output_array = insertion_sort ( input_array ) print ( f 'Sorted: {output_array} \\n ' ) Input: [31, 41, 59, 26, 41, 58] Sorted: [26, 31, 41, 41, 58, 59] Input: [] Sorted: [] Input: [40, 20] Sorted: [20, 40] Input: [1] Sorted: [1] Input: [10, 9, 8, 7] Sorted: [7, 8, 9, 10] Input: [7, 8, 9, 10] Sorted: [7, 8, 9, 10] Exercise 2.3-5 \u00b6 Referring back to the searching problem (see Exercise 2.1-3), observe that if the sequence A is sorted, we can check the midpoint of the sequence against v v and eliminate half of the sequence from further consideration. The binary search algorithm repeats this procedure, halving the size of the remaining portion of the sequence each time. Write pseudocode, either iterative or recursive, for binary search. Argue that the worst-case running time of binary search is \\Theta(n\\cdot log_2(n)) \\Theta(n\\cdot log_2(n)) Pseudo code (Iterative) BINARY-SEARCH(A, v) 1 low = 1, high = A.length 2 while low <= high 3 mid = (low + high) / 2 4 if A[mid] = v 5 return mid 6 else if A[mid] > v 7 high = mid - 1 8 else 9 low = mid + 1 10 return NIL Python code (Iterative) def binary_search ( A , element ): \"\"\"Performs search for `element` in A using binary search algorithm Args: A: Input array element: Target element to be found in A Returns: Index of the element, if found, -1 otherwise \"\"\" low , high = 0 , len ( A ) - 1 while low <= high : mid = ( low + high ) // 2 if A [ mid ] == element : return mid elif A [ mid ] > element : high = mid - 1 else : low = mid + 1 return - 1 tests = [ { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 1 , \"index\" : 0 }, { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 9 , \"index\" : 4 }, { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 4 , \"index\" : 1 }, { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 6 , \"index\" : 3 }, { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 3 , \"index\" : - 1 }, ] for test in tests : A , v , index = test [ \"A\" ], test [ \"v\" ], test [ \"index\" ] res = binary_search ( A , v ) print ( f 'A = {A}' ) print ( f 'v = {v}' ) print ( f 'Expected index = {index}' ) print ( f 'Actual index = {res} \\n ' ) A = [1, 4, 5, 6, 9] v = 1 Expected index = 0 Actual index = 0 A = [1, 4, 5, 6, 9] v = 9 Expected index = 4 Actual index = 4 A = [1, 4, 5, 6, 9] v = 4 Expected index = 1 Actual index = 1 A = [1, 4, 5, 6, 9] v = 6 Expected index = 3 Actual index = 3 A = [1, 4, 5, 6, 9] v = 3 Expected index = -1 Actual index = -1 Pseudo code (Recursive) BINARY-SEARCH(A, v, low, high) 1 if low > high 2 return NIL 3 mid = (low + high) / 2 4 if A[mid] = v 5 return mid 6 else if A[mid] > v 7 BINARY-SEARCH(A, v, low, mid - 1) 8 else 9 BINARY-SEARCH(A, v, mid + 1, high) BINARY-SEARCH(A, v, 1, A.length) Python code (Recursive) def binary_search ( A , element ): \"\"\"Performs search for `element` in A using binary search algorithm Args: A: Input array element: Target element to be found in A Returns: Index of the element, if found, -1 otherwise \"\"\" def search ( low , high ): if low > high : return - 1 mid = ( low + high ) // 2 if A [ mid ] == element : return mid elif A [ mid ] > element : return search ( low , mid - 1 ) else : return search ( mid + 1 , high ) return search ( 0 , len ( A ) - 1 ) tests = [ { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 1 , \"index\" : 0 }, { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 9 , \"index\" : 4 }, { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 4 , \"index\" : 1 }, { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 6 , \"index\" : 3 }, { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 3 , \"index\" : - 1 }, ] for test in tests : A , v , index = test [ \"A\" ], test [ \"v\" ], test [ \"index\" ] res = binary_search ( A , v ) print ( f 'A = {A}' ) print ( f 'v = {v}' ) print ( f 'Expected index = {index}' ) print ( f 'Actual index = {res} \\n ' ) A = [1, 4, 5, 6, 9] v = 1 Expected index = 0 Actual index = 0 A = [1, 4, 5, 6, 9] v = 9 Expected index = 4 Actual index = 4 A = [1, 4, 5, 6, 9] v = 4 Expected index = 1 Actual index = 1 A = [1, 4, 5, 6, 9] v = 6 Expected index = 3 Actual index = 3 A = [1, 4, 5, 6, 9] v = 3 Expected index = -1 Actual index = -1 In worst case, v v can be the first or last element. Search range becomes half at each iteration if v v is not the middle element of the current range. Hence, T(n) = T(n/2) + \\Theta(1) T(n) = T(n/2) + \\Theta(1) which gives, T(n) = \\Theta(log_2(n)) T(n) = \\Theta(log_2(n)) Exercise 2.3-6 \u00b6 Observe that the while loop of lines 5\u20137 of the INSERTION-SORT procedure in Section 2.1 uses a linear search to scan (backward) through the sorted subarray A[1 .. j - 1] . Can we use a binary search (see Exercise 2.3-5) instead to improve the overall worst-case running time of insertion sort to \\Theta(n\\cdot log_2{n}) \\Theta(n\\cdot log_2{n}) ? Line 5-7 are as follows, 5 while i > 0 and A[i] > key 6 A[i+1] = A[i] 7 i = i - 1 Using binary search will not improve the worst-case running time to \\Theta(n\\cdot log_2{n}) \\Theta(n\\cdot log_2{n}) . Binary search will only indicate the proper position to insert. Whereas, lines 5-7 of procedure INSERTION-SORT shifts the elements which are larger than A[j] A[j] . Shifting the elements takes \\Theta(j) \\Theta(j) time. Exercise 2.3-7 \u00b6 Describe a \\Theta(n\\cdot log_2n) \\Theta(n\\cdot log_2n) -time algorithm that, given a set S of n integers and another integer x , determines whether or not there exist two elements in S whose sum is exactly x . We can use Merge Sort to sort the set S , which takes \\Theta(n\\cdot log_2n) \\Theta(n\\cdot log_2n) time. Use sorted array S' to search from both the ends to find out if two elements exist whose sum is x , in \\Theta(n) \\Theta(n) time. Hence, overall running time is, T(n) = \\Theta(n\\cdot log_2n) + \\Theta(n) = \\Theta(n\\cdot log_2n) T(n) = \\Theta(n\\cdot log_2n) + \\Theta(n) = \\Theta(n\\cdot log_2n) Pseudocode SEARCH-FOR-PAIRS-OF-SUM(S, x) 1 Sort array S using Merge Sort 2 i = 1, j = S.length 3 while i < j 4 if S[i] + S[j] = x 5 return true 6 else if S[i] + S[j] < x 7 i = i + 1 8 else 9 j = j - 1 10 return false Python code def search_pairs_of_sum ( S , x ): \"\"\"Determines whether or not there exists 2 elements in S with sum x Args: S: Input array x: sum value Returns: True if 2 elements are found in S with sum=x, False otherwise \"\"\" S = sorted ( S ) # Use built-in sort method for simplicity i , j = 0 , len ( S ) - 1 while i < j : pair_sum = S [ i ] + S [ j ] if pair_sum == x : return True elif pair_sum < x : i += 1 else : j -= 1 return False tests = [ { \"S\" : [ 4 , 9 , 1 , 2 , 7 , 6 ], \"x\" : 10 , \"sum_exists\" : True }, { \"S\" : [ 4 , 9 , 1 , 2 , 7 , 6 ], \"x\" : 3 , \"sum_exists\" : True }, { \"S\" : [ 4 , 9 , 1 , 2 , 7 , 6 ], \"x\" : 12 , \"sum_exists\" : False } ] for test in tests : S , x , sum_exists = test [ \"S\" ], test [ \"x\" ], test [ \"sum_exists\" ] res = search_pairs_of_sum ( S , x ) print ( f 'S = {S}' ) print ( f 'x = {x}' ) print ( f 'Expected: {sum_exists}' ) print ( f 'Actual : {res} \\n ' ) S = [4, 9, 1, 2, 7, 6] x = 10 Expected: True Actual : True S = [4, 9, 1, 2, 7, 6] x = 3 Expected: True Actual : True S = [4, 9, 1, 2, 7, 6] x = 12 Expected: False Actual : False","title":"Exercise 2.3"},{"location":"CLRS/ch02-getting-started/exercise-2.3/#exercise-23-1","text":"Using Figure 2.4 as a model, illustrate the operation of merge sort on the array A = [3, 41, 52, 26, 38, 57, 9, 49].","title":"Exercise 2.3-1"},{"location":"CLRS/ch02-getting-started/exercise-2.3/#exercise-23-2","text":"Rewrite the MERGE procedure so that it does not use sentinels, instead stopping once either array L or R has had all its elements copied back to A and then copying the remainder of the other array back into A . Pseudocode MERGE(A, p, q, r) 1 n1 = q - p + 1 2 n2 = r - q 3 let L[1..n1+1] and R[1..n2+1] be new arrays 4 for i = 1 to n1 5 L[i] = A[p+i-1] 6 for j = 1 to n2 7 R[j] = A[q+j] 10 i = 1 11 j = 1 12 k = p 13 while i != n1 + 1 and j != n2 + 1 14 if L[i] <= R[j] 15 A[k] = L[i] 16 i = i + 1 17 else 18 A[k] = R[j] 19 j = j + 1 20 k = k + 1 21 if i = n1 + 1 22 for s = j to n2 23 A[k] = R[s] 24 k = k + 1 25 if j = n2 + 1 26 for s = i to n1 27 A[k] = L[s] 28 k = k + 1 Python code def merge ( A , p , q , r ): \"\"\"Merges sorted subarrays This procedure assumes that the subarrays A[p..q] and A[q+1..r] are sorted. Merges the subarrays to form single sorted subarray A[p..r] Args: A: Array to be sorted p: Index of start of first subarray q: Index of end of first subarray r: Index of end of second subarray \"\"\" n1 = q - p + 1 # length of subarray A[p..q] n2 = r - q # length of subarray A[q+1..r] # Initialize arrays L and R L = [ A [ p + i ] for i in range ( 0 , n1 )] R = [ A [ q + j + 1 ] for j in range ( 0 , n2 )] # Construct A[p..r] from L and R in sorted order i , j , k = 0 , 0 , p while i != n1 and j != n2 : if L [ i ] <= R [ j ]: A [ k ] = L [ i ] i += 1 else : A [ k ] = R [ j ] j += 1 k += 1 if i == n1 : for s in range ( j , n2 ): A [ k ] = R [ s ] k += 1 if j == n2 : for s in range ( i , n1 ): A [ k ] = L [ s ] k += 1 return A def merge_sort ( A ): \"\"\"Sorts the array `A` in ascending order using `Merge sort` algorithm Args: A: Array of numbers to be sorted Returns: Array of numbers in sorted, ascending order \"\"\" # Recursively callable method def merge_sort_r ( A , p , r ): if p < r : q = ( p + r ) // 2 merge_sort_r ( A , p , q ) # Sort first half merge_sort_r ( A , q + 1 , r ) # Sort second half merge ( A , p , q , r ) # Merge first and second half merge_sort_r ( A , 0 , len ( A ) - 1 ) return A tests = [ [ 31 , 41 , 59 , 26 , 41 , 58 ], [], [ 40 , 20 ], [ 1 ], [ 10 , 9 , 8 , 7 ], [ 7 , 8 , 9 , 10 ] ] for input_array in tests : print ( f 'Input: {input_array}' ) output_array = merge_sort ( input_array ) print ( f 'Sorted: {output_array} \\n ' ) Input: [31, 41, 59, 26, 41, 58] Sorted: [26, 31, 41, 41, 58, 59] Input: [] Sorted: [] Input: [40, 20] Sorted: [20, 40] Input: [1] Sorted: [1] Input: [10, 9, 8, 7] Sorted: [7, 8, 9, 10] Input: [7, 8, 9, 10] Sorted: [7, 8, 9, 10]","title":"Exercise 2.3-2"},{"location":"CLRS/ch02-getting-started/exercise-2.3/#exercise-23-3","text":"Use mathematical induction to show that when n is an exact power of 2, the solution of the recurrence: T(n) = \\left\\{ \\begin{array}{l} 2 & \\text{if } n=2\\\\ 2T(n/2)+n & \\text{if } n = 2^k, \\text{ for } k > 1 \\end{array} \\right. T(n) = \\left\\{ \\begin{array}{l} 2 & \\text{if } n=2\\\\ 2T(n/2)+n & \\text{if } n = 2^k, \\text{ for } k > 1 \\end{array} \\right. is T(n) = n \\text{ lg } n T(n) = n \\text{ lg } n Proof by mathematical induction For, n = 2 T(n) = nlog_2{n} = 2 log_2{2} = 2 T(n) = nlog_2{n} = 2 log_2{2} = 2 Hence, the equation is true for n = 2 (base case) Also, if n = 2^k n = 2^k , assume it is true for k . For k+1 , T(2^{k+1}) = 2T(\\frac{2^{k+1}}{2}) + 2^{k+1} \\\\ = 2T(2^k) + 2^{k+1} T(2^{k+1}) = 2T(\\frac{2^{k+1}}{2}) + 2^{k+1} \\\\ = 2T(2^k) + 2^{k+1} Substituting for T(2^k) T(2^k) , = 2(2^k \\cdot log_2{2^k}) + 2^{k+1} \\\\ = k \\cdot 2^{k+1} + 2^{k+1} \\\\ = (k + 1) \\cdot 2^{k+1} \\\\ = n \\cdot log_2{n} = 2(2^k \\cdot log_2{2^k}) + 2^{k+1} \\\\ = k \\cdot 2^{k+1} + 2^{k+1} \\\\ = (k + 1) \\cdot 2^{k+1} \\\\ = n \\cdot log_2{n} Hence, by Mathametical Induction, the equation is true for all n = 2^k, \\text{ for } k > 1 n = 2^k, \\text{ for } k > 1","title":"Exercise 2.3-3"},{"location":"CLRS/ch02-getting-started/exercise-2.3/#exercise-23-4","text":"We can express insertion sort as a recursive procedure as follows. In order to sort A[1..n] , we recursively sort A[1..n-1] and then insert A[n] into the sorted array A[1..n-1] . Write a recurrence for the running time of this recursive version of insertion sort. To sort array A[1..n-1] , it takes \\Theta(n) \\Theta(n) time. Hence, T(n) = \\left\\{ \\begin{array}{l} \\Theta(1) & \\text{if } n=1\\\\ T(n-1) + \\Theta(n) & \\text{if } n > 1 \\end{array} \\right. T(n) = \\left\\{ \\begin{array}{l} \\Theta(1) & \\text{if } n=1\\\\ T(n-1) + \\Theta(n) & \\text{if } n > 1 \\end{array} \\right. which gives, $$ T(n) = \\Theta(n^2) $$ Python code (recursive) def insertion_sort ( A ): \"\"\"Sorts the array `A` in ascending order using `Insertion sort` algorithm, recursively Args: A: Array of numbers to be sorted Returns: Array of numbers in sorted, ascending order \"\"\" def rec ( A , n ): if n == 2 and A [ 0 ] > A [ 1 ]: A [ 0 ], A [ 1 ] = A [ 1 ], A [ 0 ] elif n > 2 : # (i) Sort A[1 .. n - 1] recursively rec ( A , n - 1 ) # (ii) Insert A[n] into sorted array A[1 .. n - 1] key = A [ n - 1 ] # nth element i = n - 2 while i > - 1 and A [ i ] > key : A [ i + 1 ] = A [ i ] i = i - 1 A [ i + 1 ] = key rec ( A , len ( A )) return A tests = [ [ 31 , 41 , 59 , 26 , 41 , 58 ], [], [ 40 , 20 ], [ 1 ], [ 10 , 9 , 8 , 7 ], [ 7 , 8 , 9 , 10 ] ] for input_array in tests : print ( f 'Input: {input_array}' ) output_array = insertion_sort ( input_array ) print ( f 'Sorted: {output_array} \\n ' ) Input: [31, 41, 59, 26, 41, 58] Sorted: [26, 31, 41, 41, 58, 59] Input: [] Sorted: [] Input: [40, 20] Sorted: [20, 40] Input: [1] Sorted: [1] Input: [10, 9, 8, 7] Sorted: [7, 8, 9, 10] Input: [7, 8, 9, 10] Sorted: [7, 8, 9, 10]","title":"Exercise 2.3-4"},{"location":"CLRS/ch02-getting-started/exercise-2.3/#exercise-23-5","text":"Referring back to the searching problem (see Exercise 2.1-3), observe that if the sequence A is sorted, we can check the midpoint of the sequence against v v and eliminate half of the sequence from further consideration. The binary search algorithm repeats this procedure, halving the size of the remaining portion of the sequence each time. Write pseudocode, either iterative or recursive, for binary search. Argue that the worst-case running time of binary search is \\Theta(n\\cdot log_2(n)) \\Theta(n\\cdot log_2(n)) Pseudo code (Iterative) BINARY-SEARCH(A, v) 1 low = 1, high = A.length 2 while low <= high 3 mid = (low + high) / 2 4 if A[mid] = v 5 return mid 6 else if A[mid] > v 7 high = mid - 1 8 else 9 low = mid + 1 10 return NIL Python code (Iterative) def binary_search ( A , element ): \"\"\"Performs search for `element` in A using binary search algorithm Args: A: Input array element: Target element to be found in A Returns: Index of the element, if found, -1 otherwise \"\"\" low , high = 0 , len ( A ) - 1 while low <= high : mid = ( low + high ) // 2 if A [ mid ] == element : return mid elif A [ mid ] > element : high = mid - 1 else : low = mid + 1 return - 1 tests = [ { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 1 , \"index\" : 0 }, { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 9 , \"index\" : 4 }, { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 4 , \"index\" : 1 }, { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 6 , \"index\" : 3 }, { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 3 , \"index\" : - 1 }, ] for test in tests : A , v , index = test [ \"A\" ], test [ \"v\" ], test [ \"index\" ] res = binary_search ( A , v ) print ( f 'A = {A}' ) print ( f 'v = {v}' ) print ( f 'Expected index = {index}' ) print ( f 'Actual index = {res} \\n ' ) A = [1, 4, 5, 6, 9] v = 1 Expected index = 0 Actual index = 0 A = [1, 4, 5, 6, 9] v = 9 Expected index = 4 Actual index = 4 A = [1, 4, 5, 6, 9] v = 4 Expected index = 1 Actual index = 1 A = [1, 4, 5, 6, 9] v = 6 Expected index = 3 Actual index = 3 A = [1, 4, 5, 6, 9] v = 3 Expected index = -1 Actual index = -1 Pseudo code (Recursive) BINARY-SEARCH(A, v, low, high) 1 if low > high 2 return NIL 3 mid = (low + high) / 2 4 if A[mid] = v 5 return mid 6 else if A[mid] > v 7 BINARY-SEARCH(A, v, low, mid - 1) 8 else 9 BINARY-SEARCH(A, v, mid + 1, high) BINARY-SEARCH(A, v, 1, A.length) Python code (Recursive) def binary_search ( A , element ): \"\"\"Performs search for `element` in A using binary search algorithm Args: A: Input array element: Target element to be found in A Returns: Index of the element, if found, -1 otherwise \"\"\" def search ( low , high ): if low > high : return - 1 mid = ( low + high ) // 2 if A [ mid ] == element : return mid elif A [ mid ] > element : return search ( low , mid - 1 ) else : return search ( mid + 1 , high ) return search ( 0 , len ( A ) - 1 ) tests = [ { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 1 , \"index\" : 0 }, { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 9 , \"index\" : 4 }, { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 4 , \"index\" : 1 }, { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 6 , \"index\" : 3 }, { \"A\" : [ 1 , 4 , 5 , 6 , 9 ], \"v\" : 3 , \"index\" : - 1 }, ] for test in tests : A , v , index = test [ \"A\" ], test [ \"v\" ], test [ \"index\" ] res = binary_search ( A , v ) print ( f 'A = {A}' ) print ( f 'v = {v}' ) print ( f 'Expected index = {index}' ) print ( f 'Actual index = {res} \\n ' ) A = [1, 4, 5, 6, 9] v = 1 Expected index = 0 Actual index = 0 A = [1, 4, 5, 6, 9] v = 9 Expected index = 4 Actual index = 4 A = [1, 4, 5, 6, 9] v = 4 Expected index = 1 Actual index = 1 A = [1, 4, 5, 6, 9] v = 6 Expected index = 3 Actual index = 3 A = [1, 4, 5, 6, 9] v = 3 Expected index = -1 Actual index = -1 In worst case, v v can be the first or last element. Search range becomes half at each iteration if v v is not the middle element of the current range. Hence, T(n) = T(n/2) + \\Theta(1) T(n) = T(n/2) + \\Theta(1) which gives, T(n) = \\Theta(log_2(n)) T(n) = \\Theta(log_2(n))","title":"Exercise 2.3-5"},{"location":"CLRS/ch02-getting-started/exercise-2.3/#exercise-23-6","text":"Observe that the while loop of lines 5\u20137 of the INSERTION-SORT procedure in Section 2.1 uses a linear search to scan (backward) through the sorted subarray A[1 .. j - 1] . Can we use a binary search (see Exercise 2.3-5) instead to improve the overall worst-case running time of insertion sort to \\Theta(n\\cdot log_2{n}) \\Theta(n\\cdot log_2{n}) ? Line 5-7 are as follows, 5 while i > 0 and A[i] > key 6 A[i+1] = A[i] 7 i = i - 1 Using binary search will not improve the worst-case running time to \\Theta(n\\cdot log_2{n}) \\Theta(n\\cdot log_2{n}) . Binary search will only indicate the proper position to insert. Whereas, lines 5-7 of procedure INSERTION-SORT shifts the elements which are larger than A[j] A[j] . Shifting the elements takes \\Theta(j) \\Theta(j) time.","title":"Exercise 2.3-6"},{"location":"CLRS/ch02-getting-started/exercise-2.3/#exercise-23-7","text":"Describe a \\Theta(n\\cdot log_2n) \\Theta(n\\cdot log_2n) -time algorithm that, given a set S of n integers and another integer x , determines whether or not there exist two elements in S whose sum is exactly x . We can use Merge Sort to sort the set S , which takes \\Theta(n\\cdot log_2n) \\Theta(n\\cdot log_2n) time. Use sorted array S' to search from both the ends to find out if two elements exist whose sum is x , in \\Theta(n) \\Theta(n) time. Hence, overall running time is, T(n) = \\Theta(n\\cdot log_2n) + \\Theta(n) = \\Theta(n\\cdot log_2n) T(n) = \\Theta(n\\cdot log_2n) + \\Theta(n) = \\Theta(n\\cdot log_2n) Pseudocode SEARCH-FOR-PAIRS-OF-SUM(S, x) 1 Sort array S using Merge Sort 2 i = 1, j = S.length 3 while i < j 4 if S[i] + S[j] = x 5 return true 6 else if S[i] + S[j] < x 7 i = i + 1 8 else 9 j = j - 1 10 return false Python code def search_pairs_of_sum ( S , x ): \"\"\"Determines whether or not there exists 2 elements in S with sum x Args: S: Input array x: sum value Returns: True if 2 elements are found in S with sum=x, False otherwise \"\"\" S = sorted ( S ) # Use built-in sort method for simplicity i , j = 0 , len ( S ) - 1 while i < j : pair_sum = S [ i ] + S [ j ] if pair_sum == x : return True elif pair_sum < x : i += 1 else : j -= 1 return False tests = [ { \"S\" : [ 4 , 9 , 1 , 2 , 7 , 6 ], \"x\" : 10 , \"sum_exists\" : True }, { \"S\" : [ 4 , 9 , 1 , 2 , 7 , 6 ], \"x\" : 3 , \"sum_exists\" : True }, { \"S\" : [ 4 , 9 , 1 , 2 , 7 , 6 ], \"x\" : 12 , \"sum_exists\" : False } ] for test in tests : S , x , sum_exists = test [ \"S\" ], test [ \"x\" ], test [ \"sum_exists\" ] res = search_pairs_of_sum ( S , x ) print ( f 'S = {S}' ) print ( f 'x = {x}' ) print ( f 'Expected: {sum_exists}' ) print ( f 'Actual : {res} \\n ' ) S = [4, 9, 1, 2, 7, 6] x = 10 Expected: True Actual : True S = [4, 9, 1, 2, 7, 6] x = 3 Expected: True Actual : True S = [4, 9, 1, 2, 7, 6] x = 12 Expected: False Actual : False","title":"Exercise 2.3-7"},{"location":"CLRS/ch02-getting-started/insertion-sort/","text":"Insertion Sort \u00b6 Pseudocode INSERTION-SORT(A) 1 for j = 2 to A.length 2 key = A[j] 3 // Insert A[j] into the sorted sequence A[1..j-1] 4 i = j -1 5 while i > 0 and A[i] > key 6 A[i+1] = A[i] 7 i = i - 1 8 A[i+1] = key Python code def insertion_sort ( A ): \"\"\"Sorts the array `A` in ascending order using `Insertion sort` algorithm Args: A: Array of numbers to be sorted Returns: Array of numbers in sorted, ascending order \"\"\" for j in range ( 1 , len ( A )): key = A [ j ] # Insert A[j] into the sorted sequence A[0..j-1] i = j - 1 while i > - 1 and A [ i ] > key : A [ i + 1 ] = A [ i ] i = i - 1 A [ i + 1 ] = key return A tests = [ [ 31 , 41 , 59 , 26 , 41 , 58 ], [], [ 40 , 20 ], [ 1 ], [ 10 , 9 , 8 , 7 ], [ 7 , 8 , 9 , 10 ] ] for input_array in tests : print ( f 'Input: {input_array}' ) output_array = insertion_sort ( input_array ) print ( f 'Sorted: {output_array} \\n ' ) Input: [31, 41, 59, 26, 41, 58] Sorted: [26, 31, 41, 41, 58, 59] Input: [] Sorted: [] Input: [40, 20] Sorted: [20, 40] Input: [1] Sorted: [1] Input: [10, 9, 8, 7] Sorted: [7, 8, 9, 10] Input: [7, 8, 9, 10] Sorted: [7, 8, 9, 10]","title":"Insertion Sort"},{"location":"CLRS/ch02-getting-started/insertion-sort/#insertion-sort","text":"Pseudocode INSERTION-SORT(A) 1 for j = 2 to A.length 2 key = A[j] 3 // Insert A[j] into the sorted sequence A[1..j-1] 4 i = j -1 5 while i > 0 and A[i] > key 6 A[i+1] = A[i] 7 i = i - 1 8 A[i+1] = key Python code def insertion_sort ( A ): \"\"\"Sorts the array `A` in ascending order using `Insertion sort` algorithm Args: A: Array of numbers to be sorted Returns: Array of numbers in sorted, ascending order \"\"\" for j in range ( 1 , len ( A )): key = A [ j ] # Insert A[j] into the sorted sequence A[0..j-1] i = j - 1 while i > - 1 and A [ i ] > key : A [ i + 1 ] = A [ i ] i = i - 1 A [ i + 1 ] = key return A tests = [ [ 31 , 41 , 59 , 26 , 41 , 58 ], [], [ 40 , 20 ], [ 1 ], [ 10 , 9 , 8 , 7 ], [ 7 , 8 , 9 , 10 ] ] for input_array in tests : print ( f 'Input: {input_array}' ) output_array = insertion_sort ( input_array ) print ( f 'Sorted: {output_array} \\n ' ) Input: [31, 41, 59, 26, 41, 58] Sorted: [26, 31, 41, 41, 58, 59] Input: [] Sorted: [] Input: [40, 20] Sorted: [20, 40] Input: [1] Sorted: [1] Input: [10, 9, 8, 7] Sorted: [7, 8, 9, 10] Input: [7, 8, 9, 10] Sorted: [7, 8, 9, 10]","title":"Insertion Sort"},{"location":"CLRS/ch02-getting-started/merge-sort/","text":"Merge Sort \u00b6 Pseudocode MERGE(A, p, q, r) 1 n1 = q - p + 1 2 n2 = r - q 3 let L[1..n1+1] and R[1..n2+1] be new arrays 4 for i = 1 to n1 5 L[i] = A[p+i-1] 6 for j = 1 to n2 7 R[j] = A[q+j] 8 L[n1 + 1] = Inf 9 R[n2 + 1] = Inf 10 i = 1 11 j = 1 12 for k = p to r 13 if L[i] <= R[j] 14 A[k] = L[i] 15 i = i + 1 16 else 17 A[k] = R[j] 18 j = j + 1 MERGE-SORT(A,p,r) 1 if p < r 2 q = [p + r]/2 3 MERGE-SORT(A, p, q) 4 MERGE-SORT(A, q+1, r) 5 MERGE(A, p, q, r) Python code import math def merge ( A , p , q , r ): \"\"\"Merges sorted subarrays This procedure assumes that the subarrays A[p..q] and A[q+1..r] are sorted. Merges the subarrays to form single sorted subarray A[p..r] Args: A: Array to be sorted p: Index of start of first subarray q: Index of end of first subarray r: Index of end of second subarray \"\"\" n1 = q - p + 1 # length of subarray A[p..q] n2 = r - q # length of subarray A[q+1..r] # Initialize arrays L and R L = [ A [ p + i ] for i in range ( 0 , n1 )] L . append ( math . inf ) R = [ A [ q + j + 1 ] for j in range ( 0 , n2 )] R . append ( math . inf ) # Construct A[p..r] from L and R in sorted order i , j = 0 , 0 for k in range ( p , r + 1 ): if L [ i ] <= R [ j ]: A [ k ] = L [ i ] i += 1 else : A [ k ] = R [ j ] j += 1 return A def merge_sort ( A ): \"\"\"Sorts the array `A` in ascending order using `Merge sort` algorithm Args: A: Array of numbers to be sorted Returns: Array of numbers in sorted, ascending order \"\"\" # Recursively callable method def merge_sort_r ( A , p , r ): if p < r : q = ( p + r ) // 2 merge_sort_r ( A , p , q ) # Sort first half merge_sort_r ( A , q + 1 , r ) # Sort second half merge ( A , p , q , r ) # Merge first and second half merge_sort_r ( A , 0 , len ( A ) - 1 ) return A tests = [ [ 31 , 41 , 59 , 26 , 41 , 58 ], [], [ 40 , 20 ], [ 1 ], [ 10 , 9 , 8 , 7 ], [ 7 , 8 , 9 , 10 ] ] for input_array in tests : print ( f 'Input: {input_array}' ) output_array = merge_sort ( input_array ) print ( f 'Sorted: {output_array} \\n ' ) Input: [31, 41, 59, 26, 41, 58] Sorted: [26, 31, 41, 41, 58, 59] Input: [] Sorted: [] Input: [40, 20] Sorted: [20, 40] Input: [1] Sorted: [1] Input: [10, 9, 8, 7] Sorted: [7, 8, 9, 10] Input: [7, 8, 9, 10] Sorted: [7, 8, 9, 10]","title":"Merge Sort"},{"location":"CLRS/ch02-getting-started/merge-sort/#merge-sort","text":"Pseudocode MERGE(A, p, q, r) 1 n1 = q - p + 1 2 n2 = r - q 3 let L[1..n1+1] and R[1..n2+1] be new arrays 4 for i = 1 to n1 5 L[i] = A[p+i-1] 6 for j = 1 to n2 7 R[j] = A[q+j] 8 L[n1 + 1] = Inf 9 R[n2 + 1] = Inf 10 i = 1 11 j = 1 12 for k = p to r 13 if L[i] <= R[j] 14 A[k] = L[i] 15 i = i + 1 16 else 17 A[k] = R[j] 18 j = j + 1 MERGE-SORT(A,p,r) 1 if p < r 2 q = [p + r]/2 3 MERGE-SORT(A, p, q) 4 MERGE-SORT(A, q+1, r) 5 MERGE(A, p, q, r) Python code import math def merge ( A , p , q , r ): \"\"\"Merges sorted subarrays This procedure assumes that the subarrays A[p..q] and A[q+1..r] are sorted. Merges the subarrays to form single sorted subarray A[p..r] Args: A: Array to be sorted p: Index of start of first subarray q: Index of end of first subarray r: Index of end of second subarray \"\"\" n1 = q - p + 1 # length of subarray A[p..q] n2 = r - q # length of subarray A[q+1..r] # Initialize arrays L and R L = [ A [ p + i ] for i in range ( 0 , n1 )] L . append ( math . inf ) R = [ A [ q + j + 1 ] for j in range ( 0 , n2 )] R . append ( math . inf ) # Construct A[p..r] from L and R in sorted order i , j = 0 , 0 for k in range ( p , r + 1 ): if L [ i ] <= R [ j ]: A [ k ] = L [ i ] i += 1 else : A [ k ] = R [ j ] j += 1 return A def merge_sort ( A ): \"\"\"Sorts the array `A` in ascending order using `Merge sort` algorithm Args: A: Array of numbers to be sorted Returns: Array of numbers in sorted, ascending order \"\"\" # Recursively callable method def merge_sort_r ( A , p , r ): if p < r : q = ( p + r ) // 2 merge_sort_r ( A , p , q ) # Sort first half merge_sort_r ( A , q + 1 , r ) # Sort second half merge ( A , p , q , r ) # Merge first and second half merge_sort_r ( A , 0 , len ( A ) - 1 ) return A tests = [ [ 31 , 41 , 59 , 26 , 41 , 58 ], [], [ 40 , 20 ], [ 1 ], [ 10 , 9 , 8 , 7 ], [ 7 , 8 , 9 , 10 ] ] for input_array in tests : print ( f 'Input: {input_array}' ) output_array = merge_sort ( input_array ) print ( f 'Sorted: {output_array} \\n ' ) Input: [31, 41, 59, 26, 41, 58] Sorted: [26, 31, 41, 41, 58, 59] Input: [] Sorted: [] Input: [40, 20] Sorted: [20, 40] Input: [1] Sorted: [1] Input: [10, 9, 8, 7] Sorted: [7, 8, 9, 10] Input: [7, 8, 9, 10] Sorted: [7, 8, 9, 10]","title":"Merge Sort"},{"location":"CLRS/ch02-getting-started/problems/","text":"Problem 2-1 - Insertion sort on small arrays in merge sort \u00b6 Although merge sort runs in \\Theta(n\\cdot log_2n) \\Theta(n\\cdot log_2n) worst-case time and insertion sort runs in \\Theta(n^2) \\Theta(n^2) worst-case time, the constant factors in insertion sort can make it faster in practice for small problem sizes on many machines. Thus, it makes sense to coarsen the leaves of the recursion by using insertion sort within merge sort when subproblems become sufficiently small. Consider a modification to merge sort in which n / k sublists of length k are sorted using insertion sort and then merged using the standard merging mechanism, where k is a value to be determined. (a) Show that insertion sort can sort the n/k sublists, each of length k , in \\Theta(nk) \\Theta(nk) worst-case time. If there are k elements, insertion sort takes \\Theta(k^2) \\Theta(k^2) worst-case time. Hence, for n/k sub-arrays of k elements, \\Theta(k^2 \\cdot \\frac{n}{k}) = \\Theta(nk) \\Theta(k^2 \\cdot \\frac{n}{k}) = \\Theta(nk) (b) Show how to merge the sublists in \\Theta(n \\cdot log_2({n/k})) \\Theta(n \\cdot log_2({n/k})) worst-case time. In merge sort, we know that height of tree (by halving at each step, problem of size n into subproblems of size 1) is log_2n log_2n . But we decided to stop when the subproblem becomes sufficiently small - i.e. at k . Hence height of the tree is log_2n - log_2k = log_2(n/k) log_2n - log_2k = log_2(n/k) . At each step, we are merging a total of n elements ( n/k \\cdot k n/k \\cdot k ). Hence merging takes a total of \\Theta(n) \\Theta(n) time. Therefore merging sublists takes, \\Theta(n \\cdot log_2(n/k)) \\Theta(n \\cdot log_2(n/k)) (c) Given that the modified algorithm runs in \\Theta(nk + n \\cdot log_2(n/k)) \\Theta(nk + n \\cdot log_2(n/k)) worst-case time, what is the largest value of k as a function of n for which the modified algorithm has the same running time as standard merge sort, in terms of \\Theta \\Theta -notation? For the modified algorithm to have same worst-case time as original algorithm, \\Theta(nk + n \\cdot log_2(n/k)) = \\Theta(n\\cdot log_2n) \\Theta(nk + n \\cdot log_2(n/k)) = \\Theta(n\\cdot log_2n) To satisfy this condition, k cannot be more than \\Theta(log_2n) \\Theta(log_2n) To prove this, we can plug k = log_2n k = log_2n to the modified running time \\Theta(nk + n \\cdot log_2(n/k)) = \\Theta(n\\cdot log_2n + n \\cdot log_2n - n \\cdot log_2(log_2n)) \\Theta(nk + n \\cdot log_2(n/k)) = \\Theta(n\\cdot log_2n + n \\cdot log_2n - n \\cdot log_2(log_2n)) = \\Theta(2n\\cdot log_2n - n \\cdot log_2(log_2n)) = \\Theta(2n\\cdot log_2n - n \\cdot log_2(log_2n)) Since log_2(log_2n) log_2(log_2n) is sufficiently small, we get = \\Theta(n \\cdot log_2n) = \\Theta(n \\cdot log_2n) which is the original running time. Hence, maximum value of k is k = \\Theta(log_2n) k = \\Theta(log_2n) (d) How should we choose k in practice? In practice, k should be the value of length of array where merge sort beats insertion sort. We can retrieve this by plotting the appropriate graphs. Problem 2-2 - Correctness of bubblesort \u00b6 Bubblesort is a popular, but inefficient, sorting algorithm. It works by repeatedly swapping adjacent elements that are out of order. BUBBLESORT(A) 1 for i = 1 to A.length - 1 2 for j = A.length downto i + 1 3 if A[j] < A[j - 1] 4 exchange A[j] with A[j-1] (a) Let A' denote the output of BUBBLESORT(A). To prove that BUBBLESORT is correct, we need to prove that it terminates and that A'[1] \\leq A'[2] \\leq ... \\leq A'[n] A'[1] \\leq A'[2] \\leq ... \\leq A'[n] where n = A.length . In order to show that BUBBLESORT actually sorts, what else do we need to prove? We need to prove that A' contains the exact same elements as A The next two parts will prove inequality (2.3). (b) State precisely a loop invariant for the for loop in lines 2\u20134, and prove that this loop invariant holds. Your proof should use the structure of the loop invariant proof presented in this chapter. Loop invariant : When each iteration of the loop starts, the position smallest element in the array A[i..n] is less than or equal to j Initialization : Before the loop, any element has the position <= A.length . And j starts from A.length . Hence the condition holds true during initialization Maintenance : During the comparison, if A[j] < A[j - 1] , we swap the elements. Hence smallest element of A[i..n] must be the first j-1 position of the subarray. If A[j] > A[j-1] , smallest element has position at most j-1 . Hence the invariant is maintained. Termination : At the end of the loop, smallest element of A[i..n] is in position i , and value of j is i+1 (c) Using the termination condition of the loop invariant proved in part (b), state a loop invariant for the for loop in lines 1\u20134 that will allow you to prove in- equality (2.3). Your proof should use the structure of the loop invariant proof presented in this chapter. Loop invariant : When each iteration of the loop starts, subarray A[1.. i-1] contains i-1 smallest elements in sorted order Initialization : Before the loop, i=1 means first 0 elements are already sorted. Maintenance : From previous proof, we know that each the termination of inner loop, smallest element of A[i..n] is in position i . Since i-1 elements are already in sorted order A[1..i-1] , A[i] is the i th smallest element. Thus, A[1..i] contains i smallest elements Termination : At the end of the loop, A[1..n] contains all n elements of A in sorted order (d) What is the worst-case running time of bubblesort? How does it compare to the running time of insertion sort? Worst-case running time of bubblesort is \\Theta(n^2) \\Theta(n^2) . Insertion sort also has \\Theta(n^2) \\Theta(n^2) as worst-case running time. On the other hand, bubblesort has both worst-case and best-case running time as \\Theta(n^2) \\Theta(n^2) , whereas insertion sort has best-case running time of \\Theta(n) \\Theta(n) Problem 2-3 - Correctness of Horner\u2019s rule \u00b6 The following code fragment implements Horner\u2019s rule for evaluating a polynomial P(x) = \\sum_{k=0}^{n} a_k x^k = a_0 + x(a_1 + x(a_2 + ... +x(a_{n-1} + xa_n)...)) P(x) = \\sum_{k=0}^{n} a_k x^k = a_0 + x(a_1 + x(a_2 + ... +x(a_{n-1} + xa_n)...)) given the coefficients a_0, a_1, ... a_n a_0, a_1, ... a_n and a value for x x : 1 y = 0 2 for i = n downto 0 3 y = a_i + x * y (a) In terms of \\Theta \\Theta -notation, what is the running time of this code fragment for Horner\u2019s rule? Running time is \\Theta(n) \\Theta(n) (b) Write pseudocode to implement the naive polynomial-evaluation algorithm that computes each term of the polynomial from scratch. What is the running time of this algorithm? How does it compare to Horner\u2019s rule? 1 y = 0 2 for k = 0 to n 3 y = y + (a_k * x^k) Running time is \\Theta(n^2) \\Theta(n^2) , since it has to compute x^k x^k at each iteration (c) Consider the following loop invariant: At the start of each iteration of the for loop of lines 2\u20133, y = \\sum_{k=0}^{n-(i+1)} a_{k+i+1} x^k y = \\sum_{k=0}^{n-(i+1)} a_{k+i+1} x^k Interpret a summation with no terms as equaling 0. Following the structure of the loop invariant proof presented in this chapter, use this loop invariant to show that, at termination, y = \\sum_{k=0}^{n} a_k x^k y = \\sum_{k=0}^{n} a_k x^k Initialization : At the beginning of the loop, i=n i=n , hence n-(n+1) = -1 n-(n+1) = -1 , which is 0, which is the initial value of y Maintenance : If the equation is true for i , y = a_i + x \\sum_{k=0}^{n-(i+1)} a_{k+i+1} x^k = a_i + x \\sum_{k=1}^{n-i} a_{k+i} x^{k-1} = \\sum_{k=0}^{n-i} a_{k+i} x^k y = a_i + x \\sum_{k=0}^{n-(i+1)} a_{k+i+1} x^k = a_i + x \\sum_{k=1}^{n-i} a_{k+i} x^{k-1} = \\sum_{k=0}^{n-i} a_{k+i} x^k Termination : At the end, i=0 i=0 , hence n-(0+1) = n-1 n-(0+1) = n-1 , which is the final result Problem 2-4 - Inversions \u00b6 Let A[1..n] be an array of n distinct numbers. If i < j and A[i] > A[j] , then the pair (i, j) is called an inversion of A . (a) List the five inversions of the array \\langle 2, 3, 8, 6, 1 \\rangle \\langle 2, 3, 8, 6, 1 \\rangle Inversions - (1, 5), (2, 5), (3, 4), (3, 5), (4, 5) (b) What array with elements from the set {1, 2, ... n} has the most inversions? How many does it have? The array {n, n - 1, ... , 2, 1} has the most inversions. It has \\frac{n (n-1)}{2} \\frac{n (n-1)}{2} inversions (c) What is the relationship between the running time of insertion sort and the number of inversions in the input array? Justify your answer. INSERTION-SORT(A) 1 for j = 2 to A.length 2 key = A[j] 3 // Insert A[j] into the sorted sequence A[1..j-1] 4 i = j -1 5 while i > 0 and A[i] > key 6 A[i+1] = A[i] 7 i = i - 1 8 A[i+1] = key If there are more inversions, the while loop in line-5 will be executed more number of times. That is, more number of swaps. Hence, number of inversions is proportional to running time of insertion sort (d) Give an algorithm that determines the number of inversions in any permutation on n elements in \\Theta(n log_2n) \\Theta(n log_2n) worst-case time. ( Hint: Modify merge sort.) Pseudocode MERGE_INVERSIONS(A, p, q, r) 1 n1 = q - p + 1 2 n2 = r - q 3 inversions = 0 4 let L[1..n1+1] and R[1..n2+1] be new arrays 5 for i = 1 to n1 6 L[i] = A[p+i-1] 7 for j = 1 to n2 8 R[j] = A[q+j] 9 L[n1 + 1] = Inf 10 R[n2 + 1] = Inf 11 i = 1 12 j = 1 13 for k = p to r 14 if L[i] <= R[j] 15 A[k] = L[i] 16 i = i + 1 17 else 18 A[k] = R[j] 19 j = j + 1 20 inversions = inversions + n1 - i + 1 21 return inversions COUNT-INVERSIONS(A,p,r) 1 if p < r 2 q = [p + r]/2 3 left-inversions = COUNT-INVERSIONS(A, p, q) 4 right-inversions = COUNT-INVERSIONS(A, q+1, r) 5 inversions = MERGE_INVERSIONS(A, p, q, r) + left-inversions + right-inversions 6 return inversions 7 return 0 Python code import math def merge_inversions ( A , p , q , r ): \"\"\"Counts the number of inversions while merging two subarrays Args: A: Array in which inversions needs to be counted p: Index of start of first subarray q: Index of end of first subarray r: Index of end of second subarray \"\"\" inversions = 0 n1 = q - p + 1 # length of subarray A[p..q] n2 = r - q # length of subarray A[q+1..r] # Initialize arrays L and R L = [ A [ p + i ] for i in range ( 0 , n1 )] L . append ( math . inf ) R = [ A [ q + j + 1 ] for j in range ( 0 , n2 )] R . append ( math . inf ) # Construct A[p..r] from L and R in sorted order i , j = 0 , 0 for k in range ( p , r + 1 ): if L [ i ] <= R [ j ]: A [ k ] = L [ i ] i += 1 else : A [ k ] = R [ j ] j += 1 inversions += n1 - i return inversions def count_inversions ( A ): \"\"\"Counts the number of inversions in array `A` Args: A: Array of numbers Returns: Number of inversions in `A` \"\"\" # Recursively callable method def count_inversions_r ( A , p , r ): if p < r : q = ( p + r ) // 2 left_inversions = count_inversions_r ( A , p , q ) right_inversions = count_inversions_r ( A , q + 1 , r ) inversions = merge_inversions ( A , p , q , r ) + left_inversions + right_inversions return inversions return 0 inversions = count_inversions_r ( A , 0 , len ( A ) - 1 ) return inversions tests = [ [ 31 , 41 , 59 , 26 , 41 , 58 ], [], [ 40 , 20 ], [ 1 ], [ 10 , 9 , 8 , 7 , 6 , 5 ], [ 7 , 8 , 9 , 10 ] ] for input_array in tests : print ( f 'Input: {input_array}' ) inversions = count_inversions ( input_array ) print ( f 'Inversions: {inversions} \\n ' ) Input: [31, 41, 59, 26, 41, 58] Inversions: 5 Input: [] Inversions: 0 Input: [40, 20] Inversions: 1 Input: [1] Inversions: 0 Input: [10, 9, 8, 7, 6, 5] Inversions: 15 Input: [7, 8, 9, 10] Inversions: 0","title":"Problems"},{"location":"CLRS/ch02-getting-started/problems/#problem-2-1-insertion-sort-on-small-arrays-in-merge-sort","text":"Although merge sort runs in \\Theta(n\\cdot log_2n) \\Theta(n\\cdot log_2n) worst-case time and insertion sort runs in \\Theta(n^2) \\Theta(n^2) worst-case time, the constant factors in insertion sort can make it faster in practice for small problem sizes on many machines. Thus, it makes sense to coarsen the leaves of the recursion by using insertion sort within merge sort when subproblems become sufficiently small. Consider a modification to merge sort in which n / k sublists of length k are sorted using insertion sort and then merged using the standard merging mechanism, where k is a value to be determined. (a) Show that insertion sort can sort the n/k sublists, each of length k , in \\Theta(nk) \\Theta(nk) worst-case time. If there are k elements, insertion sort takes \\Theta(k^2) \\Theta(k^2) worst-case time. Hence, for n/k sub-arrays of k elements, \\Theta(k^2 \\cdot \\frac{n}{k}) = \\Theta(nk) \\Theta(k^2 \\cdot \\frac{n}{k}) = \\Theta(nk) (b) Show how to merge the sublists in \\Theta(n \\cdot log_2({n/k})) \\Theta(n \\cdot log_2({n/k})) worst-case time. In merge sort, we know that height of tree (by halving at each step, problem of size n into subproblems of size 1) is log_2n log_2n . But we decided to stop when the subproblem becomes sufficiently small - i.e. at k . Hence height of the tree is log_2n - log_2k = log_2(n/k) log_2n - log_2k = log_2(n/k) . At each step, we are merging a total of n elements ( n/k \\cdot k n/k \\cdot k ). Hence merging takes a total of \\Theta(n) \\Theta(n) time. Therefore merging sublists takes, \\Theta(n \\cdot log_2(n/k)) \\Theta(n \\cdot log_2(n/k)) (c) Given that the modified algorithm runs in \\Theta(nk + n \\cdot log_2(n/k)) \\Theta(nk + n \\cdot log_2(n/k)) worst-case time, what is the largest value of k as a function of n for which the modified algorithm has the same running time as standard merge sort, in terms of \\Theta \\Theta -notation? For the modified algorithm to have same worst-case time as original algorithm, \\Theta(nk + n \\cdot log_2(n/k)) = \\Theta(n\\cdot log_2n) \\Theta(nk + n \\cdot log_2(n/k)) = \\Theta(n\\cdot log_2n) To satisfy this condition, k cannot be more than \\Theta(log_2n) \\Theta(log_2n) To prove this, we can plug k = log_2n k = log_2n to the modified running time \\Theta(nk + n \\cdot log_2(n/k)) = \\Theta(n\\cdot log_2n + n \\cdot log_2n - n \\cdot log_2(log_2n)) \\Theta(nk + n \\cdot log_2(n/k)) = \\Theta(n\\cdot log_2n + n \\cdot log_2n - n \\cdot log_2(log_2n)) = \\Theta(2n\\cdot log_2n - n \\cdot log_2(log_2n)) = \\Theta(2n\\cdot log_2n - n \\cdot log_2(log_2n)) Since log_2(log_2n) log_2(log_2n) is sufficiently small, we get = \\Theta(n \\cdot log_2n) = \\Theta(n \\cdot log_2n) which is the original running time. Hence, maximum value of k is k = \\Theta(log_2n) k = \\Theta(log_2n) (d) How should we choose k in practice? In practice, k should be the value of length of array where merge sort beats insertion sort. We can retrieve this by plotting the appropriate graphs.","title":"Problem 2-1 - Insertion sort on small arrays in merge sort"},{"location":"CLRS/ch02-getting-started/problems/#problem-2-2-correctness-of-bubblesort","text":"Bubblesort is a popular, but inefficient, sorting algorithm. It works by repeatedly swapping adjacent elements that are out of order. BUBBLESORT(A) 1 for i = 1 to A.length - 1 2 for j = A.length downto i + 1 3 if A[j] < A[j - 1] 4 exchange A[j] with A[j-1] (a) Let A' denote the output of BUBBLESORT(A). To prove that BUBBLESORT is correct, we need to prove that it terminates and that A'[1] \\leq A'[2] \\leq ... \\leq A'[n] A'[1] \\leq A'[2] \\leq ... \\leq A'[n] where n = A.length . In order to show that BUBBLESORT actually sorts, what else do we need to prove? We need to prove that A' contains the exact same elements as A The next two parts will prove inequality (2.3). (b) State precisely a loop invariant for the for loop in lines 2\u20134, and prove that this loop invariant holds. Your proof should use the structure of the loop invariant proof presented in this chapter. Loop invariant : When each iteration of the loop starts, the position smallest element in the array A[i..n] is less than or equal to j Initialization : Before the loop, any element has the position <= A.length . And j starts from A.length . Hence the condition holds true during initialization Maintenance : During the comparison, if A[j] < A[j - 1] , we swap the elements. Hence smallest element of A[i..n] must be the first j-1 position of the subarray. If A[j] > A[j-1] , smallest element has position at most j-1 . Hence the invariant is maintained. Termination : At the end of the loop, smallest element of A[i..n] is in position i , and value of j is i+1 (c) Using the termination condition of the loop invariant proved in part (b), state a loop invariant for the for loop in lines 1\u20134 that will allow you to prove in- equality (2.3). Your proof should use the structure of the loop invariant proof presented in this chapter. Loop invariant : When each iteration of the loop starts, subarray A[1.. i-1] contains i-1 smallest elements in sorted order Initialization : Before the loop, i=1 means first 0 elements are already sorted. Maintenance : From previous proof, we know that each the termination of inner loop, smallest element of A[i..n] is in position i . Since i-1 elements are already in sorted order A[1..i-1] , A[i] is the i th smallest element. Thus, A[1..i] contains i smallest elements Termination : At the end of the loop, A[1..n] contains all n elements of A in sorted order (d) What is the worst-case running time of bubblesort? How does it compare to the running time of insertion sort? Worst-case running time of bubblesort is \\Theta(n^2) \\Theta(n^2) . Insertion sort also has \\Theta(n^2) \\Theta(n^2) as worst-case running time. On the other hand, bubblesort has both worst-case and best-case running time as \\Theta(n^2) \\Theta(n^2) , whereas insertion sort has best-case running time of \\Theta(n) \\Theta(n)","title":"Problem 2-2 - Correctness of bubblesort"},{"location":"CLRS/ch02-getting-started/problems/#problem-2-3-correctness-of-horners-rule","text":"The following code fragment implements Horner\u2019s rule for evaluating a polynomial P(x) = \\sum_{k=0}^{n} a_k x^k = a_0 + x(a_1 + x(a_2 + ... +x(a_{n-1} + xa_n)...)) P(x) = \\sum_{k=0}^{n} a_k x^k = a_0 + x(a_1 + x(a_2 + ... +x(a_{n-1} + xa_n)...)) given the coefficients a_0, a_1, ... a_n a_0, a_1, ... a_n and a value for x x : 1 y = 0 2 for i = n downto 0 3 y = a_i + x * y (a) In terms of \\Theta \\Theta -notation, what is the running time of this code fragment for Horner\u2019s rule? Running time is \\Theta(n) \\Theta(n) (b) Write pseudocode to implement the naive polynomial-evaluation algorithm that computes each term of the polynomial from scratch. What is the running time of this algorithm? How does it compare to Horner\u2019s rule? 1 y = 0 2 for k = 0 to n 3 y = y + (a_k * x^k) Running time is \\Theta(n^2) \\Theta(n^2) , since it has to compute x^k x^k at each iteration (c) Consider the following loop invariant: At the start of each iteration of the for loop of lines 2\u20133, y = \\sum_{k=0}^{n-(i+1)} a_{k+i+1} x^k y = \\sum_{k=0}^{n-(i+1)} a_{k+i+1} x^k Interpret a summation with no terms as equaling 0. Following the structure of the loop invariant proof presented in this chapter, use this loop invariant to show that, at termination, y = \\sum_{k=0}^{n} a_k x^k y = \\sum_{k=0}^{n} a_k x^k Initialization : At the beginning of the loop, i=n i=n , hence n-(n+1) = -1 n-(n+1) = -1 , which is 0, which is the initial value of y Maintenance : If the equation is true for i , y = a_i + x \\sum_{k=0}^{n-(i+1)} a_{k+i+1} x^k = a_i + x \\sum_{k=1}^{n-i} a_{k+i} x^{k-1} = \\sum_{k=0}^{n-i} a_{k+i} x^k y = a_i + x \\sum_{k=0}^{n-(i+1)} a_{k+i+1} x^k = a_i + x \\sum_{k=1}^{n-i} a_{k+i} x^{k-1} = \\sum_{k=0}^{n-i} a_{k+i} x^k Termination : At the end, i=0 i=0 , hence n-(0+1) = n-1 n-(0+1) = n-1 , which is the final result","title":"Problem 2-3 - Correctness of Horner\u2019s rule"},{"location":"CLRS/ch02-getting-started/problems/#problem-2-4-inversions","text":"Let A[1..n] be an array of n distinct numbers. If i < j and A[i] > A[j] , then the pair (i, j) is called an inversion of A . (a) List the five inversions of the array \\langle 2, 3, 8, 6, 1 \\rangle \\langle 2, 3, 8, 6, 1 \\rangle Inversions - (1, 5), (2, 5), (3, 4), (3, 5), (4, 5) (b) What array with elements from the set {1, 2, ... n} has the most inversions? How many does it have? The array {n, n - 1, ... , 2, 1} has the most inversions. It has \\frac{n (n-1)}{2} \\frac{n (n-1)}{2} inversions (c) What is the relationship between the running time of insertion sort and the number of inversions in the input array? Justify your answer. INSERTION-SORT(A) 1 for j = 2 to A.length 2 key = A[j] 3 // Insert A[j] into the sorted sequence A[1..j-1] 4 i = j -1 5 while i > 0 and A[i] > key 6 A[i+1] = A[i] 7 i = i - 1 8 A[i+1] = key If there are more inversions, the while loop in line-5 will be executed more number of times. That is, more number of swaps. Hence, number of inversions is proportional to running time of insertion sort (d) Give an algorithm that determines the number of inversions in any permutation on n elements in \\Theta(n log_2n) \\Theta(n log_2n) worst-case time. ( Hint: Modify merge sort.) Pseudocode MERGE_INVERSIONS(A, p, q, r) 1 n1 = q - p + 1 2 n2 = r - q 3 inversions = 0 4 let L[1..n1+1] and R[1..n2+1] be new arrays 5 for i = 1 to n1 6 L[i] = A[p+i-1] 7 for j = 1 to n2 8 R[j] = A[q+j] 9 L[n1 + 1] = Inf 10 R[n2 + 1] = Inf 11 i = 1 12 j = 1 13 for k = p to r 14 if L[i] <= R[j] 15 A[k] = L[i] 16 i = i + 1 17 else 18 A[k] = R[j] 19 j = j + 1 20 inversions = inversions + n1 - i + 1 21 return inversions COUNT-INVERSIONS(A,p,r) 1 if p < r 2 q = [p + r]/2 3 left-inversions = COUNT-INVERSIONS(A, p, q) 4 right-inversions = COUNT-INVERSIONS(A, q+1, r) 5 inversions = MERGE_INVERSIONS(A, p, q, r) + left-inversions + right-inversions 6 return inversions 7 return 0 Python code import math def merge_inversions ( A , p , q , r ): \"\"\"Counts the number of inversions while merging two subarrays Args: A: Array in which inversions needs to be counted p: Index of start of first subarray q: Index of end of first subarray r: Index of end of second subarray \"\"\" inversions = 0 n1 = q - p + 1 # length of subarray A[p..q] n2 = r - q # length of subarray A[q+1..r] # Initialize arrays L and R L = [ A [ p + i ] for i in range ( 0 , n1 )] L . append ( math . inf ) R = [ A [ q + j + 1 ] for j in range ( 0 , n2 )] R . append ( math . inf ) # Construct A[p..r] from L and R in sorted order i , j = 0 , 0 for k in range ( p , r + 1 ): if L [ i ] <= R [ j ]: A [ k ] = L [ i ] i += 1 else : A [ k ] = R [ j ] j += 1 inversions += n1 - i return inversions def count_inversions ( A ): \"\"\"Counts the number of inversions in array `A` Args: A: Array of numbers Returns: Number of inversions in `A` \"\"\" # Recursively callable method def count_inversions_r ( A , p , r ): if p < r : q = ( p + r ) // 2 left_inversions = count_inversions_r ( A , p , q ) right_inversions = count_inversions_r ( A , q + 1 , r ) inversions = merge_inversions ( A , p , q , r ) + left_inversions + right_inversions return inversions return 0 inversions = count_inversions_r ( A , 0 , len ( A ) - 1 ) return inversions tests = [ [ 31 , 41 , 59 , 26 , 41 , 58 ], [], [ 40 , 20 ], [ 1 ], [ 10 , 9 , 8 , 7 , 6 , 5 ], [ 7 , 8 , 9 , 10 ] ] for input_array in tests : print ( f 'Input: {input_array}' ) inversions = count_inversions ( input_array ) print ( f 'Inversions: {inversions} \\n ' ) Input: [31, 41, 59, 26, 41, 58] Inversions: 5 Input: [] Inversions: 0 Input: [40, 20] Inversions: 1 Input: [1] Inversions: 0 Input: [10, 9, 8, 7, 6, 5] Inversions: 15 Input: [7, 8, 9, 10] Inversions: 0","title":"Problem 2-4 - Inversions"},{"location":"SICP/","text":"SICP Programs \u00b6 Exercises and programs from Structure and Interpretation of Computer Programs book Chapter 1 - Building abstractions with procedures \u00b6 Programs \u00b6 Fibonacci Tree , Counting change , Exponent , GCD , Primality , Sigma function , Lambda , Half interval , Fixed point , Transformation Exercises \u00b6 1.1 Elements of Programming 1.1 , 1.2 , 1.3 , 1.4 , 1.5 , 1.6 , 1.7 , 1.8 1.2 Procedures and the Processes They Generate 1.9 , 1.10 , 1.11 , 1.12 , 1.13 , 1.15 , 1.16 , 1.17 , 1.18 , 1.19 , 1.20 , 1.21 , 1.22 , 1.23 , 1.24 , 1.25 , 1.26 , 1.27 , 1.28 1.3 Formulating Abstractions with Higher-Order Procedures 1.29 , 1.30 , 1.31 (a) , 1.31 (b) , 1.32 (a) , 1.32 (b) , 1.33 , 1.34 , 1.35 , 1.36 , 1.37 (a) , 1.37 (b) , 1.38 , 1.39 , 1.40 , 1.41 , 1.42 , 1.43 , 1.44 , 1.45 , 1.46 Chapter 2 - Building abstractions with data \u00b6 Programs \u00b6 Rational numbers , Sequences , Transforming list , Trees from list , Mapping over tree , Conventional interfaces , Nested mappings , Painter patterns , Painter higher order , Painter transformation , Symbolic differentiation , Sets as unordered list , Sets as ordered list , Sets as trees , Huffman tree , Complex numbers , Arithmetic package Exercises \u00b6 2.1 Introduction to Data Abstraction 2.1 , 2.2 , 2.3 , 2.4 , 2.5 , 2.6 , 2.7 , 2.8 , 2.9 , 2.10 , 2.11 , 2.12 , 2.13 , 2.14 , 2.15 , 2.16 2.2 Hierarchical Data and the Closure Property 2.17 , 2.18 , 2.19 , 2.20 , 2.21 , 2.22 , 2.23 , 2.24 , 2.25 , 2.26 , 2.27 , 2.28 , 2.29 , 2.30 , 2.31 , 2.32 , 2.33 , 2.34 , 2.35 , 2.36 , 2.37 , 2.38 , 2.39 , 2.40 , 2.41 , 2.42 , 2.43 , 2.44 , 2.45 , 2.46 , 2.47 , 2.48 , 2.49 , 2.50 , 2.51 , 2.52 2.3 Symbolic Data 2.53 , 2.54 , 2.55 , 2.56 , 2.57 , 2.58 (a) , 2.59 , 2.60 , 2.61 , 2.62 , 2.63 , 2.64 , 2.65 , 2.66 , 2.67 , 2.68 , 2.69 , 2.70 , 2.71 , 2.72 2.4 Multiple Representations for Abstract Data 2.73 , 2.74 , 2.75 , 2.76 2.5 Systems with Generic Operations 2.77 , 2.78 , 2.79 , 2.80 , 2.81 , 2.82 , 2.83 , 2.84 , 2.85 , 2.86 , 2.87 , 2.88 , 2.89 , 2.90 , 2.91 Running the programs \u00b6 Installing MIT Scheme on Mac \u00b6 $ brew install mit-scheme Installing DrRacket (for a few programs) on Mac \u00b6 $ brew cask install racket Running scheme programs \u00b6 $ scheme < program_name.scm Running racket programs \u00b6 $ drracket program_name.rkt","title":"SICP Programs"},{"location":"SICP/#sicp-programs","text":"Exercises and programs from Structure and Interpretation of Computer Programs book","title":"SICP Programs"},{"location":"SICP/#chapter-1-building-abstractions-with-procedures","text":"","title":"Chapter 1 - Building abstractions with procedures"},{"location":"SICP/#programs","text":"Fibonacci Tree , Counting change , Exponent , GCD , Primality , Sigma function , Lambda , Half interval , Fixed point , Transformation","title":"Programs"},{"location":"SICP/#exercises","text":"1.1 Elements of Programming 1.1 , 1.2 , 1.3 , 1.4 , 1.5 , 1.6 , 1.7 , 1.8 1.2 Procedures and the Processes They Generate 1.9 , 1.10 , 1.11 , 1.12 , 1.13 , 1.15 , 1.16 , 1.17 , 1.18 , 1.19 , 1.20 , 1.21 , 1.22 , 1.23 , 1.24 , 1.25 , 1.26 , 1.27 , 1.28 1.3 Formulating Abstractions with Higher-Order Procedures 1.29 , 1.30 , 1.31 (a) , 1.31 (b) , 1.32 (a) , 1.32 (b) , 1.33 , 1.34 , 1.35 , 1.36 , 1.37 (a) , 1.37 (b) , 1.38 , 1.39 , 1.40 , 1.41 , 1.42 , 1.43 , 1.44 , 1.45 , 1.46","title":"Exercises"},{"location":"SICP/#chapter-2-building-abstractions-with-data","text":"","title":"Chapter 2 - Building abstractions with data"},{"location":"SICP/#programs_1","text":"Rational numbers , Sequences , Transforming list , Trees from list , Mapping over tree , Conventional interfaces , Nested mappings , Painter patterns , Painter higher order , Painter transformation , Symbolic differentiation , Sets as unordered list , Sets as ordered list , Sets as trees , Huffman tree , Complex numbers , Arithmetic package","title":"Programs"},{"location":"SICP/#exercises_1","text":"2.1 Introduction to Data Abstraction 2.1 , 2.2 , 2.3 , 2.4 , 2.5 , 2.6 , 2.7 , 2.8 , 2.9 , 2.10 , 2.11 , 2.12 , 2.13 , 2.14 , 2.15 , 2.16 2.2 Hierarchical Data and the Closure Property 2.17 , 2.18 , 2.19 , 2.20 , 2.21 , 2.22 , 2.23 , 2.24 , 2.25 , 2.26 , 2.27 , 2.28 , 2.29 , 2.30 , 2.31 , 2.32 , 2.33 , 2.34 , 2.35 , 2.36 , 2.37 , 2.38 , 2.39 , 2.40 , 2.41 , 2.42 , 2.43 , 2.44 , 2.45 , 2.46 , 2.47 , 2.48 , 2.49 , 2.50 , 2.51 , 2.52 2.3 Symbolic Data 2.53 , 2.54 , 2.55 , 2.56 , 2.57 , 2.58 (a) , 2.59 , 2.60 , 2.61 , 2.62 , 2.63 , 2.64 , 2.65 , 2.66 , 2.67 , 2.68 , 2.69 , 2.70 , 2.71 , 2.72 2.4 Multiple Representations for Abstract Data 2.73 , 2.74 , 2.75 , 2.76 2.5 Systems with Generic Operations 2.77 , 2.78 , 2.79 , 2.80 , 2.81 , 2.82 , 2.83 , 2.84 , 2.85 , 2.86 , 2.87 , 2.88 , 2.89 , 2.90 , 2.91","title":"Exercises"},{"location":"SICP/#running-the-programs","text":"","title":"Running the programs"},{"location":"SICP/#installing-mit-scheme-on-mac","text":"$ brew install mit-scheme","title":"Installing MIT Scheme on Mac"},{"location":"SICP/#installing-drracket-for-a-few-programs-on-mac","text":"$ brew cask install racket","title":"Installing DrRacket (for a few programs) on Mac"},{"location":"SICP/#running-scheme-programs","text":"$ scheme < program_name.scm","title":"Running scheme programs"},{"location":"SICP/#running-racket-programs","text":"$ drracket program_name.rkt","title":"Running racket programs"},{"location":"SICP/ch1-abstraction-procedures/1.01/","text":"1.01 \u00b6 10 ; 10 ( + 5 3 4 ) ; 12 ( - 9 1 ) ; 8 ( / 6 2 ) ; 3 ( + ( * 2 4 ) ( - 4 6 )) ; 6 ( define a 3 ) ; def a = 3 ( define b ( + a 1 )) ; def b = 4 ( + a b ( * a b )) ; 19 ( = a b ) ; #f (false) ( if ( and ( > b a ) ( < b ( * a b ))) b a ) ; 4 ( cond (( = a 4 ) 6 ) (( = b 4 ) ( + 6 7 a )) ( else 25 )) ; 16 ( + 2 ( if ( > b a ) b a )) ; 6 ( * ( cond (( > a b ) a ) (( < a b ) b ) ( else -1 )) ( + a 1 )) ; 16","title":"1.01"},{"location":"SICP/ch1-abstraction-procedures/1.01/#101","text":"10 ; 10 ( + 5 3 4 ) ; 12 ( - 9 1 ) ; 8 ( / 6 2 ) ; 3 ( + ( * 2 4 ) ( - 4 6 )) ; 6 ( define a 3 ) ; def a = 3 ( define b ( + a 1 )) ; def b = 4 ( + a b ( * a b )) ; 19 ( = a b ) ; #f (false) ( if ( and ( > b a ) ( < b ( * a b ))) b a ) ; 4 ( cond (( = a 4 ) 6 ) (( = b 4 ) ( + 6 7 a )) ( else 25 )) ; 16 ( + 2 ( if ( > b a ) b a )) ; 6 ( * ( cond (( > a b ) a ) (( < a b ) b ) ( else -1 )) ( + a 1 )) ; 16","title":"1.01"},{"location":"SICP/ch1-abstraction-procedures/1.02/","text":"1.02 \u00b6 ; Translate the following expression into prefix form ; ; 5 + 4 + (2 - (3 - (6 + 4/5))) ; ------------------------------- ; 3 (6 - 2) (2 - 7) ; ; Ans: -37/150 ; ( / ( + 5 4 ( - 2 ( - 3 ( + 6 ( / 4 5 )) ) ) ) ( * 3 ( - 6 2 ) ( - 2 7 ) ) )","title":"1.02"},{"location":"SICP/ch1-abstraction-procedures/1.02/#102","text":"; Translate the following expression into prefix form ; ; 5 + 4 + (2 - (3 - (6 + 4/5))) ; ------------------------------- ; 3 (6 - 2) (2 - 7) ; ; Ans: -37/150 ; ( / ( + 5 4 ( - 2 ( - 3 ( + 6 ( / 4 5 )) ) ) ) ( * 3 ( - 6 2 ) ( - 2 7 ) ) )","title":"1.02"},{"location":"SICP/ch1-abstraction-procedures/1.03/","text":"1.03 \u00b6 ; Exercise 1.03 ; ; Define a procedure that takes three numbers as arguments ; and returns the sum of the squares of the two larger numbers ; ; ; Tests: ; (sum-of-squares-larger 1 2 3) ; 13 ; (sum-of-squares-larger 3 2 3) ; 18 ; (sum-of-squares-larger 3 2 2) ; 13 ; (sum-of-squares-larger 3 3 3) ; 18 ; ( define ( square x ) ( * x x )) ( define ( sum-of-square x y ) ( + ( square x ) ( square y ))) ( define ( sum-of-squares-larger a b c ) ( cond (( and ( >= a b ) ( >= b c )) ( sum-of-square a b )) (( and ( >= a b ) ( >= c b )) ( sum-of-square a c )) (( and ( >= b a ) ( >= c a )) ( sum-of-square b c )) ) )","title":"1.03"},{"location":"SICP/ch1-abstraction-procedures/1.03/#103","text":"; Exercise 1.03 ; ; Define a procedure that takes three numbers as arguments ; and returns the sum of the squares of the two larger numbers ; ; ; Tests: ; (sum-of-squares-larger 1 2 3) ; 13 ; (sum-of-squares-larger 3 2 3) ; 18 ; (sum-of-squares-larger 3 2 2) ; 13 ; (sum-of-squares-larger 3 3 3) ; 18 ; ( define ( square x ) ( * x x )) ( define ( sum-of-square x y ) ( + ( square x ) ( square y ))) ( define ( sum-of-squares-larger a b c ) ( cond (( and ( >= a b ) ( >= b c )) ( sum-of-square a b )) (( and ( >= a b ) ( >= c b )) ( sum-of-square a c )) (( and ( >= b a ) ( >= c a )) ( sum-of-square b c )) ) )","title":"1.03"},{"location":"SICP/ch1-abstraction-procedures/1.04/","text":"1.04 \u00b6 ; Observe that our model of evaluation allows for combinations ; whose operators are compound expressions. Use this ; observation to describe the behavior of the following procedure: ; ( define ( a-plus-abs-b a b ) (( if ( > b 0 ) + - ) a b ) ) ; The above function computes a + |b| ; i.e. if b is +ve -> a + b ; if b is -ve -> a - b ; ; Here the operation type itself is determined conditionally ; (+ a b) OR (- a b)","title":"1.04"},{"location":"SICP/ch1-abstraction-procedures/1.04/#104","text":"; Observe that our model of evaluation allows for combinations ; whose operators are compound expressions. Use this ; observation to describe the behavior of the following procedure: ; ( define ( a-plus-abs-b a b ) (( if ( > b 0 ) + - ) a b ) ) ; The above function computes a + |b| ; i.e. if b is +ve -> a + b ; if b is -ve -> a - b ; ; Here the operation type itself is determined conditionally ; (+ a b) OR (- a b)","title":"1.04"},{"location":"SICP/ch1-abstraction-procedures/1.05/","text":"1.05 \u00b6 ; Ben Bitdiddle has invented a test to determine ; whether the interpreter he is faced with is ; using applicative- order evaluation or normal-order ; evaluation. He defines the following two procedures: ( define ( p ) ( p )) ( define ( test x y ) ( if ( = x 0 ) 0 y ) ) ; Then he evaluates the expression ; ( test 0 ( p )) ; ; What behavior will Ben observe with an interpreter ; that uses applicative-order evaluation? ; What behavior will he observe with an interpreter ; that uses normal-order evaluation? Explain your answer ; (Assume that the evaluation rule for the special form ; if is the same whether the interpreter is using normal ; or applicative order: The predicate expression is evaluated ; first, and the result determines whether to evaluate the ; consequent or the alternative expression.) ; ; Answer: ; * If the interpreter uses \"applicative-order\", ; (p) will be evaluated first, hence end up in infinite ; recursion (which is the definition of p) ; * If the interpreter uses \"normal-order\" evaluation, ; (p) is not evaluated, hence will return 0","title":"1.05"},{"location":"SICP/ch1-abstraction-procedures/1.05/#105","text":"; Ben Bitdiddle has invented a test to determine ; whether the interpreter he is faced with is ; using applicative- order evaluation or normal-order ; evaluation. He defines the following two procedures: ( define ( p ) ( p )) ( define ( test x y ) ( if ( = x 0 ) 0 y ) ) ; Then he evaluates the expression ; ( test 0 ( p )) ; ; What behavior will Ben observe with an interpreter ; that uses applicative-order evaluation? ; What behavior will he observe with an interpreter ; that uses normal-order evaluation? Explain your answer ; (Assume that the evaluation rule for the special form ; if is the same whether the interpreter is using normal ; or applicative order: The predicate expression is evaluated ; first, and the result determines whether to evaluate the ; consequent or the alternative expression.) ; ; Answer: ; * If the interpreter uses \"applicative-order\", ; (p) will be evaluated first, hence end up in infinite ; recursion (which is the definition of p) ; * If the interpreter uses \"normal-order\" evaluation, ; (p) is not evaluated, hence will return 0","title":"1.05"},{"location":"SICP/ch1-abstraction-procedures/1.06/","text":"1.06 \u00b6 ; Alyssa P. Hacker doesn\u2019t see why if needs to be ; provided as a special form. \u201cWhy can\u2019t I just ; define it as an ordinary procedure in terms of cond?\u201d ; she asks. Alyssa\u2019s friend Eva Lu Ator claims this ; can indeed be done, and she defines a new version of if: ( define ( new-if predicate then-clause else-clause ) ( cond ( predicate then-clause ) ( else else-clause ) ) ) ( new-if ( = 2 3 ) 0 5 ) ; 5 ( new-if ( = 1 1 ) 0 5 ) ; 0 ; Delighted, Alyssa uses new-if to rewrite the ; square-root program: ( define ( average x y ) ( / ( + x y ) 2 )) ( define ( square x ) ( * x x )) ( define ( improve guess x ) ( average guess ( / x guess ))) ( define ( good-enough? guess x ) ( < ( abs ( - ( square guess ) x )) 0.001 ) ) ( define ( sqrt-iter guess x ) ( new-if ( good-enough? guess x ) guess ( sqrt-iter ( improve guess x ) x ) ) ) ( define ( sqrt x ) ( sqrt-iter 1.0 x ) ) ; What happens when Alyssa attempts to use this ; to compute square roots? Explain ; Answer: ; Since the condition is inside a \"function\" `new-if`, ; inside `sqrt-iter`, the \"else-clause\" will be evaluated. ; This will lead to infinite recursion scenario. ; Note: This will continue until stack overflow","title":"1.06"},{"location":"SICP/ch1-abstraction-procedures/1.06/#106","text":"; Alyssa P. Hacker doesn\u2019t see why if needs to be ; provided as a special form. \u201cWhy can\u2019t I just ; define it as an ordinary procedure in terms of cond?\u201d ; she asks. Alyssa\u2019s friend Eva Lu Ator claims this ; can indeed be done, and she defines a new version of if: ( define ( new-if predicate then-clause else-clause ) ( cond ( predicate then-clause ) ( else else-clause ) ) ) ( new-if ( = 2 3 ) 0 5 ) ; 5 ( new-if ( = 1 1 ) 0 5 ) ; 0 ; Delighted, Alyssa uses new-if to rewrite the ; square-root program: ( define ( average x y ) ( / ( + x y ) 2 )) ( define ( square x ) ( * x x )) ( define ( improve guess x ) ( average guess ( / x guess ))) ( define ( good-enough? guess x ) ( < ( abs ( - ( square guess ) x )) 0.001 ) ) ( define ( sqrt-iter guess x ) ( new-if ( good-enough? guess x ) guess ( sqrt-iter ( improve guess x ) x ) ) ) ( define ( sqrt x ) ( sqrt-iter 1.0 x ) ) ; What happens when Alyssa attempts to use this ; to compute square roots? Explain ; Answer: ; Since the condition is inside a \"function\" `new-if`, ; inside `sqrt-iter`, the \"else-clause\" will be evaluated. ; This will lead to infinite recursion scenario. ; Note: This will continue until stack overflow","title":"1.06"},{"location":"SICP/ch1-abstraction-procedures/1.07/","text":"1.07 \u00b6 ; The good-enough? test used in computing square roots ; will not be very effective for finding the square ; roots of very small numbers. Also, in real computers, ; arithmetic operations are almost always performed with ; limited precision. This makes our test inadequate for very ; large numbers. Explain these statements, with examples showing ; how the test fails for small and large numbers. An alternative ; strategy for implementing `good-enough?` is to watch how guess ; changes from one iteration to the next and to stop when the ; change is a very small fraction of the guess. Design a square-root ; procedure that uses this kind of end test. Does this work better ; for small and large numbers? ; ; Let's define the previously mentioned square root functions for ; testing small numbers ( define ( average x y ) ( / ( + x y ) 2 )) ( define ( square x ) ( * x x )) ( define ( improve guess x ) ( average guess ( / x guess ))) ( define ( good-enough? guess x ) ( < ( abs ( - ( square guess ) x )) 0.001 ) ) ( define ( sqrt-iter guess x ) ( if ( good-enough? guess x ) guess ( sqrt-iter ( improve guess x ) x ) ) ) ( define ( sqrt x ) ( sqrt-iter 1.0 x ) ) ; Let's try some small numbers ( sqrt 0.004 ) ; res = .06548128198973399, actual = 0.0632455532 ( sqrt 0.0006 ) ; res = 3.7397194007827136e-2, actual = 2.449489743e-2 ; As we can observe, our `good-enough?` test fails as the number becomes smaller ; Alternative `good-enough?` function can be, ; (latestGuess - previousGuess)/previousGuess is less than 0.001 (fraction change) ( define ( good-enough-alt? guess x ) ( < ( abs ( / ( - ( improve guess x ) guess ) guess )) 0.001 ) )","title":"1.07"},{"location":"SICP/ch1-abstraction-procedures/1.07/#107","text":"; The good-enough? test used in computing square roots ; will not be very effective for finding the square ; roots of very small numbers. Also, in real computers, ; arithmetic operations are almost always performed with ; limited precision. This makes our test inadequate for very ; large numbers. Explain these statements, with examples showing ; how the test fails for small and large numbers. An alternative ; strategy for implementing `good-enough?` is to watch how guess ; changes from one iteration to the next and to stop when the ; change is a very small fraction of the guess. Design a square-root ; procedure that uses this kind of end test. Does this work better ; for small and large numbers? ; ; Let's define the previously mentioned square root functions for ; testing small numbers ( define ( average x y ) ( / ( + x y ) 2 )) ( define ( square x ) ( * x x )) ( define ( improve guess x ) ( average guess ( / x guess ))) ( define ( good-enough? guess x ) ( < ( abs ( - ( square guess ) x )) 0.001 ) ) ( define ( sqrt-iter guess x ) ( if ( good-enough? guess x ) guess ( sqrt-iter ( improve guess x ) x ) ) ) ( define ( sqrt x ) ( sqrt-iter 1.0 x ) ) ; Let's try some small numbers ( sqrt 0.004 ) ; res = .06548128198973399, actual = 0.0632455532 ( sqrt 0.0006 ) ; res = 3.7397194007827136e-2, actual = 2.449489743e-2 ; As we can observe, our `good-enough?` test fails as the number becomes smaller ; Alternative `good-enough?` function can be, ; (latestGuess - previousGuess)/previousGuess is less than 0.001 (fraction change) ( define ( good-enough-alt? guess x ) ( < ( abs ( / ( - ( improve guess x ) guess ) guess )) 0.001 ) )","title":"1.07"},{"location":"SICP/ch1-abstraction-procedures/1.08/","text":"1.08 \u00b6 ; Newton\u2019s method for cube roots is based on the fact ; that if y is an approximation to the cube root of x , ; then a better approximation is given by the value ; ; x/y\u00b2 + 2y ; ------------ ; 3 ; ; Use this formula to implement a cube-root procedure analogous ; to the square-root procedure ( define ( square x ) ( * x x )) ( define ( cube x ) ( * x x x )) ( define ( improve guess x ) ( / ( + ( / x ( square guess )) ( * 2 guess )) 3 ) ) ( define ( good-enough? guess prev-guess ) ( < ( abs ( - guess prev-guess )) ( abs ( * guess 0.001 ))) ) ( define ( cuberoot-iter guess prev-guess x ) ( if ( good-enough? guess prev-guess ) guess ( cuberoot-iter ( improve guess x ) guess x ) ) ) ( define ( cube-root x ) ( cuberoot-iter 1.0 0.0 x ) ) ( cube-root 8 ) ;Value: 2.000000000012062 ( cube-root 1 e-27 ) ;Value: 1.0000000000037844e-9 ( cube-root 1 e15 ) ;Value: 100000.0000002152","title":"1.08"},{"location":"SICP/ch1-abstraction-procedures/1.08/#108","text":"; Newton\u2019s method for cube roots is based on the fact ; that if y is an approximation to the cube root of x , ; then a better approximation is given by the value ; ; x/y\u00b2 + 2y ; ------------ ; 3 ; ; Use this formula to implement a cube-root procedure analogous ; to the square-root procedure ( define ( square x ) ( * x x )) ( define ( cube x ) ( * x x x )) ( define ( improve guess x ) ( / ( + ( / x ( square guess )) ( * 2 guess )) 3 ) ) ( define ( good-enough? guess prev-guess ) ( < ( abs ( - guess prev-guess )) ( abs ( * guess 0.001 ))) ) ( define ( cuberoot-iter guess prev-guess x ) ( if ( good-enough? guess prev-guess ) guess ( cuberoot-iter ( improve guess x ) guess x ) ) ) ( define ( cube-root x ) ( cuberoot-iter 1.0 0.0 x ) ) ( cube-root 8 ) ;Value: 2.000000000012062 ( cube-root 1 e-27 ) ;Value: 1.0000000000037844e-9 ( cube-root 1 e15 ) ;Value: 100000.0000002152","title":"1.08"},{"location":"SICP/ch1-abstraction-procedures/1.09/","text":"1.09 \u00b6 ; Each of the following two procedures defines a ; method for adding two positive integers in terms ; of the procedures inc, which increments its argument ; by 1, and dec, which decrements its argument by 1 ( define ( + a b ) ( if ( = a 0 ) b ( inc ( + ( dec a ) b ))) ) ( define ( + a b ) ( if ( = a 0 ) b ( + ( dec a ) ( inc b ))) ) ; Using the substitution model, illustrate the process ; generated by each procedure in evaluating (+ 4 5). ; Are these processes iterative or recursive? ; Answer ; ; (1) Definition 1 ; -------------------------------------------------- ; (+ 4 5) ; (inc (+ (dec 4) 5)) ; (inc (+ 3 5)) ; (inc (inc (+ (dec 3) 5))) ; (inc (inc (+ 2 5))) ; (inc (inc (inc (+ (dec 2) 5)))) ; (inc (inc (inc (+ 1 5)))) ; (inc (inc (inc (inc (+ (dec 1) 5))))) ; (inc (inc (inc (inc (+ 0 5))))) ; (inc (inc (inc (inc 5)))) ; (inc (inc (inc 6))) ; (inc (inc 7)) ; (inc 8) ; 9 ; This is a \"recursive\" procedure ; (2) Definition 2 ; -------------------------------------------------- ; (+ 4 5) ; (+ (dec 4) (inc 5)) ; (+ 3 6) ; (+ (dec 3) (inc 6)) ; (+ 2 7) ; (+ (dec 2) (inc 7)) ; (+ 1 8) ; (+ (dec 1) (inc 8)) ; (+ 0 9) ; 9 ; This is an \"iterative\" procedure","title":"1.09"},{"location":"SICP/ch1-abstraction-procedures/1.09/#109","text":"; Each of the following two procedures defines a ; method for adding two positive integers in terms ; of the procedures inc, which increments its argument ; by 1, and dec, which decrements its argument by 1 ( define ( + a b ) ( if ( = a 0 ) b ( inc ( + ( dec a ) b ))) ) ( define ( + a b ) ( if ( = a 0 ) b ( + ( dec a ) ( inc b ))) ) ; Using the substitution model, illustrate the process ; generated by each procedure in evaluating (+ 4 5). ; Are these processes iterative or recursive? ; Answer ; ; (1) Definition 1 ; -------------------------------------------------- ; (+ 4 5) ; (inc (+ (dec 4) 5)) ; (inc (+ 3 5)) ; (inc (inc (+ (dec 3) 5))) ; (inc (inc (+ 2 5))) ; (inc (inc (inc (+ (dec 2) 5)))) ; (inc (inc (inc (+ 1 5)))) ; (inc (inc (inc (inc (+ (dec 1) 5))))) ; (inc (inc (inc (inc (+ 0 5))))) ; (inc (inc (inc (inc 5)))) ; (inc (inc (inc 6))) ; (inc (inc 7)) ; (inc 8) ; 9 ; This is a \"recursive\" procedure ; (2) Definition 2 ; -------------------------------------------------- ; (+ 4 5) ; (+ (dec 4) (inc 5)) ; (+ 3 6) ; (+ (dec 3) (inc 6)) ; (+ 2 7) ; (+ (dec 2) (inc 7)) ; (+ 1 8) ; (+ (dec 1) (inc 8)) ; (+ 0 9) ; 9 ; This is an \"iterative\" procedure","title":"1.09"},{"location":"SICP/ch1-abstraction-procedures/1.10/","text":"1.10 \u00b6 ; The following procedure computes a mathematical ; function called \"Ackermann\u2019s function\" ( define ( A x y ) ( cond (( = y 0 ) 0 ) (( = x 0 ) ( * 2 y )) (( = y 1 ) 2 ) ( else ( A ( - x 1 ) ( A x ( - y 1 )))))) ; Q1) What are the values of the following expressions? ( A 1 10 ) ( A 2 4 ) ( A 3 3 ) ; A1) ; (A 1 10) ; => (A 0 (A 1 9)) ; => (A 0 (A 0 (A 1 8))) ; => ... ; => 1024 ; (A 2 4) ; => 65536 ; (A 3 3) ; => 65536 ; ; Consider the following procedures, where A ; is the procedure defined above: ( define ( f n ) ( A 0 n )) ( define ( g n ) ( A 1 n )) ( define ( h n ) ( A 2 n )) ( define ( k n ) ( * 5 n n )) ; Q2) Give concise mathematical definitions for the ; functions computed by the procedures f, g, and h ; for positive integer values of n. ; For example, (k n) computes 5n^2 ; ; A2) ; f(n) -> A(0, n) ; -> x=0 -> 2y -> 2n ; => f(n) = 2n ; g(n) -> A(1, n) ; -> A(0, A(1, n-1)) ; -> 2 * A(1, n-1) ; -> 2 * A(0, A(1, n-2)) ; -> 2 * 2 * A(0, A(1, n-3)) ; -> 2 * 2 * 2 ... * 2 (n times) ; => g(n) = 2^n ; ; h(n) -> A(2, n) ; -> A(1, A(2, n-1)) ; -> 2 ^ A(2, n -1) ; -> 2 ^ ( A(1, A(2, n - 2)) ) ; -> 2 ^ 2 ^ A(2, n - 2) ; => h(n) = 2 ^ 2 ^ 2 .... ^ 2 (n times)","title":"1.10"},{"location":"SICP/ch1-abstraction-procedures/1.10/#110","text":"; The following procedure computes a mathematical ; function called \"Ackermann\u2019s function\" ( define ( A x y ) ( cond (( = y 0 ) 0 ) (( = x 0 ) ( * 2 y )) (( = y 1 ) 2 ) ( else ( A ( - x 1 ) ( A x ( - y 1 )))))) ; Q1) What are the values of the following expressions? ( A 1 10 ) ( A 2 4 ) ( A 3 3 ) ; A1) ; (A 1 10) ; => (A 0 (A 1 9)) ; => (A 0 (A 0 (A 1 8))) ; => ... ; => 1024 ; (A 2 4) ; => 65536 ; (A 3 3) ; => 65536 ; ; Consider the following procedures, where A ; is the procedure defined above: ( define ( f n ) ( A 0 n )) ( define ( g n ) ( A 1 n )) ( define ( h n ) ( A 2 n )) ( define ( k n ) ( * 5 n n )) ; Q2) Give concise mathematical definitions for the ; functions computed by the procedures f, g, and h ; for positive integer values of n. ; For example, (k n) computes 5n^2 ; ; A2) ; f(n) -> A(0, n) ; -> x=0 -> 2y -> 2n ; => f(n) = 2n ; g(n) -> A(1, n) ; -> A(0, A(1, n-1)) ; -> 2 * A(1, n-1) ; -> 2 * A(0, A(1, n-2)) ; -> 2 * 2 * A(0, A(1, n-3)) ; -> 2 * 2 * 2 ... * 2 (n times) ; => g(n) = 2^n ; ; h(n) -> A(2, n) ; -> A(1, A(2, n-1)) ; -> 2 ^ A(2, n -1) ; -> 2 ^ ( A(1, A(2, n - 2)) ) ; -> 2 ^ 2 ^ A(2, n - 2) ; => h(n) = 2 ^ 2 ^ 2 .... ^ 2 (n times)","title":"1.10"},{"location":"SICP/ch1-abstraction-procedures/1.11/","text":"1.11 \u00b6 ; A function f is defined by the rule that ; ; f(n) = n if n < 3 ; = f(n-1) + 2f(n-2) + 3f(n-3) if n >= 3 ; ; Write a procedure that computes f by means of a recursive process. ; Write a procedure that computes f by means of an iterative process. ( define ( f-rec n ) ( cond (( < n 3 ) n ) ( else ( + ( f-rec ( - n 1 )) ( * 2 ( f-rec ( - n 2 ))) ( * 3 ( f-rec ( - n 3 )))))) ) ( define ( f-iter n ) ( define ( compute a b c ) ( + c ( * 2 b ) ( * 3 a ))) ( define ( f-iter-inner a b c count ) ( cond (( = count 2 ) c ) (( < count 2 ) count ) ( else ( f-iter-inner b c ( compute a b c ) ( - count 1 ))))) ( f-iter-inner 0 1 2 n ) ) ( f-rec 5 ) ;Value: 25 ( f-rec 4 ) ;Value: 11 ( f-rec 3 ) ;Value: 4 ( f-rec 2 ) ;Value: 2 ( f-rec 1 ) ;Value: 1 ( f-rec 0 ) ;Value: 0 ( f-iter 5 ) ;Value: 25 ( f-iter 4 ) ;Value: 11 ( f-iter 3 ) ;Value: 4 ( f-iter 2 ) ;Value: 2 ( f-iter 1 ) ;Value: 1 ( f-iter 0 ) ;Value: 0","title":"1.11"},{"location":"SICP/ch1-abstraction-procedures/1.11/#111","text":"; A function f is defined by the rule that ; ; f(n) = n if n < 3 ; = f(n-1) + 2f(n-2) + 3f(n-3) if n >= 3 ; ; Write a procedure that computes f by means of a recursive process. ; Write a procedure that computes f by means of an iterative process. ( define ( f-rec n ) ( cond (( < n 3 ) n ) ( else ( + ( f-rec ( - n 1 )) ( * 2 ( f-rec ( - n 2 ))) ( * 3 ( f-rec ( - n 3 )))))) ) ( define ( f-iter n ) ( define ( compute a b c ) ( + c ( * 2 b ) ( * 3 a ))) ( define ( f-iter-inner a b c count ) ( cond (( = count 2 ) c ) (( < count 2 ) count ) ( else ( f-iter-inner b c ( compute a b c ) ( - count 1 ))))) ( f-iter-inner 0 1 2 n ) ) ( f-rec 5 ) ;Value: 25 ( f-rec 4 ) ;Value: 11 ( f-rec 3 ) ;Value: 4 ( f-rec 2 ) ;Value: 2 ( f-rec 1 ) ;Value: 1 ( f-rec 0 ) ;Value: 0 ( f-iter 5 ) ;Value: 25 ( f-iter 4 ) ;Value: 11 ( f-iter 3 ) ;Value: 4 ( f-iter 2 ) ;Value: 2 ( f-iter 1 ) ;Value: 1 ( f-iter 0 ) ;Value: 0","title":"1.11"},{"location":"SICP/ch1-abstraction-procedures/1.12/","text":"1.12 \u00b6 ; The following pattern of numbers is called Pascal\u2019s triangle. ; 1 ; 1 1 ; 1 2 1 ; 1 3 3 1 ; 1 4 6 4 1 ; ; The numbers at the edge of the triangle are all 1, ; and each number inside the triangle is the sum of ; the two numbers above it. ; Write a procedure that computes elements of Pascal\u2019s triangle ; by means of a recursive process ; Answer ; P(row, col) => ; if row = col or col = 1 => 1 ; else =>P(row - 1, col - 1) + P(row - 1, col) ; ( define ( pascal row col ) ( cond (( or ( = row col ) ( = col 1 )) 1 ) ( else ( + ( pascal ( - row 1 ) ( - col 1 )) ( pascal ( - row 1 ) col )))) ) ( pascal 1 1 ) ; 1 ( pascal 2 1 ) ; 1 ( pascal 2 2 ) ; 1 ( pascal 3 2 ) ; 2 ( pascal 4 2 ) ; 3 ( pascal 5 2 ) ; 4 ( pascal 5 3 ) ; 6","title":"1.12"},{"location":"SICP/ch1-abstraction-procedures/1.12/#112","text":"; The following pattern of numbers is called Pascal\u2019s triangle. ; 1 ; 1 1 ; 1 2 1 ; 1 3 3 1 ; 1 4 6 4 1 ; ; The numbers at the edge of the triangle are all 1, ; and each number inside the triangle is the sum of ; the two numbers above it. ; Write a procedure that computes elements of Pascal\u2019s triangle ; by means of a recursive process ; Answer ; P(row, col) => ; if row = col or col = 1 => 1 ; else =>P(row - 1, col - 1) + P(row - 1, col) ; ( define ( pascal row col ) ( cond (( or ( = row col ) ( = col 1 )) 1 ) ( else ( + ( pascal ( - row 1 ) ( - col 1 )) ( pascal ( - row 1 ) col )))) ) ( pascal 1 1 ) ; 1 ( pascal 2 1 ) ; 1 ( pascal 2 2 ) ; 1 ( pascal 3 2 ) ; 2 ( pascal 4 2 ) ; 3 ( pascal 5 2 ) ; 4 ( pascal 5 3 ) ; 6","title":"1.12"},{"location":"SICP/ch1-abstraction-procedures/1.13/","text":"1.13 \u00b6 ; Prove that Fib(n) is the closest integer to ; (\u03c6^n)/\u221a5, where \u03c6 = (1 + \u221a5)/2 ; Hint: Let \u03c8 = (1 \u2212 \u221a5)/2 ; Use induction and the definition of the Fibonacci numbers ; to prove that Fib(n) = (\u03c6^n \u2212 \u03c8^n )/\u221a5 ( define phi ( / ( + 1 ( sqrt 5 )) 2 )) ( define ( f n ) ( / ( expt phi n ) ( sqrt 5 ))) ( f 0 ) ( f 1 ) ( f 2 ) ( f 3 ) ( f 4 ) ( f 5 ) ( f 6 ) ; Proof by Induction method: ; http://www.billthelizard.com/2009/12/sicp-exercise-113-fibonacci-and-golden.html","title":"1.13"},{"location":"SICP/ch1-abstraction-procedures/1.13/#113","text":"; Prove that Fib(n) is the closest integer to ; (\u03c6^n)/\u221a5, where \u03c6 = (1 + \u221a5)/2 ; Hint: Let \u03c8 = (1 \u2212 \u221a5)/2 ; Use induction and the definition of the Fibonacci numbers ; to prove that Fib(n) = (\u03c6^n \u2212 \u03c8^n )/\u221a5 ( define phi ( / ( + 1 ( sqrt 5 )) 2 )) ( define ( f n ) ( / ( expt phi n ) ( sqrt 5 ))) ( f 0 ) ( f 1 ) ( f 2 ) ( f 3 ) ( f 4 ) ( f 5 ) ( f 6 ) ; Proof by Induction method: ; http://www.billthelizard.com/2009/12/sicp-exercise-113-fibonacci-and-golden.html","title":"1.13"},{"location":"SICP/ch1-abstraction-procedures/1.15/","text":"1.15 \u00b6 ; The sine of an angle (specified in radians) can be ; computed by making use of the approximation sin x \u2248 x ; if x is sufficiently small, and the trigonometric identity ; sin x = 3 sin (x/3) \u2212 4 sin^3 (x/3) ; to reduce the size of the argument of sin. ; (For purposes of this exercise an angle is considered ; \u201csufficiently small\u201d if its magnitude is not greater than 0.1 ; radians.) These ideas are incorporated in the following procedures: ( define ( cube x ) ( * x x x )) ( define ( p x ) ( - ( * 3 x ) ( * 4 ( cube x )))) ( define ( sine angle ) ( if ( not ( > ( abs angle ) 0.1 )) angle ( p ( sine ( / angle 3.0 ))))) ; a) How many times is the procedure \"p\" applied when (sine 12.15) is evaluated? ; Answer ; (sine 12.15) ; (p (sine 4.05)) ; (p (p (sine 1.35))) ; (p (p (p (sine 0.45)))) ; (p (p (p (p (sine 0.15))))) ; (p (p (p (p (p (sine 0.05)))))) ; (p (p (p (p (p 0.05))))) ; => Procedure \"p\" is applied 5 times ; b) What is the order of growth in space and number of steps ; (as a function of a) used by the process generated by the ; sine procedure when (sine a) is evaluated? ; Anwer ; => Order of growth = O(log (a)) ; ; To calculate number of steps, ; 0.05 x 3 x 3 x 3 x 3 x 3 = 12.15 ; => 0.05 x 3^5 = 12.15 ; => 3^5 = (12.15 / 0.05) ; -> rewriting, 5 = log3(12.15 / 0.05) (log base 3) ; Hence, we got 5 (number of steps) like above ; In general, we can say that, ; => no.of.steps = log3(a / 0.1) (since at 0.1, applying p is stopped) ; Since this number is not an integer, we would have to take upper ; bound of the number (ceiling) ; ; i.e. No.of.steps = ceil(log (a / 0.1) / log 3) (since, logb(a) = log a / log b) ( define ( no-of-steps a ) ( ceiling ( / ( log ( / a 0.1 )) ( log 3 ))) )","title":"1.15"},{"location":"SICP/ch1-abstraction-procedures/1.15/#115","text":"; The sine of an angle (specified in radians) can be ; computed by making use of the approximation sin x \u2248 x ; if x is sufficiently small, and the trigonometric identity ; sin x = 3 sin (x/3) \u2212 4 sin^3 (x/3) ; to reduce the size of the argument of sin. ; (For purposes of this exercise an angle is considered ; \u201csufficiently small\u201d if its magnitude is not greater than 0.1 ; radians.) These ideas are incorporated in the following procedures: ( define ( cube x ) ( * x x x )) ( define ( p x ) ( - ( * 3 x ) ( * 4 ( cube x )))) ( define ( sine angle ) ( if ( not ( > ( abs angle ) 0.1 )) angle ( p ( sine ( / angle 3.0 ))))) ; a) How many times is the procedure \"p\" applied when (sine 12.15) is evaluated? ; Answer ; (sine 12.15) ; (p (sine 4.05)) ; (p (p (sine 1.35))) ; (p (p (p (sine 0.45)))) ; (p (p (p (p (sine 0.15))))) ; (p (p (p (p (p (sine 0.05)))))) ; (p (p (p (p (p 0.05))))) ; => Procedure \"p\" is applied 5 times ; b) What is the order of growth in space and number of steps ; (as a function of a) used by the process generated by the ; sine procedure when (sine a) is evaluated? ; Anwer ; => Order of growth = O(log (a)) ; ; To calculate number of steps, ; 0.05 x 3 x 3 x 3 x 3 x 3 = 12.15 ; => 0.05 x 3^5 = 12.15 ; => 3^5 = (12.15 / 0.05) ; -> rewriting, 5 = log3(12.15 / 0.05) (log base 3) ; Hence, we got 5 (number of steps) like above ; In general, we can say that, ; => no.of.steps = log3(a / 0.1) (since at 0.1, applying p is stopped) ; Since this number is not an integer, we would have to take upper ; bound of the number (ceiling) ; ; i.e. No.of.steps = ceil(log (a / 0.1) / log 3) (since, logb(a) = log a / log b) ( define ( no-of-steps a ) ( ceiling ( / ( log ( / a 0.1 )) ( log 3 ))) )","title":"1.15"},{"location":"SICP/ch1-abstraction-procedures/1.16/","text":"1.16 \u00b6 ; Design a procedure that evolves an iterative ; exponentiation process that uses successive squaring ; and uses a logarithmic number of steps, as does `fast-expt` ; (Hint: Using the observation that (bn/2)2 = (b2)n/2, keep, ; along with the exponent n and the base b, an additional state variable a, ; and define the state transformation in such a way that the product ab^n is ; unchanged from state to state. At the beginning of the process a is taken to be 1, ; and the answer is given by the value of a at the end of the process. ; In general, the technique of defining an invariant quantity that remains unchanged ; from state to state is a powerful way to think about the design of ; iterative algorithms.) ( define ( fast-expt b n ) ( define ( even? n ) ( = ( remainder n 2 ) 0 )) ( define ( fast-expt-iter base counter prod ) ( cond (( = counter 0 ) prod ) (( even? counter ) ( fast-expt-iter ( square base ) ( / counter 2 ) prod )) ( else ( fast-expt-iter base ( - counter 1 ) ( * base prod ))) ) ) ( fast-expt-iter b n 1 ) ) ( fast-expt 2 10 ) ;Value: 1024 ( fast-expt 2 5 ) ;Value: 32 ( fast-expt 2 1000 ) ;Value: 1071508607186267320948425049 ;0600018105614048117055336074437503883703510511249361224931 ;98378815695858127594672917553146825187145285692314043598457 ;757469857480393456777482423098542107460506237114187795418215 ;30464749835819412673987675591655439460770629145711964776865421 ;67660429831652624386837205668069376","title":"1.16"},{"location":"SICP/ch1-abstraction-procedures/1.16/#116","text":"; Design a procedure that evolves an iterative ; exponentiation process that uses successive squaring ; and uses a logarithmic number of steps, as does `fast-expt` ; (Hint: Using the observation that (bn/2)2 = (b2)n/2, keep, ; along with the exponent n and the base b, an additional state variable a, ; and define the state transformation in such a way that the product ab^n is ; unchanged from state to state. At the beginning of the process a is taken to be 1, ; and the answer is given by the value of a at the end of the process. ; In general, the technique of defining an invariant quantity that remains unchanged ; from state to state is a powerful way to think about the design of ; iterative algorithms.) ( define ( fast-expt b n ) ( define ( even? n ) ( = ( remainder n 2 ) 0 )) ( define ( fast-expt-iter base counter prod ) ( cond (( = counter 0 ) prod ) (( even? counter ) ( fast-expt-iter ( square base ) ( / counter 2 ) prod )) ( else ( fast-expt-iter base ( - counter 1 ) ( * base prod ))) ) ) ( fast-expt-iter b n 1 ) ) ( fast-expt 2 10 ) ;Value: 1024 ( fast-expt 2 5 ) ;Value: 32 ( fast-expt 2 1000 ) ;Value: 1071508607186267320948425049 ;0600018105614048117055336074437503883703510511249361224931 ;98378815695858127594672917553146825187145285692314043598457 ;757469857480393456777482423098542107460506237114187795418215 ;30464749835819412673987675591655439460770629145711964776865421 ;67660429831652624386837205668069376","title":"1.16"},{"location":"SICP/ch1-abstraction-procedures/1.17/","text":"1.17 \u00b6 ; The exponentiation algorithms in this section are ; based on performing exponentiation by means of repeated ; multiplication. In a similar way, one can perform integer ; multiplication by means of repeated addition. The following ; multiplication procedure (in which it is assumed that our ; language can only add, not multiply) is analogous to the ; `expt` procedure ( define ( * a b ) ( if ( = b 0 ) 0 ( + a ( * a ( - b 1 ))))) ; This algorithm takes a number of steps that is linear in b. ; Now suppose we include, together with addition, operations `double`, ; which doubles an integer, and `halve`, which divides an (even) integer by 2. ; Using these, design a multiplication procedure analogous to `fast-expt` that ; uses a logarithmic number of steps. ( define ( fast-mul a b ) ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( double x ) ( + x x )) ( define ( halve x ) ( / x 2 )) ( cond (( = b 0 ) 0 ) (( even? b ) ( fast-mul ( double a ) ( halve b ))) ( else ( + a ( fast-mul a ( - b 1 )))) ) ) ( fast-mul 2 6 ) ;Value: 12 ( fast-mul 24 67 ) ;Value: 1608 ( fast-mul 1 7 ) ;Value: 7","title":"1.17"},{"location":"SICP/ch1-abstraction-procedures/1.17/#117","text":"; The exponentiation algorithms in this section are ; based on performing exponentiation by means of repeated ; multiplication. In a similar way, one can perform integer ; multiplication by means of repeated addition. The following ; multiplication procedure (in which it is assumed that our ; language can only add, not multiply) is analogous to the ; `expt` procedure ( define ( * a b ) ( if ( = b 0 ) 0 ( + a ( * a ( - b 1 ))))) ; This algorithm takes a number of steps that is linear in b. ; Now suppose we include, together with addition, operations `double`, ; which doubles an integer, and `halve`, which divides an (even) integer by 2. ; Using these, design a multiplication procedure analogous to `fast-expt` that ; uses a logarithmic number of steps. ( define ( fast-mul a b ) ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( double x ) ( + x x )) ( define ( halve x ) ( / x 2 )) ( cond (( = b 0 ) 0 ) (( even? b ) ( fast-mul ( double a ) ( halve b ))) ( else ( + a ( fast-mul a ( - b 1 )))) ) ) ( fast-mul 2 6 ) ;Value: 12 ( fast-mul 24 67 ) ;Value: 1608 ( fast-mul 1 7 ) ;Value: 7","title":"1.17"},{"location":"SICP/ch1-abstraction-procedures/1.18/","text":"1.18 \u00b6 ; Using the results of Exercise 1.16 and Exercise 1.17, ; devise a procedure that generates an iterative process ; for multiplying two integers in terms of adding, doubling, ; and halving and uses a logarithmic number of steps ( define ( fast-mul a b ) ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( double x ) ( + x x )) ( define ( halve x ) ( / x 2 )) ( define ( fast-mul-iter a counter sum ) ( cond (( = counter 0 ) sum ) (( even? counter ) ( fast-mul-iter ( double a ) ( halve counter ) sum )) ( else ( fast-mul-iter a ( - counter 1 ) ( + a sum ))) ) ) ( fast-mul-iter a b 0 ) ) ( fast-mul 2 6 ) ;Value: 12 ( fast-mul 24 67 ) ;Value: 1608 ( fast-mul 1 7 ) ;Value: 7","title":"1.18"},{"location":"SICP/ch1-abstraction-procedures/1.18/#118","text":"; Using the results of Exercise 1.16 and Exercise 1.17, ; devise a procedure that generates an iterative process ; for multiplying two integers in terms of adding, doubling, ; and halving and uses a logarithmic number of steps ( define ( fast-mul a b ) ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( double x ) ( + x x )) ( define ( halve x ) ( / x 2 )) ( define ( fast-mul-iter a counter sum ) ( cond (( = counter 0 ) sum ) (( even? counter ) ( fast-mul-iter ( double a ) ( halve counter ) sum )) ( else ( fast-mul-iter a ( - counter 1 ) ( + a sum ))) ) ) ( fast-mul-iter a b 0 ) ) ( fast-mul 2 6 ) ;Value: 12 ( fast-mul 24 67 ) ;Value: 1608 ( fast-mul 1 7 ) ;Value: 7","title":"1.18"},{"location":"SICP/ch1-abstraction-procedures/1.19/","text":"1.19 \u00b6 ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( fib n ) ( fib-iter 1 0 0 1 n )) ( define ( fib-iter a b p q count ) ( cond (( = count 0 ) b ) (( even? count ) ( fib-iter a b ( + ( square p ) ( square q )) ( + ( * 2 p q ) ( square q )) ( / count 2 ))) ( else ( fib-iter ( + ( * b q ) ( * a q ) ( * a p )) ( + ( * b p ) ( * a q )) p q ( - count 1 ))))) ( fib 0 ) ( fib 1 ) ( fib 2 ) ( fib 3 ) ( fib 4 ) ( fib 5 ) ( fib 6 ) ( fib 7 ) ( fib 8 ) ( fib 9 ) ( fib 10 )","title":"1.19"},{"location":"SICP/ch1-abstraction-procedures/1.19/#119","text":"( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( fib n ) ( fib-iter 1 0 0 1 n )) ( define ( fib-iter a b p q count ) ( cond (( = count 0 ) b ) (( even? count ) ( fib-iter a b ( + ( square p ) ( square q )) ( + ( * 2 p q ) ( square q )) ( / count 2 ))) ( else ( fib-iter ( + ( * b q ) ( * a q ) ( * a p )) ( + ( * b p ) ( * a q )) p q ( - count 1 ))))) ( fib 0 ) ( fib 1 ) ( fib 2 ) ( fib 3 ) ( fib 4 ) ( fib 5 ) ( fib 6 ) ( fib 7 ) ( fib 8 ) ( fib 9 ) ( fib 10 )","title":"1.19"},{"location":"SICP/ch1-abstraction-procedures/1.20/","text":"1.20 \u00b6 ; The process that a procedure generates is of course ; dependent on the rules used by the interpreter. ; As an example, consider the iterative gcd procedure given above. ; Suppose we were to interpret this procedure using normal-order evaluation, ; as discussed in Section 1.1.5. (The normal-order-evaluation rule for if is ; described in Exercise 1.5.) Using the substitution method (for normal order), ; illustrate the process generated in evaluating (gcd 206 40) and indicate the ; remainder operations that are actually performed. How many remainder ; operations are actually performed in the normal-order evaluation of (gcd 206 40)? ; In the applicative-order evaluation? ; (a) Normal order evaluation of (gcd 206 40) ; (gcd 206 40) ; (if (= 40 0) 40) (not true) ; (gcd 40 (remainder 206 40)) ; (if (= (remainder 206 40) 0) ...) ; (gcd (remainder 206 40) (remainder 40 (remainder 206 40))) ; ; (gcd (remainder 40 (remainder 206 40)) ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) ; (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ; (remainder ; (remainder 40 (remainder 206 40)) ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) ; Total remainders = 18 ( gcd 206 40 ) ( if ( = 40 0 ) 40 ( gcd 40 ( remainder 206 40 ))) ( gcd 40 ( remainder 206 40 )) ( if ( = ( remainder 206 40 ) 0 ) 40 ( gcd ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 )))) ( gcd ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 ))) ( if ( = ( remainder 40 ( remainder 206 40 )) 0 ) ( remainder 206 40 ) ( gcd ( remainder 40 ( remainder 206 40 )) ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 ))))) ( gcd ( remainder 40 ( remainder 206 40 )) ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 )))) ( if ( = ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 ))) 0 ) ( remainder 40 ( remainder 206 40 )) ( gcd ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 ))) ( remainder ( remainder 40 ( remainder 206 40 )) ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 )))))) ( gcd ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 ))) ( remainder ( remainder 40 ( remainder 206 40 )) ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 ))))) ( if ( = ( remainder ( remainder 40 ( remainder 206 40 )) ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 )))) 0 ) ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 ))) ( gcd ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 ))) ( remainder ( remainder 40 ( remainder 206 40 )) ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 )))))) ; (b) Applicative-order evaluation ( gcd 206 40 ) ( gcd 40 ( remainder 206 40 )) ( gcd 40 6 ) ( gcd 6 ( remainder 40 6 )) ( gcd 6 4 ) ( gcd 4 ( remainder 6 4 )) ( gcd 4 2 ) ( gcd 2 ( remainder 4 2 )) ( gcd 2 0 ) 2 ; Total remainder operations = 4","title":"1.20"},{"location":"SICP/ch1-abstraction-procedures/1.20/#120","text":"; The process that a procedure generates is of course ; dependent on the rules used by the interpreter. ; As an example, consider the iterative gcd procedure given above. ; Suppose we were to interpret this procedure using normal-order evaluation, ; as discussed in Section 1.1.5. (The normal-order-evaluation rule for if is ; described in Exercise 1.5.) Using the substitution method (for normal order), ; illustrate the process generated in evaluating (gcd 206 40) and indicate the ; remainder operations that are actually performed. How many remainder ; operations are actually performed in the normal-order evaluation of (gcd 206 40)? ; In the applicative-order evaluation? ; (a) Normal order evaluation of (gcd 206 40) ; (gcd 206 40) ; (if (= 40 0) 40) (not true) ; (gcd 40 (remainder 206 40)) ; (if (= (remainder 206 40) 0) ...) ; (gcd (remainder 206 40) (remainder 40 (remainder 206 40))) ; ; (gcd (remainder 40 (remainder 206 40)) ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) ; (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ; (remainder ; (remainder 40 (remainder 206 40)) ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) ; Total remainders = 18 ( gcd 206 40 ) ( if ( = 40 0 ) 40 ( gcd 40 ( remainder 206 40 ))) ( gcd 40 ( remainder 206 40 )) ( if ( = ( remainder 206 40 ) 0 ) 40 ( gcd ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 )))) ( gcd ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 ))) ( if ( = ( remainder 40 ( remainder 206 40 )) 0 ) ( remainder 206 40 ) ( gcd ( remainder 40 ( remainder 206 40 )) ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 ))))) ( gcd ( remainder 40 ( remainder 206 40 )) ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 )))) ( if ( = ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 ))) 0 ) ( remainder 40 ( remainder 206 40 )) ( gcd ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 ))) ( remainder ( remainder 40 ( remainder 206 40 )) ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 )))))) ( gcd ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 ))) ( remainder ( remainder 40 ( remainder 206 40 )) ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 ))))) ( if ( = ( remainder ( remainder 40 ( remainder 206 40 )) ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 )))) 0 ) ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 ))) ( gcd ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 ))) ( remainder ( remainder 40 ( remainder 206 40 )) ( remainder ( remainder 206 40 ) ( remainder 40 ( remainder 206 40 )))))) ; (b) Applicative-order evaluation ( gcd 206 40 ) ( gcd 40 ( remainder 206 40 )) ( gcd 40 6 ) ( gcd 6 ( remainder 40 6 )) ( gcd 6 4 ) ( gcd 4 ( remainder 6 4 )) ( gcd 4 2 ) ( gcd 2 ( remainder 4 2 )) ( gcd 2 0 ) 2 ; Total remainder operations = 4","title":"1.20"},{"location":"SICP/ch1-abstraction-procedures/1.21/","text":"1.21 \u00b6 ; Use the `smallest-divisor` procedure to find the ; smallest divisor of each of the following numbers: ; 199, 1999, 19999. ( define ( divides? a b ) ( = ( remainder b a ) 0 )) ( define ( smallest-divisor n ) ( find-divisor n 2 )) ( define ( find-divisor n test-divisor ) ( cond (( > ( square test-divisor ) n ) n ) (( divides? test-divisor n ) test-divisor ) ( else ( find-divisor n ( + test-divisor 1 ))))) ( smallest-divisor 199 ) ;Value: 199 ( smallest-divisor 1999 ) ;Value: 1999 ( smallest-divisor 19999 ) ;Value: 7","title":"1.21"},{"location":"SICP/ch1-abstraction-procedures/1.21/#121","text":"; Use the `smallest-divisor` procedure to find the ; smallest divisor of each of the following numbers: ; 199, 1999, 19999. ( define ( divides? a b ) ( = ( remainder b a ) 0 )) ( define ( smallest-divisor n ) ( find-divisor n 2 )) ( define ( find-divisor n test-divisor ) ( cond (( > ( square test-divisor ) n ) n ) (( divides? test-divisor n ) test-divisor ) ( else ( find-divisor n ( + test-divisor 1 ))))) ( smallest-divisor 199 ) ;Value: 199 ( smallest-divisor 1999 ) ;Value: 1999 ( smallest-divisor 19999 ) ;Value: 7","title":"1.21"},{"location":"SICP/ch1-abstraction-procedures/1.22/","text":"1.22 \u00b6 ; Most Lisp implementations include a primitive called ; `runtime` that returns an integer that specifies the ; amount of time the system has been running (measured, ; for example, in microseconds). The following `timed-prime-test` ; procedure, when called with an integer n, prints n and ; checks to see if n is prime. If n is prime, the procedure ; prints three asterisks followed by the amount of time used ; in performing the test. ( define ( timed-prime-test n ) ( newline ) ( display n ) ( start-prime-test n ( runtime ))) ( define ( start-prime-test n start-time ) ( if ( prime? n ) ( report-prime ( - ( runtime ) start-time )))) ( define ( report-prime elapsed-time ) ( display \" *** \" ) ( display elapsed-time )) ; Using this procedure, write a procedure `search-for-primes` ; that checks the primality of consecutive odd integers in a ; specified range. Use your procedure to find the three ; smallest primes larger than 1000; larger than 10,000; ; larger than 100,000; larger than 1,000,000. Note the time ; needed to test each prime. Since the testing algorithm has ; order of growth of \u0398(\u221an), you should expect that testing for ; primes around 10,000 should take about \u221a10 times as long as ; testing for primes around 1000. Do your timing data bear this out? ; How well do the data for 100,000 and 1,000,000 support the \u0398(\u221an) ; prediction? Is your result compatible with the notion that ; programs on your machine run in time proportional to the number ; of steps required for the computation? ; ANSWER ; Let's define `prime?` procedure ( define ( divides? a b ) ( = ( remainder b a ) 0 )) ( define ( prime? n ) ( define ( smallest-divisor n ) ( find-divisor n 2 )) ( define ( find-divisor n test-divisor ) ( cond (( > ( square test-divisor ) n ) n ) (( divides? test-divisor n ) test-divisor ) ( else ( find-divisor n ( + test-divisor 1 ))))) ( = n ( smallest-divisor n )) ) ; Write `search-for-primes` procedure ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( search-for-primes start end ) ( define ( search-for-primes-iter cur ) ( if ( <= cur end ) ( timed-prime-test cur )) ( if ( <= cur end ) ( search-for-primes-iter ( + 2 cur ))) ) ( search-for-primes-iter ( if ( even? start ) ( + 1 start ) start ))) ( search-for-primes 1000 1020 ) ( search-for-primes 10000 10050 ) ( search-for-primes 1000000 1000100 ) ; We almost see zero for computation time. ; Hence we need to increase the quantity of numbers ( search-for-primes 1000000000 1000000025 ) ; 10^9 ( search-for-primes 10000000000 10000000080 ) ; 10^10 ( search-for-primes 100000000000 100000000060 ) ; 10^11 ( search-for-primes 1000000000000 1000000000065 ) ; 10^12 ( search-for-primes 10000000000000 10000000000080 ) ; 10^13 ; On my MacBook air, the following times were reported ; 10^9 => ~ 0.06 ; 10^10 => ~ 0.16 ; 10^11 => ~ 0.5 ; 10^12 => ~ 1.45 ; 10^13 => ~ 4.75 ; \u221a10 ~ 3.16 ; If we calculate, ; (a) Time(10^11) / Time(10^10) = 0.5 / 0.16 = 3.125 ; (b) Time(10^10) / Time(10^9) = 0.16 / 0.06 = 2.67 ; (c) Time(10^12) / Time(10^11) = 1.45 / 0.5 = 2.9 ; (c) Time(10^13) / Time(10^12) = 4.75 / 1.45 = 3.275","title":"1.22"},{"location":"SICP/ch1-abstraction-procedures/1.22/#122","text":"; Most Lisp implementations include a primitive called ; `runtime` that returns an integer that specifies the ; amount of time the system has been running (measured, ; for example, in microseconds). The following `timed-prime-test` ; procedure, when called with an integer n, prints n and ; checks to see if n is prime. If n is prime, the procedure ; prints three asterisks followed by the amount of time used ; in performing the test. ( define ( timed-prime-test n ) ( newline ) ( display n ) ( start-prime-test n ( runtime ))) ( define ( start-prime-test n start-time ) ( if ( prime? n ) ( report-prime ( - ( runtime ) start-time )))) ( define ( report-prime elapsed-time ) ( display \" *** \" ) ( display elapsed-time )) ; Using this procedure, write a procedure `search-for-primes` ; that checks the primality of consecutive odd integers in a ; specified range. Use your procedure to find the three ; smallest primes larger than 1000; larger than 10,000; ; larger than 100,000; larger than 1,000,000. Note the time ; needed to test each prime. Since the testing algorithm has ; order of growth of \u0398(\u221an), you should expect that testing for ; primes around 10,000 should take about \u221a10 times as long as ; testing for primes around 1000. Do your timing data bear this out? ; How well do the data for 100,000 and 1,000,000 support the \u0398(\u221an) ; prediction? Is your result compatible with the notion that ; programs on your machine run in time proportional to the number ; of steps required for the computation? ; ANSWER ; Let's define `prime?` procedure ( define ( divides? a b ) ( = ( remainder b a ) 0 )) ( define ( prime? n ) ( define ( smallest-divisor n ) ( find-divisor n 2 )) ( define ( find-divisor n test-divisor ) ( cond (( > ( square test-divisor ) n ) n ) (( divides? test-divisor n ) test-divisor ) ( else ( find-divisor n ( + test-divisor 1 ))))) ( = n ( smallest-divisor n )) ) ; Write `search-for-primes` procedure ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( search-for-primes start end ) ( define ( search-for-primes-iter cur ) ( if ( <= cur end ) ( timed-prime-test cur )) ( if ( <= cur end ) ( search-for-primes-iter ( + 2 cur ))) ) ( search-for-primes-iter ( if ( even? start ) ( + 1 start ) start ))) ( search-for-primes 1000 1020 ) ( search-for-primes 10000 10050 ) ( search-for-primes 1000000 1000100 ) ; We almost see zero for computation time. ; Hence we need to increase the quantity of numbers ( search-for-primes 1000000000 1000000025 ) ; 10^9 ( search-for-primes 10000000000 10000000080 ) ; 10^10 ( search-for-primes 100000000000 100000000060 ) ; 10^11 ( search-for-primes 1000000000000 1000000000065 ) ; 10^12 ( search-for-primes 10000000000000 10000000000080 ) ; 10^13 ; On my MacBook air, the following times were reported ; 10^9 => ~ 0.06 ; 10^10 => ~ 0.16 ; 10^11 => ~ 0.5 ; 10^12 => ~ 1.45 ; 10^13 => ~ 4.75 ; \u221a10 ~ 3.16 ; If we calculate, ; (a) Time(10^11) / Time(10^10) = 0.5 / 0.16 = 3.125 ; (b) Time(10^10) / Time(10^9) = 0.16 / 0.06 = 2.67 ; (c) Time(10^12) / Time(10^11) = 1.45 / 0.5 = 2.9 ; (c) Time(10^13) / Time(10^12) = 4.75 / 1.45 = 3.275","title":"1.22"},{"location":"SICP/ch1-abstraction-procedures/1.23/","text":"1.23 \u00b6 ; The `smallest-divisor` procedure shown at the start ; of this section does lots of needless testing: After ; it checks to see if the number is divisible by 2 there ; is no point in checking to see if it is divisible by any ; larger even numbbers. This suggests that the values ; used for test-divisor should not be 2, 3, 4, 5, 6, . . ., ; but rather 2, 3, 5, 7, 9, . . .. ; To implement this change, define a procedure next that ; returns 3 if its input is equal to 2 and otherwise returns ; its input plus 2. Modify the smallest-divisor procedure ; to use (next test-divisor) instead of (+ test-divisor 1). ; With timed-prime-test incorporating this modified version ; of smallest-divisor, run the test for each of the 12 primes ; found in Exercise 1.22. Since this modification halves the ; number of test steps, you should expect it to run about twice as fast. ; Is this expectation confirmed? If not, what is the observed ratio ; of the speeds of the two algorithms, and how do you explain the ; fact that it is different from 2? ( define ( divides? a b ) ( = ( remainder b a ) 0 )) ( define ( prime? n ) ( define ( smallest-divisor n ) ( find-divisor n 2 )) ( define ( find-divisor n test-divisor ) ( cond (( > ( square test-divisor ) n ) n ) (( divides? test-divisor n ) test-divisor ) ( else ( find-divisor n ( next test-divisor ))))) ( = n ( smallest-divisor n )) ) ( define ( next n ) ( if ( = n 2 ) 3 ( + n 2 ))) ; Timed prime test ( define ( timed-prime-test n ) ( newline ) ( display n ) ( start-prime-test n ( runtime ))) ( define ( start-prime-test n start-time ) ( if ( prime? n ) ( report-prime ( - ( runtime ) start-time )))) ( define ( report-prime elapsed-time ) ( display \" *** \" ) ( display elapsed-time )) ; 12 primes found in `Exercise 1.22` ( timed-prime-test 1000000007 ) ; .03 ( timed-prime-test 1000000009 ) ; .03 ( timed-prime-test 1000000021 ) ; .04000000000000001 ( timed-prime-test 10000000019 ) ; .08999999999999997 ( timed-prime-test 10000000033 ) ; .09000000000000002 ( timed-prime-test 10000000061 ) ; .08999999999999997 ( timed-prime-test 100000000003 ) ; .27 ( timed-prime-test 100000000019 ) ; .30000000000000004 ( timed-prime-test 100000000057 ) ; .28 ( timed-prime-test 1000000000039 ) ; 1.0399999999999998 ( timed-prime-test 1000000000061 ) ; .8500000000000001 ( timed-prime-test 1000000000063 ) ; .8600000000000003 ; Comparing the order v/s time from previous and current ; implementations ; ------------------------------------------------ ; | Order | Previous | Current | Factor reduced | ; |----------------------------------------------| ; | 10^9 | 0.06 | 0.04 | 1.5 | ; | 10^10 | 0.16 | 0.9 | 1.77 | ; | 10^11 | 0.5 | 0.3 | 1.66 | ; | 10^12 | 1.45 | 0.85 | 1.7 | ; |----------------------------------------------| ; ; As we observe, factor reduced is not exactly 2, but ~1.5-1.6 ; This is because, we spend some time during IF condition ; present in `next` procedure","title":"1.23"},{"location":"SICP/ch1-abstraction-procedures/1.23/#123","text":"; The `smallest-divisor` procedure shown at the start ; of this section does lots of needless testing: After ; it checks to see if the number is divisible by 2 there ; is no point in checking to see if it is divisible by any ; larger even numbbers. This suggests that the values ; used for test-divisor should not be 2, 3, 4, 5, 6, . . ., ; but rather 2, 3, 5, 7, 9, . . .. ; To implement this change, define a procedure next that ; returns 3 if its input is equal to 2 and otherwise returns ; its input plus 2. Modify the smallest-divisor procedure ; to use (next test-divisor) instead of (+ test-divisor 1). ; With timed-prime-test incorporating this modified version ; of smallest-divisor, run the test for each of the 12 primes ; found in Exercise 1.22. Since this modification halves the ; number of test steps, you should expect it to run about twice as fast. ; Is this expectation confirmed? If not, what is the observed ratio ; of the speeds of the two algorithms, and how do you explain the ; fact that it is different from 2? ( define ( divides? a b ) ( = ( remainder b a ) 0 )) ( define ( prime? n ) ( define ( smallest-divisor n ) ( find-divisor n 2 )) ( define ( find-divisor n test-divisor ) ( cond (( > ( square test-divisor ) n ) n ) (( divides? test-divisor n ) test-divisor ) ( else ( find-divisor n ( next test-divisor ))))) ( = n ( smallest-divisor n )) ) ( define ( next n ) ( if ( = n 2 ) 3 ( + n 2 ))) ; Timed prime test ( define ( timed-prime-test n ) ( newline ) ( display n ) ( start-prime-test n ( runtime ))) ( define ( start-prime-test n start-time ) ( if ( prime? n ) ( report-prime ( - ( runtime ) start-time )))) ( define ( report-prime elapsed-time ) ( display \" *** \" ) ( display elapsed-time )) ; 12 primes found in `Exercise 1.22` ( timed-prime-test 1000000007 ) ; .03 ( timed-prime-test 1000000009 ) ; .03 ( timed-prime-test 1000000021 ) ; .04000000000000001 ( timed-prime-test 10000000019 ) ; .08999999999999997 ( timed-prime-test 10000000033 ) ; .09000000000000002 ( timed-prime-test 10000000061 ) ; .08999999999999997 ( timed-prime-test 100000000003 ) ; .27 ( timed-prime-test 100000000019 ) ; .30000000000000004 ( timed-prime-test 100000000057 ) ; .28 ( timed-prime-test 1000000000039 ) ; 1.0399999999999998 ( timed-prime-test 1000000000061 ) ; .8500000000000001 ( timed-prime-test 1000000000063 ) ; .8600000000000003 ; Comparing the order v/s time from previous and current ; implementations ; ------------------------------------------------ ; | Order | Previous | Current | Factor reduced | ; |----------------------------------------------| ; | 10^9 | 0.06 | 0.04 | 1.5 | ; | 10^10 | 0.16 | 0.9 | 1.77 | ; | 10^11 | 0.5 | 0.3 | 1.66 | ; | 10^12 | 1.45 | 0.85 | 1.7 | ; |----------------------------------------------| ; ; As we observe, factor reduced is not exactly 2, but ~1.5-1.6 ; This is because, we spend some time during IF condition ; present in `next` procedure","title":"1.23"},{"location":"SICP/ch1-abstraction-procedures/1.24/","text":"1.24 \u00b6 ; Modify the timed-prime-test procedure of Exercise 1.22 ; to use fast-prime? (the Fermat method), and test each ; of the 12 primes you found in that exercise. Since the ; Fermat test has \u0398(log n) growth, how would you expect ; the time to test primes near 1,000,000 to compare with ; the time needed to test primes near 1000? Do your data ; bear this out? Can you explain any discrepancy you find? ; Let's define fast-prime procedure ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( expmod base exp m ) ( cond (( = exp 0 ) 1 ) (( even? exp ) ( remainder ( square ( expmod base ( / exp 2 ) m )) m )) ( else ( remainder ( * base ( expmod base ( - exp 1 ) m )) m )))) ( define ( fermat-test n ) ( define ( try-it a ) ( = ( expmod a n n ) a )) ( try-it ( + 1 ( random ( - n 1 ))))) ( define ( fast-prime? n times ) ( cond (( = times 0 ) true ) (( fermat-test n ) ( fast-prime? n ( - times 1 ))) ( else false ))) ( define ( prime? n ) ( fast-prime? n 500 )) ; Define `timed-prime-test` procedure ( define ( timed-prime-test n ) ( newline ) ( display n ) ( start-prime-test n ( runtime ))) ( define ( start-prime-test n start-time ) ( if ( prime? n ) ( report-prime ( - ( runtime ) start-time )))) ( define ( report-prime elapsed-time ) ( display \" *** \" ) ( display elapsed-time )) ; Test the timing on large prime numbers ( timed-prime-test 1000000007 ) ; .05000000000000002 ( timed-prime-test 1000000009 ) ; .03999999999999998 ( timed-prime-test 1000000021 ) ; .04000000000000001 ( timed-prime-test 10000000019 ) ; .06 ( timed-prime-test 10000000033 ) ; .04999999999999999 ( timed-prime-test 10000000061 ) ; .06 ( timed-prime-test 100000000003 ) ; .06 ( timed-prime-test 100000000019 ) ; .06000000000000005 ( timed-prime-test 100000000057 ) ; .06000000000000005 ( timed-prime-test 1000000000039 ) ; .06999999999999995 ( timed-prime-test 1000000000061 ) ; .06000000000000005 ; Test by doubling number of digits ( timed-prime-test 1000003 ) ; 3.9999999999999925e-2 ( timed-prime-test 1000000000063 ) ; .08000000000000007 ; i.e. ; 10^6 => 0.04 ; 10^12 => 0.08, which is a logarithmic scale","title":"1.24"},{"location":"SICP/ch1-abstraction-procedures/1.24/#124","text":"; Modify the timed-prime-test procedure of Exercise 1.22 ; to use fast-prime? (the Fermat method), and test each ; of the 12 primes you found in that exercise. Since the ; Fermat test has \u0398(log n) growth, how would you expect ; the time to test primes near 1,000,000 to compare with ; the time needed to test primes near 1000? Do your data ; bear this out? Can you explain any discrepancy you find? ; Let's define fast-prime procedure ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( expmod base exp m ) ( cond (( = exp 0 ) 1 ) (( even? exp ) ( remainder ( square ( expmod base ( / exp 2 ) m )) m )) ( else ( remainder ( * base ( expmod base ( - exp 1 ) m )) m )))) ( define ( fermat-test n ) ( define ( try-it a ) ( = ( expmod a n n ) a )) ( try-it ( + 1 ( random ( - n 1 ))))) ( define ( fast-prime? n times ) ( cond (( = times 0 ) true ) (( fermat-test n ) ( fast-prime? n ( - times 1 ))) ( else false ))) ( define ( prime? n ) ( fast-prime? n 500 )) ; Define `timed-prime-test` procedure ( define ( timed-prime-test n ) ( newline ) ( display n ) ( start-prime-test n ( runtime ))) ( define ( start-prime-test n start-time ) ( if ( prime? n ) ( report-prime ( - ( runtime ) start-time )))) ( define ( report-prime elapsed-time ) ( display \" *** \" ) ( display elapsed-time )) ; Test the timing on large prime numbers ( timed-prime-test 1000000007 ) ; .05000000000000002 ( timed-prime-test 1000000009 ) ; .03999999999999998 ( timed-prime-test 1000000021 ) ; .04000000000000001 ( timed-prime-test 10000000019 ) ; .06 ( timed-prime-test 10000000033 ) ; .04999999999999999 ( timed-prime-test 10000000061 ) ; .06 ( timed-prime-test 100000000003 ) ; .06 ( timed-prime-test 100000000019 ) ; .06000000000000005 ( timed-prime-test 100000000057 ) ; .06000000000000005 ( timed-prime-test 1000000000039 ) ; .06999999999999995 ( timed-prime-test 1000000000061 ) ; .06000000000000005 ; Test by doubling number of digits ( timed-prime-test 1000003 ) ; 3.9999999999999925e-2 ( timed-prime-test 1000000000063 ) ; .08000000000000007 ; i.e. ; 10^6 => 0.04 ; 10^12 => 0.08, which is a logarithmic scale","title":"1.24"},{"location":"SICP/ch1-abstraction-procedures/1.25/","text":"1.25 \u00b6 ; Alyssa P. Hacker complains that we went to a lot of ; extra work in writing expmod. After all, she says, ; since we already know how to compute exponentials, ; we could have simply written ; ( define ( expmod base exp m ) ( remainder ( fast-expt base exp ) m )) ; ; Is she correct? Would this procedure serve as well for ; our fast prime tester? Explain. ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( expmod-prev base exp m ) ( cond (( = exp 0 ) 1 ) (( even? exp ) ( remainder ( square ( expmod-prev base ( / exp 2 ) m )) m )) ( else ( remainder ( * base ( expmod-prev base ( - exp 1 ) m )) m )))) ( define ( fast-expt b n ) ( define ( even? n ) ( = ( remainder n 2 ) 0 )) ( cond (( = n 0 ) 1 ) (( even? n ) ( square ( fast-expt b ( / n 2 )))) ( else ( * b ( fast-expt b ( - n 1 )))))) ; Let's test whether both `expmod-prev` and `expmod` return ; correct result for some values ( expmod-prev 6 97 97 ) ;Value: 6 ( expmod 6 97 97 ) ;Value: 6 ( expmod-prev 103 1000003 1000003 ) ;Value: 103 ( expmod 103 1000003 1000003 ) ;Value: 103 ; We can also observe that the current `expmod` takes more ; time for large numbers, as it computes very large ; intermediate values","title":"1.25"},{"location":"SICP/ch1-abstraction-procedures/1.25/#125","text":"; Alyssa P. Hacker complains that we went to a lot of ; extra work in writing expmod. After all, she says, ; since we already know how to compute exponentials, ; we could have simply written ; ( define ( expmod base exp m ) ( remainder ( fast-expt base exp ) m )) ; ; Is she correct? Would this procedure serve as well for ; our fast prime tester? Explain. ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( expmod-prev base exp m ) ( cond (( = exp 0 ) 1 ) (( even? exp ) ( remainder ( square ( expmod-prev base ( / exp 2 ) m )) m )) ( else ( remainder ( * base ( expmod-prev base ( - exp 1 ) m )) m )))) ( define ( fast-expt b n ) ( define ( even? n ) ( = ( remainder n 2 ) 0 )) ( cond (( = n 0 ) 1 ) (( even? n ) ( square ( fast-expt b ( / n 2 )))) ( else ( * b ( fast-expt b ( - n 1 )))))) ; Let's test whether both `expmod-prev` and `expmod` return ; correct result for some values ( expmod-prev 6 97 97 ) ;Value: 6 ( expmod 6 97 97 ) ;Value: 6 ( expmod-prev 103 1000003 1000003 ) ;Value: 103 ( expmod 103 1000003 1000003 ) ;Value: 103 ; We can also observe that the current `expmod` takes more ; time for large numbers, as it computes very large ; intermediate values","title":"1.25"},{"location":"SICP/ch1-abstraction-procedures/1.26/","text":"1.26 \u00b6 ; Louis Reasoner is having great difficulty doing Exercise 1.24. ; His fast-prime? test seems to run more slowly than his prime? ; test. Louis calls his friend Eva Lu Ator over to help. When ; they examine Louis\u2019s code, they find that he has rewritten ; the expmod procedure to use an explicit multiplication, ; rather than calling square: ( define ( expmod base exp m ) ( cond (( = exp 0 ) 1 ) (( even? exp ) ( remainder ( * ( expmod base ( / exp 2 ) m ) ( expmod base ( / exp 2 ) m )) m )) ( else ( remainder ( * base ( expmod base ( - exp 1 ) m )) m )))) ; \u201cI don\u2019t see what difference that could make,\u201d says Louis. ; \u201cI do.\u201d says Eva. \u201cBy writing the procedure like that, you ; have transformed the \u0398(logn) process into a \u0398(n) process.\u201d ; Explain. ; ANSWER ; Explicit multiplication will compute (expmod ...) first, ; and square the result later ; But, in this case, (expmod ...) is computed twice and ; squared later. Morever, this becomes a tree-recursion with ; execution time is linear.","title":"1.26"},{"location":"SICP/ch1-abstraction-procedures/1.26/#126","text":"; Louis Reasoner is having great difficulty doing Exercise 1.24. ; His fast-prime? test seems to run more slowly than his prime? ; test. Louis calls his friend Eva Lu Ator over to help. When ; they examine Louis\u2019s code, they find that he has rewritten ; the expmod procedure to use an explicit multiplication, ; rather than calling square: ( define ( expmod base exp m ) ( cond (( = exp 0 ) 1 ) (( even? exp ) ( remainder ( * ( expmod base ( / exp 2 ) m ) ( expmod base ( / exp 2 ) m )) m )) ( else ( remainder ( * base ( expmod base ( - exp 1 ) m )) m )))) ; \u201cI don\u2019t see what difference that could make,\u201d says Louis. ; \u201cI do.\u201d says Eva. \u201cBy writing the procedure like that, you ; have transformed the \u0398(logn) process into a \u0398(n) process.\u201d ; Explain. ; ANSWER ; Explicit multiplication will compute (expmod ...) first, ; and square the result later ; But, in this case, (expmod ...) is computed twice and ; squared later. Morever, this becomes a tree-recursion with ; execution time is linear.","title":"1.26"},{"location":"SICP/ch1-abstraction-procedures/1.27/","text":"1.27 \u00b6 ; Demonstrate that the Carmichael numbers listed in ; Footnote 1.47 really do fool the Fermat test. That is, ; write a procedure that takes an integer n and tests ; whether an is congruent to a modulo n for every a < n, ; and try your procedure on the given Carmichael numbers. ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( expmod base exp m ) ( cond (( = exp 0 ) 1 ) (( even? exp ) ( remainder ( square ( expmod base ( / exp 2 ) m )) m )) ( else ( remainder ( * base ( expmod base ( - exp 1 ) m )) m )))) ( define ( fermat-test-all n ) ( define ( fermat-test-all-iter a ) ( if ( = a n ) #t ( if ( = ( expmod a n n ) a ) ( fermat-test-all-iter ( + a 1 )) #f ))) ( fermat-test-all-iter 1 ) ) ; Testing with actual prime numbers ( fermat-test-all 2 ) ;Value: #t ( fermat-test-all 17 ) ;Value: #t ; Testing with Carmichael numbers (should be false, but returns true) ( fermat-test-all 561 ) ( fermat-test-all 1105 ) ( fermat-test-all 1729 ) ( fermat-test-all 2465 ) ( fermat-test-all 2821 ) ( fermat-test-all 6601 )","title":"1.27"},{"location":"SICP/ch1-abstraction-procedures/1.27/#127","text":"; Demonstrate that the Carmichael numbers listed in ; Footnote 1.47 really do fool the Fermat test. That is, ; write a procedure that takes an integer n and tests ; whether an is congruent to a modulo n for every a < n, ; and try your procedure on the given Carmichael numbers. ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( expmod base exp m ) ( cond (( = exp 0 ) 1 ) (( even? exp ) ( remainder ( square ( expmod base ( / exp 2 ) m )) m )) ( else ( remainder ( * base ( expmod base ( - exp 1 ) m )) m )))) ( define ( fermat-test-all n ) ( define ( fermat-test-all-iter a ) ( if ( = a n ) #t ( if ( = ( expmod a n n ) a ) ( fermat-test-all-iter ( + a 1 )) #f ))) ( fermat-test-all-iter 1 ) ) ; Testing with actual prime numbers ( fermat-test-all 2 ) ;Value: #t ( fermat-test-all 17 ) ;Value: #t ; Testing with Carmichael numbers (should be false, but returns true) ( fermat-test-all 561 ) ( fermat-test-all 1105 ) ( fermat-test-all 1729 ) ( fermat-test-all 2465 ) ( fermat-test-all 2821 ) ( fermat-test-all 6601 )","title":"1.27"},{"location":"SICP/ch1-abstraction-procedures/1.28/","text":"1.28 \u00b6 ; One variant of the Fermat test that cannot be fooled ; is called the Miller-Rabin test (Miller 1976; Rabin 1980). ; This starts from an alternate form of Fermat\u2019s Little Theorem, ; which states that if n is a prime number and a is any positive ; integer less than n,then a raised to the (n\u22121)-st power is ; congruent to 1 modulo n. To test the primality of a number n by ; the Miller-Rabin test, we pick a random number a < n and raise a to ; the (n\u22121)-st power modulo n using the `expmod` procedure. However, ; whenever we perform the squaring step in expmod, we check to see ; if we have discovered a \u201cnontrivial square root of 1 modulo n,\u201d that ; is, a number not equal to 1 or n \u2212 1 whose square is equal to 1 modulo n. ; It is possible to prove that if such a nontrivial square root of 1 exists, ; then n is not prime. It is also possible to prove that if n is an odd ; number that is not prime, then, for at least half the numbers a < n, ; computing a^(n\u22121) in this way will reveal a nontrivial square root of 1 modulo n. ; This is why the Miller-Rabin test cannot be fooled.) Modify the expmod procedure ; to signal if it discovers a nontrivial square root of 1, and use this to ; implement the Miller-Rabin test with a procedure analogous to fermat-test. ; Check your procedure by testing various known primes and non-primes. ; Hint: One convenient way to make expmod signal is to have it return 0. ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( expmod base exp m ) ( cond (( = exp 0 ) 1 ) (( even? exp ) ( remainder ( square ( test-non-trivial ( expmod base ( / exp 2 ) m ) m )) m )) ( else ( remainder ( * base ( expmod base ( - exp 1 ) m )) m )))) ( define ( test-non-trivial x n ) ( cond (( and ( = ( remainder ( square x ) n ) 1 ) ( not ( = x 1 )) ( not ( = x ( - n 1 )))) 0 ) ( else x ))) ( define ( miller-rabin-test n ) ( define ( miller-rabin-test-iter a ) ( cond (( = a 0 ) #t ) (( check-num ( + 1 ( random ( - n 1 )))) ( miller-rabin-test-iter ( - a 1 ))) ( else #f ))) ( define ( check-num a ) ( = ( expmod a ( - n 1 ) n ) 1 )) ( miller-rabin-test-iter 100 ) ) ; Testing with actual prime numbers ( miller-rabin-test 2 ) ;Value: #t ( miller-rabin-test 17 ) ;Value: #t ( miller-rabin-test 19 ) ;Value: #t ; Testing with Carmichael numbers (should be false) ( miller-rabin-test 561 ) ( miller-rabin-test 1105 ) ( miller-rabin-test 1729 ) ( miller-rabin-test 2465 ) ( miller-rabin-test 2821 ) ( miller-rabin-test 6601 )","title":"1.28"},{"location":"SICP/ch1-abstraction-procedures/1.28/#128","text":"; One variant of the Fermat test that cannot be fooled ; is called the Miller-Rabin test (Miller 1976; Rabin 1980). ; This starts from an alternate form of Fermat\u2019s Little Theorem, ; which states that if n is a prime number and a is any positive ; integer less than n,then a raised to the (n\u22121)-st power is ; congruent to 1 modulo n. To test the primality of a number n by ; the Miller-Rabin test, we pick a random number a < n and raise a to ; the (n\u22121)-st power modulo n using the `expmod` procedure. However, ; whenever we perform the squaring step in expmod, we check to see ; if we have discovered a \u201cnontrivial square root of 1 modulo n,\u201d that ; is, a number not equal to 1 or n \u2212 1 whose square is equal to 1 modulo n. ; It is possible to prove that if such a nontrivial square root of 1 exists, ; then n is not prime. It is also possible to prove that if n is an odd ; number that is not prime, then, for at least half the numbers a < n, ; computing a^(n\u22121) in this way will reveal a nontrivial square root of 1 modulo n. ; This is why the Miller-Rabin test cannot be fooled.) Modify the expmod procedure ; to signal if it discovers a nontrivial square root of 1, and use this to ; implement the Miller-Rabin test with a procedure analogous to fermat-test. ; Check your procedure by testing various known primes and non-primes. ; Hint: One convenient way to make expmod signal is to have it return 0. ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( expmod base exp m ) ( cond (( = exp 0 ) 1 ) (( even? exp ) ( remainder ( square ( test-non-trivial ( expmod base ( / exp 2 ) m ) m )) m )) ( else ( remainder ( * base ( expmod base ( - exp 1 ) m )) m )))) ( define ( test-non-trivial x n ) ( cond (( and ( = ( remainder ( square x ) n ) 1 ) ( not ( = x 1 )) ( not ( = x ( - n 1 )))) 0 ) ( else x ))) ( define ( miller-rabin-test n ) ( define ( miller-rabin-test-iter a ) ( cond (( = a 0 ) #t ) (( check-num ( + 1 ( random ( - n 1 )))) ( miller-rabin-test-iter ( - a 1 ))) ( else #f ))) ( define ( check-num a ) ( = ( expmod a ( - n 1 ) n ) 1 )) ( miller-rabin-test-iter 100 ) ) ; Testing with actual prime numbers ( miller-rabin-test 2 ) ;Value: #t ( miller-rabin-test 17 ) ;Value: #t ( miller-rabin-test 19 ) ;Value: #t ; Testing with Carmichael numbers (should be false) ( miller-rabin-test 561 ) ( miller-rabin-test 1105 ) ( miller-rabin-test 1729 ) ( miller-rabin-test 2465 ) ( miller-rabin-test 2821 ) ( miller-rabin-test 6601 )","title":"1.28"},{"location":"SICP/ch1-abstraction-procedures/1.29/","text":"1.29 \u00b6 ; Simpson\u2019s Rule is a more accurate method of numerical ; integration than the method illustrated above. Using ; Simpson\u2019s Rule, the integral of a function f between a ; and b is approximated as ; (h/3)*(y0 +4y1 +2y2 +4y3 +2y4 +\u00b7\u00b7\u00b7+2yn\u22122 +4yn\u22121 +yn) ; where h = (b \u2212 a)/n, for some even integer n, and ; yk = f (a + kh). (Increasing n increases the accuracy ; of the approximation.) Define a procedure that takes ; as arguments f, a, b, and n and returns the value of ; the integral, computed using Simpson\u2019s Rule. Use your ; procedure to integrate cube between 0 and 1 ; (with n = 100 and n = 1000), and compare the results ; to those of the integral procedure shown above. ( define ( integral f a b n ) ( define ( coefficient k ) ( cond (( or ( = k 0 ) ( = k n )) 1 ) (( even? k ) 2 ) ( else 4 ))) ( define h ( / ( - b a ) n )) ( define ( y-of-k k ) ( f ( + a ( * k h )))) ( define ( iter k sum ) ( cond (( = k -1 ) sum ) ( else ( iter ( - k 1 ) ( + sum ( * ( coefficient k ) ( y-of-k k ))))) ) ) ( * ( / h 3 ) ( iter n 0 )) ) ( define ( cube x ) ( * x x x )) ( integral cube 0 1 100 ) ;Value: .24999999999999992 ( integral cube 0 1 1000 ) ;Value: .2500000000000003","title":"1.29"},{"location":"SICP/ch1-abstraction-procedures/1.29/#129","text":"; Simpson\u2019s Rule is a more accurate method of numerical ; integration than the method illustrated above. Using ; Simpson\u2019s Rule, the integral of a function f between a ; and b is approximated as ; (h/3)*(y0 +4y1 +2y2 +4y3 +2y4 +\u00b7\u00b7\u00b7+2yn\u22122 +4yn\u22121 +yn) ; where h = (b \u2212 a)/n, for some even integer n, and ; yk = f (a + kh). (Increasing n increases the accuracy ; of the approximation.) Define a procedure that takes ; as arguments f, a, b, and n and returns the value of ; the integral, computed using Simpson\u2019s Rule. Use your ; procedure to integrate cube between 0 and 1 ; (with n = 100 and n = 1000), and compare the results ; to those of the integral procedure shown above. ( define ( integral f a b n ) ( define ( coefficient k ) ( cond (( or ( = k 0 ) ( = k n )) 1 ) (( even? k ) 2 ) ( else 4 ))) ( define h ( / ( - b a ) n )) ( define ( y-of-k k ) ( f ( + a ( * k h )))) ( define ( iter k sum ) ( cond (( = k -1 ) sum ) ( else ( iter ( - k 1 ) ( + sum ( * ( coefficient k ) ( y-of-k k ))))) ) ) ( * ( / h 3 ) ( iter n 0 )) ) ( define ( cube x ) ( * x x x )) ( integral cube 0 1 100 ) ;Value: .24999999999999992 ( integral cube 0 1 1000 ) ;Value: .2500000000000003","title":"1.29"},{"location":"SICP/ch1-abstraction-procedures/1.30/","text":"1.30 \u00b6 ; The sum procedure above generates a linear recursion. ; The procedure can be rewritten so that the sum is ; performed iteratively. Show how to do this by filling ; in the missing expressions in the following definition: ; ; (define (sum term a next b) ; (define (iter a result) ; (if \u27e8??\u27e9 ; \u27e8??\u27e9 ; (iter \u27e8??\u27e9 \u27e8??\u27e9))) ; (iter \u27e8??\u27e9 \u27e8??\u27e9)) ( define ( sum term a next b ) ( define ( iter a result ) ( if ( > a b ) result ( iter ( next a ) ( + result ( term a ))))) ( iter a 0 )) ( define ( pi-sum a b ) ( define ( pi-term x ) ( / 1.0 ( * x ( + x 2 )))) ( define ( pi-next x ) ( + x 4 )) ( sum pi-term a pi-next b )) ( * 8 ( pi-sum 1 1000 )) ;Value: 3.139592655589782","title":"1.30"},{"location":"SICP/ch1-abstraction-procedures/1.30/#130","text":"; The sum procedure above generates a linear recursion. ; The procedure can be rewritten so that the sum is ; performed iteratively. Show how to do this by filling ; in the missing expressions in the following definition: ; ; (define (sum term a next b) ; (define (iter a result) ; (if \u27e8??\u27e9 ; \u27e8??\u27e9 ; (iter \u27e8??\u27e9 \u27e8??\u27e9))) ; (iter \u27e8??\u27e9 \u27e8??\u27e9)) ( define ( sum term a next b ) ( define ( iter a result ) ( if ( > a b ) result ( iter ( next a ) ( + result ( term a ))))) ( iter a 0 )) ( define ( pi-sum a b ) ( define ( pi-term x ) ( / 1.0 ( * x ( + x 2 )))) ( define ( pi-next x ) ( + x 4 )) ( sum pi-term a pi-next b )) ( * 8 ( pi-sum 1 1000 )) ;Value: 3.139592655589782","title":"1.30"},{"location":"SICP/ch1-abstraction-procedures/1.31.a/","text":"1.31.a \u00b6 ; The `sum` procedure is only the simplest of a vast ; number of similar abstractions that can be captured ; as higher-order procedures. Write an analogous procedure ; called `product` that returns the product of the values ; of a function at points over a given range. Show how to ; define `factorial` in terms of `product`. Also use `product` ; to compute approximations to \u03c0 using the formula ; \u03c0/4 = (2/3)(4/3)(4/5)(6/5)(6/7)(8/7) ( define ( product term a next b ) ( if ( > a b ) 1 ( * ( term a ) ( product term ( next a ) next b )))) ; Define `factorial` ( define ( factorial n ) ( define ( f x ) x ) ( define ( next x ) ( + x 1 )) ( product f 1 next n )) ( factorial 0 ) ;Value: 1 ( factorial 1 ) ;Value: 1 ( factorial 2 ) ;Value: 2 ( factorial 5 ) ;Value: 120 ( define ( pi-term n ) ( cond (( even? n ) ( / ( + n 2 ) ( + n 1 ))) ( else ( / ( + n 1 ) ( + n 2 ))))) ( define ( pi-sum n ) ( define ( next x ) ( + x 1 )) ( product pi-term 1 next n ) ) ( * ( pi-sum 10 ) 4.0 ) ;Value: 3.2751010413348074 ( * ( pi-sum 1000 ) 4.0 ) ;Value: 3.1431607055322663","title":"1.31.a"},{"location":"SICP/ch1-abstraction-procedures/1.31.a/#131a","text":"; The `sum` procedure is only the simplest of a vast ; number of similar abstractions that can be captured ; as higher-order procedures. Write an analogous procedure ; called `product` that returns the product of the values ; of a function at points over a given range. Show how to ; define `factorial` in terms of `product`. Also use `product` ; to compute approximations to \u03c0 using the formula ; \u03c0/4 = (2/3)(4/3)(4/5)(6/5)(6/7)(8/7) ( define ( product term a next b ) ( if ( > a b ) 1 ( * ( term a ) ( product term ( next a ) next b )))) ; Define `factorial` ( define ( factorial n ) ( define ( f x ) x ) ( define ( next x ) ( + x 1 )) ( product f 1 next n )) ( factorial 0 ) ;Value: 1 ( factorial 1 ) ;Value: 1 ( factorial 2 ) ;Value: 2 ( factorial 5 ) ;Value: 120 ( define ( pi-term n ) ( cond (( even? n ) ( / ( + n 2 ) ( + n 1 ))) ( else ( / ( + n 1 ) ( + n 2 ))))) ( define ( pi-sum n ) ( define ( next x ) ( + x 1 )) ( product pi-term 1 next n ) ) ( * ( pi-sum 10 ) 4.0 ) ;Value: 3.2751010413348074 ( * ( pi-sum 1000 ) 4.0 ) ;Value: 3.1431607055322663","title":"1.31.a"},{"location":"SICP/ch1-abstraction-procedures/1.31.b/","text":"1.31.b \u00b6 ; If your `product` procedure generates a recursive ; process, write one that generates an iterative process. ; If it generates an iterative process, write one that ; generates a recursive process. ; Iterative version of `product` ( define ( product term a next b ) ( define ( iter a result ) ( if ( > a b ) result ( iter ( next a ) ( * result ( term a ))))) ( iter a 1 ) ) ( define ( factorial n ) ( define ( f x ) x ) ( define ( next x ) ( + x 1 )) ( product f 1 next n )) ( factorial 0 ) ;Value: 1 ( factorial 1 ) ;Value: 1 ( factorial 2 ) ;Value: 2 ( factorial 5 ) ;Value: 120","title":"1.31.b"},{"location":"SICP/ch1-abstraction-procedures/1.31.b/#131b","text":"; If your `product` procedure generates a recursive ; process, write one that generates an iterative process. ; If it generates an iterative process, write one that ; generates a recursive process. ; Iterative version of `product` ( define ( product term a next b ) ( define ( iter a result ) ( if ( > a b ) result ( iter ( next a ) ( * result ( term a ))))) ( iter a 1 ) ) ( define ( factorial n ) ( define ( f x ) x ) ( define ( next x ) ( + x 1 )) ( product f 1 next n )) ( factorial 0 ) ;Value: 1 ( factorial 1 ) ;Value: 1 ( factorial 2 ) ;Value: 2 ( factorial 5 ) ;Value: 120","title":"1.31.b"},{"location":"SICP/ch1-abstraction-procedures/1.32.a/","text":"1.32.a \u00b6 ; Show that `sum` and `product` (Exercise 1.31) are both ; special cases of a still more general notion called ; `accumulate` that combines a collection of terms, ; using some general accumulation function ; \"\"\"\"\"\"\"\"\"\"\"\"\"\" ; (accumulate combiner null-value term a next b) ; \"\"\"\"\"\"\"\"\"\"\"\"\"\" ; accumulate takes as arguments the same term and range ; specifications as `sum` and `product`, together with ; a `combiner` procedure (of two arguments) that specifies ; how the current term is to be combined with the accumulation ; of the preceding terms and a `null-value` that specifies what ; base value to use when the terms run out. Write accumulate ; and show how `sum` and `product` can both be defined as ; simple calls to `accumulate`. ( define ( accumulate combiner null-value term a next b ) ( if ( > a b ) null-value ( combiner ( term a ) ( accumulate combiner null-value term ( next a ) next b )))) ( define ( product term a next b ) ( accumulate * 1 term a next b )) ( define ( sum term a next b ) ( accumulate + 0 term a next b )) ; Verify `product` by factorial ( define ( factorial n ) ( define ( f x ) x ) ( define ( next x ) ( + x 1 )) ( product f 1 next n )) ( factorial 0 ) ;Value: 1 ( factorial 1 ) ;Value: 1 ( factorial 2 ) ;Value: 2 ( factorial 5 ) ;Value: 120 ; Verify `sum` by `pi-sum` ( define ( pi-sum a b ) ( define ( pi-term x ) ( / 1.0 ( * x ( + x 2 )))) ( define ( pi-next x ) ( + x 4 )) ( sum pi-term a pi-next b )) ( * 8 ( pi-sum 1 1000 )) ;Value: 3.139592655589783","title":"1.32.a"},{"location":"SICP/ch1-abstraction-procedures/1.32.a/#132a","text":"; Show that `sum` and `product` (Exercise 1.31) are both ; special cases of a still more general notion called ; `accumulate` that combines a collection of terms, ; using some general accumulation function ; \"\"\"\"\"\"\"\"\"\"\"\"\"\" ; (accumulate combiner null-value term a next b) ; \"\"\"\"\"\"\"\"\"\"\"\"\"\" ; accumulate takes as arguments the same term and range ; specifications as `sum` and `product`, together with ; a `combiner` procedure (of two arguments) that specifies ; how the current term is to be combined with the accumulation ; of the preceding terms and a `null-value` that specifies what ; base value to use when the terms run out. Write accumulate ; and show how `sum` and `product` can both be defined as ; simple calls to `accumulate`. ( define ( accumulate combiner null-value term a next b ) ( if ( > a b ) null-value ( combiner ( term a ) ( accumulate combiner null-value term ( next a ) next b )))) ( define ( product term a next b ) ( accumulate * 1 term a next b )) ( define ( sum term a next b ) ( accumulate + 0 term a next b )) ; Verify `product` by factorial ( define ( factorial n ) ( define ( f x ) x ) ( define ( next x ) ( + x 1 )) ( product f 1 next n )) ( factorial 0 ) ;Value: 1 ( factorial 1 ) ;Value: 1 ( factorial 2 ) ;Value: 2 ( factorial 5 ) ;Value: 120 ; Verify `sum` by `pi-sum` ( define ( pi-sum a b ) ( define ( pi-term x ) ( / 1.0 ( * x ( + x 2 )))) ( define ( pi-next x ) ( + x 4 )) ( sum pi-term a pi-next b )) ( * 8 ( pi-sum 1 1000 )) ;Value: 3.139592655589783","title":"1.32.a"},{"location":"SICP/ch1-abstraction-procedures/1.32.b/","text":"1.32.b \u00b6 ; If your accumulate procedure generates a recursive process, ; write one that generates an iterative process. If it ; generates an iterative process, write one that generates ; a recursive process ; Iterative `accumulate` ( define ( accumulate combiner null-value term a next b ) ( define ( iter a result ) ( if ( > a b ) result ( iter ( next a ) ( combiner result ( term a )))) ) ( iter a null-value )) ( define ( product term a next b ) ( accumulate * 1 term a next b )) ( define ( sum term a next b ) ( accumulate + 0 term a next b )) ; Verify `product` by factorial ( define ( factorial n ) ( define ( f x ) x ) ( define ( next x ) ( + x 1 )) ( product f 1 next n )) ( factorial 0 ) ;Value: 1 ( factorial 1 ) ;Value: 1 ( factorial 2 ) ;Value: 2 ( factorial 5 ) ;Value: 120 ; Verify `sum` by `pi-sum` ( define ( pi-sum a b ) ( define ( pi-term x ) ( / 1.0 ( * x ( + x 2 )))) ( define ( pi-next x ) ( + x 4 )) ( sum pi-term a pi-next b )) ( * 8 ( pi-sum 1 1000 )) ;Value: 3.139592655589783","title":"1.32.b"},{"location":"SICP/ch1-abstraction-procedures/1.32.b/#132b","text":"; If your accumulate procedure generates a recursive process, ; write one that generates an iterative process. If it ; generates an iterative process, write one that generates ; a recursive process ; Iterative `accumulate` ( define ( accumulate combiner null-value term a next b ) ( define ( iter a result ) ( if ( > a b ) result ( iter ( next a ) ( combiner result ( term a )))) ) ( iter a null-value )) ( define ( product term a next b ) ( accumulate * 1 term a next b )) ( define ( sum term a next b ) ( accumulate + 0 term a next b )) ; Verify `product` by factorial ( define ( factorial n ) ( define ( f x ) x ) ( define ( next x ) ( + x 1 )) ( product f 1 next n )) ( factorial 0 ) ;Value: 1 ( factorial 1 ) ;Value: 1 ( factorial 2 ) ;Value: 2 ( factorial 5 ) ;Value: 120 ; Verify `sum` by `pi-sum` ( define ( pi-sum a b ) ( define ( pi-term x ) ( / 1.0 ( * x ( + x 2 )))) ( define ( pi-next x ) ( + x 4 )) ( sum pi-term a pi-next b )) ( * 8 ( pi-sum 1 1000 )) ;Value: 3.139592655589783","title":"1.32.b"},{"location":"SICP/ch1-abstraction-procedures/1.33/","text":"1.33 \u00b6 ; You can obtain an even more general version of ; accumulate (Exercise 1.32) by introducing the notion ; of a filter on the terms to be combined. That is, ; combine only those terms derived from values in the ; range that satisfy a specified condition. The resulting ; `filtered-accumulate` abstraction takes the same ; arguments as `accumulate`, together with an additional ; predicate of one argument that specifies the filter. ; Write `filtered-accumulate` as a procedure. Show how ; to express the following using filtered-accumulate: ; (a) the sum of the squares of the prime numbers in the ; interval a to b (assuming that you have a prime? ; predicate already written) ; (b) the product of all the positive integers less than n ; are relatively prime to n (i.e., all positive integers ; i < n such that GCD(i,n) = 1). ; ----------------------------------- ; Answer ; ----------------------------------- ; Let's define `filtered-accumulate` function ( define ( filtered-accumulate combiner null-value filter term a next b ) ( if ( > a b ) null-value ( if ( filter a ) ( combiner ( term a ) ( filtered-accumulate combiner null-value filter term ( next a ) next b )) ( combiner null-value ( filtered-accumulate combiner null-value filter term ( next a ) next b ))))) ; (a) Let's test with `prime?` procedure ( define ( prime? n ) ( define ( divides? a b ) ( = ( remainder b a ) 0 )) ( define ( smallest-divisor n ) ( find-divisor n 2 )) ( define ( find-divisor n test-divisor ) ( cond (( > ( square test-divisor ) n ) n ) (( divides? test-divisor n ) test-divisor ) ( else ( find-divisor n ( + test-divisor 1 ))))) ( if ( = n 1 ) #f ( = n ( smallest-divisor n ))) ) ( define ( inc x ) ( + x 1 )) ( define ( sum-of-squares-prime a b ) ( filtered-accumulate + 0 prime? square a inc b )) ( sum-of-squares-prime 1 10 ) ;Value: 87 (2^2 + 3^2 + 5^2 + 7^2) ; (b) Define `relatively-prime?` filter ( define ( gcd a b ) ( cond (( < a b ) ( gcd b a )) (( = b 0 ) a ) ( else ( gcd b ( remainder a b ))))) ( define ( relatively-prime? a b ) ( = ( gcd a b ) 1 )) ( define ( product-of-relative-prime-nums n ) ( define ( filter x ) ( relatively-prime? x n )) ( define ( f x ) x ) ( filtered-accumulate * 1 filter f 1 inc n ) ) ( product-of-relative-prime-nums 10 ) ;Value: 189","title":"1.33"},{"location":"SICP/ch1-abstraction-procedures/1.33/#133","text":"; You can obtain an even more general version of ; accumulate (Exercise 1.32) by introducing the notion ; of a filter on the terms to be combined. That is, ; combine only those terms derived from values in the ; range that satisfy a specified condition. The resulting ; `filtered-accumulate` abstraction takes the same ; arguments as `accumulate`, together with an additional ; predicate of one argument that specifies the filter. ; Write `filtered-accumulate` as a procedure. Show how ; to express the following using filtered-accumulate: ; (a) the sum of the squares of the prime numbers in the ; interval a to b (assuming that you have a prime? ; predicate already written) ; (b) the product of all the positive integers less than n ; are relatively prime to n (i.e., all positive integers ; i < n such that GCD(i,n) = 1). ; ----------------------------------- ; Answer ; ----------------------------------- ; Let's define `filtered-accumulate` function ( define ( filtered-accumulate combiner null-value filter term a next b ) ( if ( > a b ) null-value ( if ( filter a ) ( combiner ( term a ) ( filtered-accumulate combiner null-value filter term ( next a ) next b )) ( combiner null-value ( filtered-accumulate combiner null-value filter term ( next a ) next b ))))) ; (a) Let's test with `prime?` procedure ( define ( prime? n ) ( define ( divides? a b ) ( = ( remainder b a ) 0 )) ( define ( smallest-divisor n ) ( find-divisor n 2 )) ( define ( find-divisor n test-divisor ) ( cond (( > ( square test-divisor ) n ) n ) (( divides? test-divisor n ) test-divisor ) ( else ( find-divisor n ( + test-divisor 1 ))))) ( if ( = n 1 ) #f ( = n ( smallest-divisor n ))) ) ( define ( inc x ) ( + x 1 )) ( define ( sum-of-squares-prime a b ) ( filtered-accumulate + 0 prime? square a inc b )) ( sum-of-squares-prime 1 10 ) ;Value: 87 (2^2 + 3^2 + 5^2 + 7^2) ; (b) Define `relatively-prime?` filter ( define ( gcd a b ) ( cond (( < a b ) ( gcd b a )) (( = b 0 ) a ) ( else ( gcd b ( remainder a b ))))) ( define ( relatively-prime? a b ) ( = ( gcd a b ) 1 )) ( define ( product-of-relative-prime-nums n ) ( define ( filter x ) ( relatively-prime? x n )) ( define ( f x ) x ) ( filtered-accumulate * 1 filter f 1 inc n ) ) ( product-of-relative-prime-nums 10 ) ;Value: 189","title":"1.33"},{"location":"SICP/ch1-abstraction-procedures/1.34/","text":"1.34 \u00b6 ; Suppose we define the procedure ( define ( f g ) ( g 2 )) ; Then we have ( f square ) ;Value: 4 ( f ( lambda ( z ) ( * z ( + z 1 )))) ;Value: 6 ; What happens if we (perversely) ask the interpreter ; to evaluate the combination (f f)? Explain ; Answer ; ------------------ ; Evaluation of (f f) will give the following error ; \"The object 2 is not applicable.\" ; ; This is because, it will be evaluated to (f 2) => (2 2) ; Hence, interpreter will throw the error","title":"1.34"},{"location":"SICP/ch1-abstraction-procedures/1.34/#134","text":"; Suppose we define the procedure ( define ( f g ) ( g 2 )) ; Then we have ( f square ) ;Value: 4 ( f ( lambda ( z ) ( * z ( + z 1 )))) ;Value: 6 ; What happens if we (perversely) ask the interpreter ; to evaluate the combination (f f)? Explain ; Answer ; ------------------ ; Evaluation of (f f) will give the following error ; \"The object 2 is not applicable.\" ; ; This is because, it will be evaluated to (f 2) => (2 2) ; Hence, interpreter will throw the error","title":"1.34"},{"location":"SICP/ch1-abstraction-procedures/1.35/","text":"1.35 \u00b6 ; Show that the golden ratio \u03c6 (Section 1.2.2) is a ; fixed point of the transformation x \udbff\udc15\u2192 1 + 1/x, and ; use this fact to compute \u03c6 by means of the fixed-point ; procedure. ( define tolerance 0.00001 ) ( define ( fixed-point f first-guess ) ( define ( close-enough? v1 v2 ) ( < ( abs ( - v1 v2 )) tolerance )) ( define ( try guess ) ( let (( next ( f guess ))) ( if ( close-enough? guess next ) next ( try next )))) ( try first-guess )) ( fixed-point ( lambda ( x ) ( + 1 ( / 1 x ))) 1.0 ) ;Value: 1.6180327868852458 ; The result is close, as we know \u03c6=1.61803398875","title":"1.35"},{"location":"SICP/ch1-abstraction-procedures/1.35/#135","text":"; Show that the golden ratio \u03c6 (Section 1.2.2) is a ; fixed point of the transformation x \udbff\udc15\u2192 1 + 1/x, and ; use this fact to compute \u03c6 by means of the fixed-point ; procedure. ( define tolerance 0.00001 ) ( define ( fixed-point f first-guess ) ( define ( close-enough? v1 v2 ) ( < ( abs ( - v1 v2 )) tolerance )) ( define ( try guess ) ( let (( next ( f guess ))) ( if ( close-enough? guess next ) next ( try next )))) ( try first-guess )) ( fixed-point ( lambda ( x ) ( + 1 ( / 1 x ))) 1.0 ) ;Value: 1.6180327868852458 ; The result is close, as we know \u03c6=1.61803398875","title":"1.35"},{"location":"SICP/ch1-abstraction-procedures/1.36/","text":"1.36 \u00b6 ; Modify `fixed-point` so that it prints the sequence ; of approximations it generates, using the newline and ; display primitives shown in Exercise 1.22. Then find ; a solution to x^x = 1000 by finding a fixed point of ; x \udbff\udc15\u2192 log(1000)/ log(x). (Use Scheme\u2019s primitive log ; procedure, which computes natural logarithms.) Compare ; the number of steps this takes with and without average ; damping. (Note that you cannot start fixed-point with ; a guess of 1, as this would cause division by log(1) = 0.) ; Answer ; ------------------------- ; (i) Modified `fixed-point` procedure ( define tolerance 0.00001 ) ( define ( average a b ) ( / ( + a b ) 2 )) ( define ( fixed-point f first-guess ) ( define ( close-enough? v1 v2 ) ( < ( abs ( - v1 v2 )) tolerance )) ( define ( try guess ) ( newline ) ( display \"Guess: \" ) ( display guess ) ( let (( next ( f guess ))) ( if ( close-enough? guess next ) next ( try next )))) ( try first-guess )) ; (ii) Solution to x^x = 1000 (without avg) ( fixed-point ( lambda ( x ) ( / ( log 1000 ) ( log x ))) 2.5 ) ;Value: 4.555539169119903 ; (iii) Solution to x^x = 1000 (with avg) ( fixed-point ( lambda ( x ) ( average x ( / ( log 1000 ) ( log x )))) 2.5 ) ; Comparison ; ----------------- ; Without average => 33 steps ; With average => 9 steps","title":"1.36"},{"location":"SICP/ch1-abstraction-procedures/1.36/#136","text":"; Modify `fixed-point` so that it prints the sequence ; of approximations it generates, using the newline and ; display primitives shown in Exercise 1.22. Then find ; a solution to x^x = 1000 by finding a fixed point of ; x \udbff\udc15\u2192 log(1000)/ log(x). (Use Scheme\u2019s primitive log ; procedure, which computes natural logarithms.) Compare ; the number of steps this takes with and without average ; damping. (Note that you cannot start fixed-point with ; a guess of 1, as this would cause division by log(1) = 0.) ; Answer ; ------------------------- ; (i) Modified `fixed-point` procedure ( define tolerance 0.00001 ) ( define ( average a b ) ( / ( + a b ) 2 )) ( define ( fixed-point f first-guess ) ( define ( close-enough? v1 v2 ) ( < ( abs ( - v1 v2 )) tolerance )) ( define ( try guess ) ( newline ) ( display \"Guess: \" ) ( display guess ) ( let (( next ( f guess ))) ( if ( close-enough? guess next ) next ( try next )))) ( try first-guess )) ; (ii) Solution to x^x = 1000 (without avg) ( fixed-point ( lambda ( x ) ( / ( log 1000 ) ( log x ))) 2.5 ) ;Value: 4.555539169119903 ; (iii) Solution to x^x = 1000 (with avg) ( fixed-point ( lambda ( x ) ( average x ( / ( log 1000 ) ( log x )))) 2.5 ) ; Comparison ; ----------------- ; Without average => 33 steps ; With average => 9 steps","title":"1.36"},{"location":"SICP/ch1-abstraction-procedures/1.37.a/","text":"1.37.a \u00b6 ; An infinite continued fraction is an expression of the form ; f = N1 ; ----------------- ; D1 + N2 ; ------------- ; D2 + N3 ; -------- ; D3 + ... ; As an example, one can show that the infinite continued ; fraction expansion with the Ni and the Di all equal to 1 produces ; 1/\u03c6, where \u03c6 is the golden ratio (described in Section 1.2.2). ; One way to approximate an infinite continued fraction is to ; truncate the expansion after a given number of terms. Such a ; truncation \u2014 a so-called k-term finite continued fraction \u2014 has the form ; N1 ; --------------- ; D1 + N2 ; --------- ; ... + Nk/Dk ; ; Suppose that n and d are procedures of one argument (the term index i) ; that return the Ni and Di of the terms of the continued fraction. ; Define a procedure cont-frac such that evaluating (cont-frac n d k) ; computes the value of the k-term finite continued fraction. Check ; your procedure by approximating 1/\u03c6 usng ; (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) k) ; for successive values of k. How large must you make k in order to get ; an approximation that is accurate to 4 decimal places? ( define ( cont-frac n d k ) ( if ( = k 0 ) 0 ( / ( n 1 ) ( + ( d 1 ) ( cont-frac ( lambda ( x ) ( n ( + x 1 ))) ( lambda ( x ) ( n ( + x 1 ))) ( - k 1 )))))) ; 1/\u03c6 = 0.6180339887 ; At around k = 12, we get value accurate to 4 decimal placess ( cont-frac ( lambda ( i ) 1.0 ) ( lambda ( i ) 1.0 ) 12 ) ; Value: .6180257510729613","title":"1.37.a"},{"location":"SICP/ch1-abstraction-procedures/1.37.a/#137a","text":"; An infinite continued fraction is an expression of the form ; f = N1 ; ----------------- ; D1 + N2 ; ------------- ; D2 + N3 ; -------- ; D3 + ... ; As an example, one can show that the infinite continued ; fraction expansion with the Ni and the Di all equal to 1 produces ; 1/\u03c6, where \u03c6 is the golden ratio (described in Section 1.2.2). ; One way to approximate an infinite continued fraction is to ; truncate the expansion after a given number of terms. Such a ; truncation \u2014 a so-called k-term finite continued fraction \u2014 has the form ; N1 ; --------------- ; D1 + N2 ; --------- ; ... + Nk/Dk ; ; Suppose that n and d are procedures of one argument (the term index i) ; that return the Ni and Di of the terms of the continued fraction. ; Define a procedure cont-frac such that evaluating (cont-frac n d k) ; computes the value of the k-term finite continued fraction. Check ; your procedure by approximating 1/\u03c6 usng ; (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) k) ; for successive values of k. How large must you make k in order to get ; an approximation that is accurate to 4 decimal places? ( define ( cont-frac n d k ) ( if ( = k 0 ) 0 ( / ( n 1 ) ( + ( d 1 ) ( cont-frac ( lambda ( x ) ( n ( + x 1 ))) ( lambda ( x ) ( n ( + x 1 ))) ( - k 1 )))))) ; 1/\u03c6 = 0.6180339887 ; At around k = 12, we get value accurate to 4 decimal placess ( cont-frac ( lambda ( i ) 1.0 ) ( lambda ( i ) 1.0 ) 12 ) ; Value: .6180257510729613","title":"1.37.a"},{"location":"SICP/ch1-abstraction-procedures/1.37.b/","text":"1.37.b \u00b6 ; If your cont-frac procedure generates a recursive process, ; write one that generates an iterative process. If it ; generates an iterative process, write one that generates ; a recursive process ; Iterative version of `cont-frac` ( define ( cont-frac-iter n d k ) ( define ( iter k res ) ( if ( = k 0 ) res ( iter ( - k 1 ) ( / ( n k ) ( + ( d k ) res ))))) ( iter k 0 )) ; Testing ( cont-frac-iter ( lambda ( i ) 1.0 ) ( lambda ( i ) 1.0 ) 100 ) ;Value: .6180339887498948","title":"1.37.b"},{"location":"SICP/ch1-abstraction-procedures/1.37.b/#137b","text":"; If your cont-frac procedure generates a recursive process, ; write one that generates an iterative process. If it ; generates an iterative process, write one that generates ; a recursive process ; Iterative version of `cont-frac` ( define ( cont-frac-iter n d k ) ( define ( iter k res ) ( if ( = k 0 ) res ( iter ( - k 1 ) ( / ( n k ) ( + ( d k ) res ))))) ( iter k 0 )) ; Testing ( cont-frac-iter ( lambda ( i ) 1.0 ) ( lambda ( i ) 1.0 ) 100 ) ;Value: .6180339887498948","title":"1.37.b"},{"location":"SICP/ch1-abstraction-procedures/1.38/","text":"1.38 \u00b6 ; In 1737, the Swiss mathematician Leonhard Euler published ; a memoir De Fractionibus Continuis, which included a ; continued fraction expansion for e\u22122, where e is the base ; of the natural logarithms. In this fraction, the Ni are all 1, ; and the Di are successively 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, . . .. ; Write a program that uses your cont-frac procedure from ; Exercise 1.37 to approximate e, based on Euler\u2019s expansion ; To calculate Di, we can observe 2,5,8..th terms are 2,4,6,8... ; i.e. if remainder(i/3) = 2 -> Di = 3(i + 1)/2, else Di = 1 ( define ( cont-frac n d k ) ( define ( iter k res ) ( if ( = k 0 ) res ( iter ( - k 1 ) ( / ( n k ) ( + ( d k ) res ))))) ( iter k 0 )) ( + ( cont-frac ( lambda ( x ) 1 ) ( lambda ( x ) ( if ( = ( remainder x 3 ) 2 ) ( / ( + x 1 ) 1.5 ) 1 )) 200 ) 2 ) ;Value: 2.7182818284590455","title":"1.38"},{"location":"SICP/ch1-abstraction-procedures/1.38/#138","text":"; In 1737, the Swiss mathematician Leonhard Euler published ; a memoir De Fractionibus Continuis, which included a ; continued fraction expansion for e\u22122, where e is the base ; of the natural logarithms. In this fraction, the Ni are all 1, ; and the Di are successively 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, . . .. ; Write a program that uses your cont-frac procedure from ; Exercise 1.37 to approximate e, based on Euler\u2019s expansion ; To calculate Di, we can observe 2,5,8..th terms are 2,4,6,8... ; i.e. if remainder(i/3) = 2 -> Di = 3(i + 1)/2, else Di = 1 ( define ( cont-frac n d k ) ( define ( iter k res ) ( if ( = k 0 ) res ( iter ( - k 1 ) ( / ( n k ) ( + ( d k ) res ))))) ( iter k 0 )) ( + ( cont-frac ( lambda ( x ) 1 ) ( lambda ( x ) ( if ( = ( remainder x 3 ) 2 ) ( / ( + x 1 ) 1.5 ) 1 )) 200 ) 2 ) ;Value: 2.7182818284590455","title":"1.38"},{"location":"SICP/ch1-abstraction-procedures/1.39/","text":"1.39 \u00b6 ; A continued fraction representation of the tangent ; function was published in 1770 by the German mathematician ; J.H. Lambert: ; tan x = x ; -------------- ; 1 - x^2 ; ---------- ; 3 - x^2 ; ------- ; 5 - ... ; where x is in radians. Define a procedure (tan-cf x k) ; that computes an approximation to the tangent function ; based on Lambert\u2019s formula. k specifies the number of terms ; to compute, as in Exercise 1.37. ( define ( cont-frac n d k ) ( define ( iter k res ) ( if ( = k 0 ) res ( iter ( - k 1 ) ( / ( n k ) ( + ( d k ) res ))))) ( iter k 0 )) ( define ( tan-cf x k ) ( cont-frac ( lambda ( i ) ( if ( = i 1 ) x ( - ( square x )))) ( lambda ( i ) ( - ( * 2 i ) 1 )) k )) ( tan-cf 0.7853981634 20 ) ;Value: 1.0000000000051033 (tan(45 deg) = 1)","title":"1.39"},{"location":"SICP/ch1-abstraction-procedures/1.39/#139","text":"; A continued fraction representation of the tangent ; function was published in 1770 by the German mathematician ; J.H. Lambert: ; tan x = x ; -------------- ; 1 - x^2 ; ---------- ; 3 - x^2 ; ------- ; 5 - ... ; where x is in radians. Define a procedure (tan-cf x k) ; that computes an approximation to the tangent function ; based on Lambert\u2019s formula. k specifies the number of terms ; to compute, as in Exercise 1.37. ( define ( cont-frac n d k ) ( define ( iter k res ) ( if ( = k 0 ) res ( iter ( - k 1 ) ( / ( n k ) ( + ( d k ) res ))))) ( iter k 0 )) ( define ( tan-cf x k ) ( cont-frac ( lambda ( i ) ( if ( = i 1 ) x ( - ( square x )))) ( lambda ( i ) ( - ( * 2 i ) 1 )) k )) ( tan-cf 0.7853981634 20 ) ;Value: 1.0000000000051033 (tan(45 deg) = 1)","title":"1.39"},{"location":"SICP/ch1-abstraction-procedures/1.40/","text":"1.40 \u00b6 ; Define a procedure cubic that can be used together with the ; `newtons-method` procedure in expressions of the form ; (newtons-method (cubic a b c) 1) ; to approximate zeros of the cubic x3 + ax2 + bx + c. ( define ( cube x ) ( * x x x )) ( define ( cubic a b c ) ( lambda ( x ) ( + ( cube x ) ( * a ( square x )) ( * b x ) c ))) ; Using with `newtons-method` ( define ( deriv g ) ( lambda ( x ) ( / ( - ( g ( + x dx )) ( g x )) dx ))) ( define dx 0.00001 ) ( define tolerance 0.00001 ) ( define ( fixed-point f first-guess ) ( define ( close-enough? v1 v2 ) ( < ( abs ( - v1 v2 )) tolerance )) ( define ( try guess ) ( let (( next ( f guess ))) ( if ( close-enough? guess next ) next ( try next )))) ( try first-guess )) ( define ( newton-transform g ) ( lambda ( x ) ( - x ( / ( g x ) (( deriv g ) x ))))) ( define ( newtons-method g guess ) ( fixed-point ( newton-transform g ) guess )) ( newtons-method ( cubic 3 1 19 ) 1 ) ;Value: -3.959409544418823 (~4)","title":"1.40"},{"location":"SICP/ch1-abstraction-procedures/1.40/#140","text":"; Define a procedure cubic that can be used together with the ; `newtons-method` procedure in expressions of the form ; (newtons-method (cubic a b c) 1) ; to approximate zeros of the cubic x3 + ax2 + bx + c. ( define ( cube x ) ( * x x x )) ( define ( cubic a b c ) ( lambda ( x ) ( + ( cube x ) ( * a ( square x )) ( * b x ) c ))) ; Using with `newtons-method` ( define ( deriv g ) ( lambda ( x ) ( / ( - ( g ( + x dx )) ( g x )) dx ))) ( define dx 0.00001 ) ( define tolerance 0.00001 ) ( define ( fixed-point f first-guess ) ( define ( close-enough? v1 v2 ) ( < ( abs ( - v1 v2 )) tolerance )) ( define ( try guess ) ( let (( next ( f guess ))) ( if ( close-enough? guess next ) next ( try next )))) ( try first-guess )) ( define ( newton-transform g ) ( lambda ( x ) ( - x ( / ( g x ) (( deriv g ) x ))))) ( define ( newtons-method g guess ) ( fixed-point ( newton-transform g ) guess )) ( newtons-method ( cubic 3 1 19 ) 1 ) ;Value: -3.959409544418823 (~4)","title":"1.40"},{"location":"SICP/ch1-abstraction-procedures/1.41/","text":"1.41 \u00b6 ; Define a procedure `double` that takes a procedure of ; one argument as argument and returns a procedure that ; applies the original procedure twice. For example, if ; `inc` is a procedure that adds 1 to its argument, then ; (double inc) should be a procedure that adds 2. What ; value is returned by ; (((double (double double)) inc) 5) ( define ( double f ) ( lambda ( x ) ( f ( f x )))) ( define ( inc x ) ( + x 1 )) ((( double ( double double )) inc ) 5 ) ;Value: 21","title":"1.41"},{"location":"SICP/ch1-abstraction-procedures/1.41/#141","text":"; Define a procedure `double` that takes a procedure of ; one argument as argument and returns a procedure that ; applies the original procedure twice. For example, if ; `inc` is a procedure that adds 1 to its argument, then ; (double inc) should be a procedure that adds 2. What ; value is returned by ; (((double (double double)) inc) 5) ( define ( double f ) ( lambda ( x ) ( f ( f x )))) ( define ( inc x ) ( + x 1 )) ((( double ( double double )) inc ) 5 ) ;Value: 21","title":"1.41"},{"location":"SICP/ch1-abstraction-procedures/1.42/","text":"1.42 \u00b6 ; Let f and g be two one-argument functions. The ; composition f after g is defined to be the function ; x \udbff\udc15\u2192 f(g(x)). Define a procedure compose that implements ; `composition`. For example, if inc is a procedure that ; adds 1 to its argument, ; ((compose square inc) 6) ; 49 ( define ( compose f g ) ( lambda ( x ) ( f ( g x )))) ( define ( inc x ) ( + x 1 )) (( compose square inc ) 6 ) ;Value: 49","title":"1.42"},{"location":"SICP/ch1-abstraction-procedures/1.42/#142","text":"; Let f and g be two one-argument functions. The ; composition f after g is defined to be the function ; x \udbff\udc15\u2192 f(g(x)). Define a procedure compose that implements ; `composition`. For example, if inc is a procedure that ; adds 1 to its argument, ; ((compose square inc) 6) ; 49 ( define ( compose f g ) ( lambda ( x ) ( f ( g x )))) ( define ( inc x ) ( + x 1 )) (( compose square inc ) 6 ) ;Value: 49","title":"1.42"},{"location":"SICP/ch1-abstraction-procedures/1.43/","text":"1.43 \u00b6 ; If f is a numerical function and n is a positive integer, ; then we can form the nth repeated application of f , ; which is defined to be the function whose value at ; x is f(f(...(f(x))...)). For example, if f is the function ; x \udbff\udc15\u2192 x + 1, then the nth repeated application of f is the ; function x \udbff\udc15\u2192 x + n. If f is the operation of squaring a ; number, then the nth repeated application of f is the ; function that raises its argument to the 2^n-th power. ; Write a procedure that takes as inputs a procedure that ; computes f and a positive integer n and returns the ; procedure that computes the nth repeated application of f. ; Your procedure should be able to be used as follows: ; ((repeated square 2) 5) ; 625 ; Hint: You may find it convenient to use compose from Exercise 1.42. ( define ( compose f g ) ( lambda ( x ) ( f ( g x )))) ( define ( repeated f n ) ( if ( = n 1 ) ( lambda ( x ) ( f x )) ( compose f ( repeated f ( - n 1 )))) ) (( repeated square 2 ) 5 ) ;Value: 625","title":"1.43"},{"location":"SICP/ch1-abstraction-procedures/1.43/#143","text":"; If f is a numerical function and n is a positive integer, ; then we can form the nth repeated application of f , ; which is defined to be the function whose value at ; x is f(f(...(f(x))...)). For example, if f is the function ; x \udbff\udc15\u2192 x + 1, then the nth repeated application of f is the ; function x \udbff\udc15\u2192 x + n. If f is the operation of squaring a ; number, then the nth repeated application of f is the ; function that raises its argument to the 2^n-th power. ; Write a procedure that takes as inputs a procedure that ; computes f and a positive integer n and returns the ; procedure that computes the nth repeated application of f. ; Your procedure should be able to be used as follows: ; ((repeated square 2) 5) ; 625 ; Hint: You may find it convenient to use compose from Exercise 1.42. ( define ( compose f g ) ( lambda ( x ) ( f ( g x )))) ( define ( repeated f n ) ( if ( = n 1 ) ( lambda ( x ) ( f x )) ( compose f ( repeated f ( - n 1 )))) ) (( repeated square 2 ) 5 ) ;Value: 625","title":"1.43"},{"location":"SICP/ch1-abstraction-procedures/1.44/","text":"1.44 \u00b6 ; The idea of smoothing a function is an important concept ; in signal processing. If f is a function and dx is some ; small number, then the smoothed version of f is the ; function whose value at a point x is the average of ; f(x\u2212dx), f(x), and f(x+dx). Write a procedure smooth ; that takes as input a procedure that computes f and ; returns a procedure that computes the smoothed f. ; It is sometimes valuable to repeatedly smooth a ; function (that is, smooth the smoothed function, and so ; on) to obtain the n-fold smoothed function. Show how to ; generate the n-fold smoothed function of any given function ; using `smooth` and `repeated` from Exercise 1.43. ; Answer ; (i) Let's define `repeated` procedure ( define ( compose f g ) ( lambda ( x ) ( f ( g x )))) ( define ( repeated f n ) ( if ( = n 1 ) ( lambda ( x ) ( f x )) ( compose f ( repeated f ( - n 1 )))) ) ; (ii) Write `smooth` procedure ( define ( average a b c ) ( / ( + a b c ) 3 )) ( define dx 0.0001 ) ( define ( smooth f ) ( lambda ( x ) ( average ( f ( - x dx )) ( f x ) ( f ( + x dx ))))) ; (iii) Write `n-fold-smooth` procedure ( define ( n-fold-smooth f n ) ( repeated ( smooth f ) n )) (( n-fold-smooth ( lambda ( x ) ( sin x )) 10 ) 3.1415 ) ;Value: 9.265358537893419e-5","title":"1.44"},{"location":"SICP/ch1-abstraction-procedures/1.44/#144","text":"; The idea of smoothing a function is an important concept ; in signal processing. If f is a function and dx is some ; small number, then the smoothed version of f is the ; function whose value at a point x is the average of ; f(x\u2212dx), f(x), and f(x+dx). Write a procedure smooth ; that takes as input a procedure that computes f and ; returns a procedure that computes the smoothed f. ; It is sometimes valuable to repeatedly smooth a ; function (that is, smooth the smoothed function, and so ; on) to obtain the n-fold smoothed function. Show how to ; generate the n-fold smoothed function of any given function ; using `smooth` and `repeated` from Exercise 1.43. ; Answer ; (i) Let's define `repeated` procedure ( define ( compose f g ) ( lambda ( x ) ( f ( g x )))) ( define ( repeated f n ) ( if ( = n 1 ) ( lambda ( x ) ( f x )) ( compose f ( repeated f ( - n 1 )))) ) ; (ii) Write `smooth` procedure ( define ( average a b c ) ( / ( + a b c ) 3 )) ( define dx 0.0001 ) ( define ( smooth f ) ( lambda ( x ) ( average ( f ( - x dx )) ( f x ) ( f ( + x dx ))))) ; (iii) Write `n-fold-smooth` procedure ( define ( n-fold-smooth f n ) ( repeated ( smooth f ) n )) (( n-fold-smooth ( lambda ( x ) ( sin x )) 10 ) 3.1415 ) ;Value: 9.265358537893419e-5","title":"1.44"},{"location":"SICP/ch1-abstraction-procedures/1.45/","text":"1.45 \u00b6 ; We saw in Section 1.3.3 that attempting to compute square ; roots by naively finding a fixed point of y \udbff\udc15\u2192 x/y does not ; converge, and that this can be fixed by average damping. ; The same method works for finding cube roots as fixed ; points of the average-damped y \udbff\udc15\u2192 x/y2. Unfortunately, the ; process does not work for fourth roots \u2014 a single average ; damp is not enough to make a fixed-point search for y \udbff\udc15\u2192 x/y3 ; converge. On the other hand, if we average damp twice (i.e., ; use the average damp of the average damp of y \udbff\udc15\u2192 x/y3) the ; fixed-point search does converge. Do some experiments to ; determine how many average damps are required to compute ; nth roots as a fixed-point search based upon repeated average ; damping of y \udbff\udc15\u2192 x/yn\u22121. Use this to implement a simple procedure ; for computing nth roots using fixed-point, average-damp, and ; the repeated procedure of Exercise 1.43. Assume that any ; arithmetic operations you need are available as primitives. ( define ( average-damp f ) ( lambda ( x ) (( lambda ( a b ) ( / ( + a b ) 2 )) x ( f x )))) ( define ( fixed-point f first-guess ) ( define ( close-enough? v1 v2 ) ( < ( abs ( - v1 v2 )) 0.00001 )) ( define ( try guess ) ( let (( next ( f guess ))) ( if ( close-enough? guess next ) next ( try next )))) ( try first-guess )) ( define ( compose f g ) ( lambda ( x ) ( f ( g x )))) ( define ( repeated f n ) ( if ( = n 1 ) ( lambda ( x ) ( f x )) ( compose f ( repeated f ( - n 1 )))) ) ; Let's write nth-root procedure ( define ( nth-root x n damps ) ( fixed-point (( repeated average-damp damps ) ( lambda ( y ) ( / x ( expt y ( - n 1 ))))) 1.0 )) ; Let's try with some values ( nth-root 1296 4 3 ) ;Value: 6.000005021306138 (6^4 = 1296) ( nth-root 2197.5 5 3 ) ;Value: 4.660003848858503 (4.66^5 ~= 2197.5) ; It is sufficient to apply number of damps log2(n) times ( define ( nth-root x n ) ( define damps ( floor ( / ( log n ) ( log 2 )))) ( fixed-point (( repeated average-damp damps ) ( lambda ( y ) ( / x ( expt y ( - n 1 ))))) 1.0 )) ( nth-root 1048576 20 ) ;Value: 1.999999063225966","title":"1.45"},{"location":"SICP/ch1-abstraction-procedures/1.45/#145","text":"; We saw in Section 1.3.3 that attempting to compute square ; roots by naively finding a fixed point of y \udbff\udc15\u2192 x/y does not ; converge, and that this can be fixed by average damping. ; The same method works for finding cube roots as fixed ; points of the average-damped y \udbff\udc15\u2192 x/y2. Unfortunately, the ; process does not work for fourth roots \u2014 a single average ; damp is not enough to make a fixed-point search for y \udbff\udc15\u2192 x/y3 ; converge. On the other hand, if we average damp twice (i.e., ; use the average damp of the average damp of y \udbff\udc15\u2192 x/y3) the ; fixed-point search does converge. Do some experiments to ; determine how many average damps are required to compute ; nth roots as a fixed-point search based upon repeated average ; damping of y \udbff\udc15\u2192 x/yn\u22121. Use this to implement a simple procedure ; for computing nth roots using fixed-point, average-damp, and ; the repeated procedure of Exercise 1.43. Assume that any ; arithmetic operations you need are available as primitives. ( define ( average-damp f ) ( lambda ( x ) (( lambda ( a b ) ( / ( + a b ) 2 )) x ( f x )))) ( define ( fixed-point f first-guess ) ( define ( close-enough? v1 v2 ) ( < ( abs ( - v1 v2 )) 0.00001 )) ( define ( try guess ) ( let (( next ( f guess ))) ( if ( close-enough? guess next ) next ( try next )))) ( try first-guess )) ( define ( compose f g ) ( lambda ( x ) ( f ( g x )))) ( define ( repeated f n ) ( if ( = n 1 ) ( lambda ( x ) ( f x )) ( compose f ( repeated f ( - n 1 )))) ) ; Let's write nth-root procedure ( define ( nth-root x n damps ) ( fixed-point (( repeated average-damp damps ) ( lambda ( y ) ( / x ( expt y ( - n 1 ))))) 1.0 )) ; Let's try with some values ( nth-root 1296 4 3 ) ;Value: 6.000005021306138 (6^4 = 1296) ( nth-root 2197.5 5 3 ) ;Value: 4.660003848858503 (4.66^5 ~= 2197.5) ; It is sufficient to apply number of damps log2(n) times ( define ( nth-root x n ) ( define damps ( floor ( / ( log n ) ( log 2 )))) ( fixed-point (( repeated average-damp damps ) ( lambda ( y ) ( / x ( expt y ( - n 1 ))))) 1.0 )) ( nth-root 1048576 20 ) ;Value: 1.999999063225966","title":"1.45"},{"location":"SICP/ch1-abstraction-procedures/1.46/","text":"1.46 \u00b6 ; Several of the numerical methods described in this chapter ; are instances of an extremely general computational strategy ; known as iterative improvement. Iterative improvement says ; that, to compute something, we start with an initial guess ; for the answer, test if the guess is good enough, and otherwise ; improve the guess and continue the process using the improved ; guess as the new guess. Write a procedure iterative-improve ; that takes two procedures as arguments: a method for telling ; whether a guess is good enough and a method for improving a ; guess. iterative-improve should return as its value a procedure ; that takes a guess as argument and keeps improving the guess ; until it is good enough. Rewrite the sqrt procedure of Section 1.1.7 ; and the fixed-point procedure of Section 1.3.3 in terms of ; iterative-improve. ( define ( iterative-improve good-enough? improve ) ( lambda ( guess ) ( if ( good-enough? guess ) guess (( iterative-improve good-enough? improve ) ( improve guess ))))) ; (i) Re-write sqrt ( define ( sqrt-iter x ) ( define ( avg a b ) ( / ( + a b ) 2 )) ( define ( good-enough? guess ) ( < ( abs ( - ( square guess ) x )) 0.001 )) ( define ( improve guess ) ( avg guess ( / x guess ))) (( iterative-improve good-enough? improve ) 1.0 )) ( sqrt-iter 69 ) ;Value: 8.306626993523448 ; (ii) Re-write `fixed-point` ( define ( fixed-point f first-guess ) ( define ( close-enough? v1 v2 ) ( < ( abs ( - v1 v2 )) 0.00001 )) (( iterative-improve ( lambda ( x ) ( close-enough? x ( f x ))) f ) first-guess )) ( fixed-point ( lambda ( x ) ( + 1 ( / 1 x ))) 1.0 ) ;Value: 1.6180327868852458 (~= \u03c6, golden ratio)","title":"1.46"},{"location":"SICP/ch1-abstraction-procedures/1.46/#146","text":"; Several of the numerical methods described in this chapter ; are instances of an extremely general computational strategy ; known as iterative improvement. Iterative improvement says ; that, to compute something, we start with an initial guess ; for the answer, test if the guess is good enough, and otherwise ; improve the guess and continue the process using the improved ; guess as the new guess. Write a procedure iterative-improve ; that takes two procedures as arguments: a method for telling ; whether a guess is good enough and a method for improving a ; guess. iterative-improve should return as its value a procedure ; that takes a guess as argument and keeps improving the guess ; until it is good enough. Rewrite the sqrt procedure of Section 1.1.7 ; and the fixed-point procedure of Section 1.3.3 in terms of ; iterative-improve. ( define ( iterative-improve good-enough? improve ) ( lambda ( guess ) ( if ( good-enough? guess ) guess (( iterative-improve good-enough? improve ) ( improve guess ))))) ; (i) Re-write sqrt ( define ( sqrt-iter x ) ( define ( avg a b ) ( / ( + a b ) 2 )) ( define ( good-enough? guess ) ( < ( abs ( - ( square guess ) x )) 0.001 )) ( define ( improve guess ) ( avg guess ( / x guess ))) (( iterative-improve good-enough? improve ) 1.0 )) ( sqrt-iter 69 ) ;Value: 8.306626993523448 ; (ii) Re-write `fixed-point` ( define ( fixed-point f first-guess ) ( define ( close-enough? v1 v2 ) ( < ( abs ( - v1 v2 )) 0.00001 )) (( iterative-improve ( lambda ( x ) ( close-enough? x ( f x ))) f ) first-guess )) ( fixed-point ( lambda ( x ) ( + 1 ( / 1 x ))) 1.0 ) ;Value: 1.6180327868852458 (~= \u03c6, golden ratio)","title":"1.46"},{"location":"SICP/ch1-abstraction-procedures/counting-change/","text":"counting-change \u00b6 ( define ( count-change amount ) ( cc amount 5 )) ( define ( cc amount kinds-of-coins ) ( cond (( = amount 0 ) 1 ) (( or ( < amount 0 ) ( = kinds-of-coins 0 )) 0 ) ( else ( + ( cc amount ( - kinds-of-coins 1 )) ( cc ( - amount ( first-denomination kinds-of-coins )) kinds-of-coins )))) ) ( define ( first-denomination kinds-of-coins ) ( cond (( = kinds-of-coins 1 ) 1 ) (( = kinds-of-coins 2 ) 5 ) (( = kinds-of-coins 3 ) 10 ) (( = kinds-of-coins 4 ) 25 ) (( = kinds-of-coins 5 ) 50 )) ) ( count-change 100 ) ;Value: 292","title":"counting-change"},{"location":"SICP/ch1-abstraction-procedures/counting-change/#counting-change","text":"( define ( count-change amount ) ( cc amount 5 )) ( define ( cc amount kinds-of-coins ) ( cond (( = amount 0 ) 1 ) (( or ( < amount 0 ) ( = kinds-of-coins 0 )) 0 ) ( else ( + ( cc amount ( - kinds-of-coins 1 )) ( cc ( - amount ( first-denomination kinds-of-coins )) kinds-of-coins )))) ) ( define ( first-denomination kinds-of-coins ) ( cond (( = kinds-of-coins 1 ) 1 ) (( = kinds-of-coins 2 ) 5 ) (( = kinds-of-coins 3 ) 10 ) (( = kinds-of-coins 4 ) 25 ) (( = kinds-of-coins 5 ) 50 )) ) ( count-change 100 ) ;Value: 292","title":"counting-change"},{"location":"SICP/ch1-abstraction-procedures/expt/","text":"expt \u00b6 ; Exponent Recursive ; requires \u0398(n) steps and \u0398(n) space ( define ( expt b n ) ( cond (( = n 0 ) 1 ) ( else ( * b ( expt b ( - n 1 ))))) ) ( expt 2 6 ) ;Value: 64 ; Exponent iterative ; requires \u0398(n) steps and \u0398(1) space ( define ( expt b n ) ( define ( expt-iter b prod n ) ( cond (( = n 0 ) prod ) ( else ( expt-iter b ( * b prod ) ( - n 1 ))) ) ) ( expt-iter b 1 n ) ) ( expt 2 6 ) ;Value: 64 ( expt 2 0 ) ;Value: 1 ; Exponent fast ; b^n = (b^n/2)^2 if n is even ; b^n = b * b^(n-1) if n is odd ; ; This has \u0398(log n) growth, ; for example for n = 1000, it requires only 14 multiplications ( define ( fast-exp b n ) ( define ( even? n ) ( = ( remainder n 2 ) 0 )) ( cond (( = n 0 ) 1 ) (( even? n ) ( square ( fast-exp b ( / n 2 )))) ( else ( * b ( fast-exp b ( - n 1 )))) ) ) ( fast-exp 2 6 ) ;Value: 64 ( fast-exp 2 5 ) ;Value: 32","title":"expt"},{"location":"SICP/ch1-abstraction-procedures/expt/#expt","text":"; Exponent Recursive ; requires \u0398(n) steps and \u0398(n) space ( define ( expt b n ) ( cond (( = n 0 ) 1 ) ( else ( * b ( expt b ( - n 1 ))))) ) ( expt 2 6 ) ;Value: 64 ; Exponent iterative ; requires \u0398(n) steps and \u0398(1) space ( define ( expt b n ) ( define ( expt-iter b prod n ) ( cond (( = n 0 ) prod ) ( else ( expt-iter b ( * b prod ) ( - n 1 ))) ) ) ( expt-iter b 1 n ) ) ( expt 2 6 ) ;Value: 64 ( expt 2 0 ) ;Value: 1 ; Exponent fast ; b^n = (b^n/2)^2 if n is even ; b^n = b * b^(n-1) if n is odd ; ; This has \u0398(log n) growth, ; for example for n = 1000, it requires only 14 multiplications ( define ( fast-exp b n ) ( define ( even? n ) ( = ( remainder n 2 ) 0 )) ( cond (( = n 0 ) 1 ) (( even? n ) ( square ( fast-exp b ( / n 2 )))) ( else ( * b ( fast-exp b ( - n 1 )))) ) ) ( fast-exp 2 6 ) ;Value: 64 ( fast-exp 2 5 ) ;Value: 32","title":"expt"},{"location":"SICP/ch1-abstraction-procedures/fibonacci_tree/","text":"fibonacci_tree \u00b6 ; Fibonacci series using tree recursion ( define ( fib n ) ( cond (( = n 0 ) 0 ) (( = n 1 ) 1 ) ( else ( + ( fib ( - n 1 )) ( fib ( - n 2 )))) ) ) ( fib 6 ) ( fib 5 ) ( fib 4 ) ; Fibonacci series using iterative process ( define ( fib n ) ( define ( fib-iter a b count ) ( if ( = count 0 ) b ( fib-iter ( + a b ) a ( - count 1 )) ) ) ( fib-iter 1 0 n ) ) ( fib 6 ) ( fib 5 ) ( fib 4 ) ; (fib 6) ; => (fib-iter 1 0 6) ; => (fib-iter 1 1 5) ; => (fib-iter 2 1 4) ; => (fib-iter 3 2 3) ; => (fib-iter 5 3 2) ; => (fib-iter 8 5 1) ; => (fib-iter 13 8 0) ; => 8","title":"fibonacci_tree"},{"location":"SICP/ch1-abstraction-procedures/fibonacci_tree/#fibonacci_tree","text":"; Fibonacci series using tree recursion ( define ( fib n ) ( cond (( = n 0 ) 0 ) (( = n 1 ) 1 ) ( else ( + ( fib ( - n 1 )) ( fib ( - n 2 )))) ) ) ( fib 6 ) ( fib 5 ) ( fib 4 ) ; Fibonacci series using iterative process ( define ( fib n ) ( define ( fib-iter a b count ) ( if ( = count 0 ) b ( fib-iter ( + a b ) a ( - count 1 )) ) ) ( fib-iter 1 0 n ) ) ( fib 6 ) ( fib 5 ) ( fib 4 ) ; (fib 6) ; => (fib-iter 1 0 6) ; => (fib-iter 1 1 5) ; => (fib-iter 2 1 4) ; => (fib-iter 3 2 3) ; => (fib-iter 5 3 2) ; => (fib-iter 8 5 1) ; => (fib-iter 13 8 0) ; => 8","title":"fibonacci_tree"},{"location":"SICP/ch1-abstraction-procedures/fixed-point/","text":"fixed-point \u00b6 ( define tolerance 0.00001 ) ( define ( fixed-point f first-guess ) ( define ( close-enough? v1 v2 ) ( < ( abs ( - v1 v2 )) tolerance )) ( define ( try guess ) ( let (( next ( f guess ))) ( if ( close-enough? guess next ) next ( try next )))) ( try first-guess )) ( fixed-point cos 1.0 ) ;Value: .7390822985224023 (cos (value) = value) ( fixed-point ( lambda ( y ) ( + ( sin y ) ( cos y ))) 1.0 ) ;Value: 1.2587315962971173","title":"fixed-point"},{"location":"SICP/ch1-abstraction-procedures/fixed-point/#fixed-point","text":"( define tolerance 0.00001 ) ( define ( fixed-point f first-guess ) ( define ( close-enough? v1 v2 ) ( < ( abs ( - v1 v2 )) tolerance )) ( define ( try guess ) ( let (( next ( f guess ))) ( if ( close-enough? guess next ) next ( try next )))) ( try first-guess )) ( fixed-point cos 1.0 ) ;Value: .7390822985224023 (cos (value) = value) ( fixed-point ( lambda ( y ) ( + ( sin y ) ( cos y ))) 1.0 ) ;Value: 1.2587315962971173","title":"fixed-point"},{"location":"SICP/ch1-abstraction-procedures/gcd/","text":"gcd \u00b6 ; Euclid's algorithm ; GCD(a,b) = GCD(b,r), where r is remainder of a/b ; GCD(206,40) = GCD(40,6) ; = GCD(6,4) ; = GCD(4,2) ; = GCD(2,0) ; = 2 ( define ( gcd a b ) ( if ( = b 0 ) a ( gcd b ( remainder a b )))) ( gcd 206 40 ) ;Value: 2 ( gcd 16 28 ) ;Value: 4","title":"gcd"},{"location":"SICP/ch1-abstraction-procedures/gcd/#gcd","text":"; Euclid's algorithm ; GCD(a,b) = GCD(b,r), where r is remainder of a/b ; GCD(206,40) = GCD(40,6) ; = GCD(6,4) ; = GCD(4,2) ; = GCD(2,0) ; = 2 ( define ( gcd a b ) ( if ( = b 0 ) a ( gcd b ( remainder a b )))) ( gcd 206 40 ) ;Value: 2 ( gcd 16 28 ) ;Value: 4","title":"gcd"},{"location":"SICP/ch1-abstraction-procedures/half-interval/","text":"half-interval \u00b6 ; Half-interval method for finding roots of ; f(x) = 0 ( define ( average a b ) ( / ( + a b ) 2 )) ( define ( search f neg-point pos-point ) ( let (( midpoint ( average neg-point pos-point ))) ( if ( close-enough? neg-point pos-point ) midpoint ( let (( test-value ( f midpoint ))) ( cond (( positive? test-value ) ( search f neg-point midpoint )) (( negative? test-value ) ( search f midpoint pos-point )) ( else midpoint )))))) ( define ( close-enough? x y ) ( < ( abs ( - x y )) 0.001 )) ; This will give wrong answer if we directly supply points ; at which f(x) do not have requried sign ; A better wrapper method ( define ( half-interval-method f a b ) ( let (( a-value ( f a )) ( b-value ( f b ))) ( cond (( and ( negative? a-value ) ( positive? b-value )) ( search f a b )) (( and ( positive? a-value ) ( negative? b-value )) ( search f b a )) ( else ( error \"Values are not of opposite sign\" a b ))))) ( half-interval-method sin 2.0 4.0 ) ;Value: 3.14111328125 ( half-interval-method ( lambda ( x ) ( - ( * x x x ) ( * 2 x ) 3 )) 1.0 2.0 ) ;Value: 1.89306640625","title":"half-interval"},{"location":"SICP/ch1-abstraction-procedures/half-interval/#half-interval","text":"; Half-interval method for finding roots of ; f(x) = 0 ( define ( average a b ) ( / ( + a b ) 2 )) ( define ( search f neg-point pos-point ) ( let (( midpoint ( average neg-point pos-point ))) ( if ( close-enough? neg-point pos-point ) midpoint ( let (( test-value ( f midpoint ))) ( cond (( positive? test-value ) ( search f neg-point midpoint )) (( negative? test-value ) ( search f midpoint pos-point )) ( else midpoint )))))) ( define ( close-enough? x y ) ( < ( abs ( - x y )) 0.001 )) ; This will give wrong answer if we directly supply points ; at which f(x) do not have requried sign ; A better wrapper method ( define ( half-interval-method f a b ) ( let (( a-value ( f a )) ( b-value ( f b ))) ( cond (( and ( negative? a-value ) ( positive? b-value )) ( search f a b )) (( and ( positive? a-value ) ( negative? b-value )) ( search f b a )) ( else ( error \"Values are not of opposite sign\" a b ))))) ( half-interval-method sin 2.0 4.0 ) ;Value: 3.14111328125 ( half-interval-method ( lambda ( x ) ( - ( * x x x ) ( * 2 x ) 3 )) 1.0 2.0 ) ;Value: 1.89306640625","title":"half-interval"},{"location":"SICP/ch1-abstraction-procedures/lambda/","text":"lambda \u00b6 ; f(x,y)=x(1+xy)^2 + y(1\u2212y) + (1+xy)(1\u2212y) ; => a = 1 + xy ; b = 1 - y ; => f(x, y) = xa^2 + yb + ab ( define ( f x y ) ( ( lambda ( a b ) ( + ( * x ( square a )) ( * y b ) ( * a b ) ) ) ( + 1 ( * x y )) ( - 1 y ) ) ) ( f 1 2 ) ;Value: 4 ; Using `let` feature ( define ( f x y ) ( let (( a ( + 1 ( * x y ))) ( b ( - 1 y ))) ( + ( * x ( square a )) ( * y b ) ( * a b )))) ( f 1 2 ) ;Value: 4","title":"lambda"},{"location":"SICP/ch1-abstraction-procedures/lambda/#lambda","text":"; f(x,y)=x(1+xy)^2 + y(1\u2212y) + (1+xy)(1\u2212y) ; => a = 1 + xy ; b = 1 - y ; => f(x, y) = xa^2 + yb + ab ( define ( f x y ) ( ( lambda ( a b ) ( + ( * x ( square a )) ( * y b ) ( * a b ) ) ) ( + 1 ( * x y )) ( - 1 y ) ) ) ( f 1 2 ) ;Value: 4 ; Using `let` feature ( define ( f x y ) ( let (( a ( + 1 ( * x y ))) ( b ( - 1 y ))) ( + ( * x ( square a )) ( * y b ) ( * a b )))) ( f 1 2 ) ;Value: 4","title":"lambda"},{"location":"SICP/ch1-abstraction-procedures/primality/","text":"primality \u00b6 ; Straightforward primality testing ; Test divisors b/w 1 to sqrt(n) ; Order of growth = \u0398(\u221an). ( define ( divides? a b ) ( = ( remainder b a ) 0 )) ( define ( prime? n ) ( define ( smallest-divisor n ) ( find-divisor n 2 )) ( define ( find-divisor n test-divisor ) ( cond (( > ( square test-divisor ) n ) n ) (( divides? test-divisor n ) test-divisor ) ( else ( find-divisor n ( + test-divisor 1 ))))) ( = n ( smallest-divisor n )) ) ( prime? 11 ) ( prime? 19 ) ( prime? 20 ) ; Fermat test ; If n is a prime number and a is any positive integer less ; than n, then a raised to the nth power is congruent to a modulo n ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( expmod base exp m ) ( cond (( = exp 0 ) 1 ) (( even? exp ) ( remainder ( square ( expmod base ( / exp 2 ) m )) m )) ( else ( remainder ( * base ( expmod base ( - exp 1 ) m )) m )))) ( define ( fermat-test n ) ( define ( try-it a ) ( = ( expmod a n n ) a )) ( try-it ( + 1 ( random ( - n 1 ))))) ( define ( fast-prime? n times ) ( cond (( = times 0 ) true ) (( fermat-test n ) ( fast-prime? n ( - times 1 ))) ( else false ))) ( fast-prime? 19 10 )","title":"primality"},{"location":"SICP/ch1-abstraction-procedures/primality/#primality","text":"; Straightforward primality testing ; Test divisors b/w 1 to sqrt(n) ; Order of growth = \u0398(\u221an). ( define ( divides? a b ) ( = ( remainder b a ) 0 )) ( define ( prime? n ) ( define ( smallest-divisor n ) ( find-divisor n 2 )) ( define ( find-divisor n test-divisor ) ( cond (( > ( square test-divisor ) n ) n ) (( divides? test-divisor n ) test-divisor ) ( else ( find-divisor n ( + test-divisor 1 ))))) ( = n ( smallest-divisor n )) ) ( prime? 11 ) ( prime? 19 ) ( prime? 20 ) ; Fermat test ; If n is a prime number and a is any positive integer less ; than n, then a raised to the nth power is congruent to a modulo n ( define ( even? x ) ( = ( remainder x 2 ) 0 )) ( define ( expmod base exp m ) ( cond (( = exp 0 ) 1 ) (( even? exp ) ( remainder ( square ( expmod base ( / exp 2 ) m )) m )) ( else ( remainder ( * base ( expmod base ( - exp 1 ) m )) m )))) ( define ( fermat-test n ) ( define ( try-it a ) ( = ( expmod a n n ) a )) ( try-it ( + 1 ( random ( - n 1 ))))) ( define ( fast-prime? n times ) ( cond (( = times 0 ) true ) (( fermat-test n ) ( fast-prime? n ( - times 1 ))) ( else false ))) ( fast-prime? 19 10 )","title":"primality"},{"location":"SICP/ch1-abstraction-procedures/sigma/","text":"sigma \u00b6 ; Arriving at higher abstraction notation \"Sigma\" ; (1) Compute sum from a to b ; a + (a + 1) + ... + (b - 1) + b ( define ( sum-integers a b ) ( if ( > a b ) 0 ( + a ( sum-integers ( + a 1 ) b )))) ( sum-integers 1 10 ) ;Value: 55 ; (2) Sum of cubes of integer from a to b ; a^3 + (a+1)^3 + ... + (b-1)^3 + b^3 ( define ( cube x ) ( * x x x )) ( define ( sum-cubes a b ) ( if ( > a b ) 0 ( + ( cube a ) ( sum-cubes ( + a 1 ) b )))) ( sum-cubes 2 4 ) ;Value: 99 ; (3) Sum of the following series (Pi-sum) ; (1/ (1 * 3)) + (1 / (5 * 7)) + (1 / (9 * 11)) + ... = \u03c0/8 ( define ( pi-sum a b ) ( if ( > a b ) 0 ( + ( / 1.0 ( * a ( + a 2 ))) ( pi-sum ( + a 4 ) b )))) ( * 8 ( pi-sum 1 1000 )) ;Value: 3.139592655589783 ; Abstracting the common pattern, ( define ( sigma term a next b ) ( if ( > a b ) 0 ( + ( term a ) ( sigma term ( next a ) next b )))) ; Problem (2) can be written as, ( define ( inc n ) ( + n 1 )) ( define ( sum-cubes a b ) ( sigma cube a inc b )) ( sum-cubes 2 4 ) ;Value: 99 ; Problem (3) can be written as, ( define ( pi-sum a b ) ( define ( pi-term x ) ( / 1.0 ( * x ( + x 2 )))) ( define ( pi-next x ) ( + x 4 )) ( sigma pi-term a pi-next b )) ( * 8 ( pi-sum 1 1000 )) ;Value: 3.139592655589783","title":"sigma"},{"location":"SICP/ch1-abstraction-procedures/sigma/#sigma","text":"; Arriving at higher abstraction notation \"Sigma\" ; (1) Compute sum from a to b ; a + (a + 1) + ... + (b - 1) + b ( define ( sum-integers a b ) ( if ( > a b ) 0 ( + a ( sum-integers ( + a 1 ) b )))) ( sum-integers 1 10 ) ;Value: 55 ; (2) Sum of cubes of integer from a to b ; a^3 + (a+1)^3 + ... + (b-1)^3 + b^3 ( define ( cube x ) ( * x x x )) ( define ( sum-cubes a b ) ( if ( > a b ) 0 ( + ( cube a ) ( sum-cubes ( + a 1 ) b )))) ( sum-cubes 2 4 ) ;Value: 99 ; (3) Sum of the following series (Pi-sum) ; (1/ (1 * 3)) + (1 / (5 * 7)) + (1 / (9 * 11)) + ... = \u03c0/8 ( define ( pi-sum a b ) ( if ( > a b ) 0 ( + ( / 1.0 ( * a ( + a 2 ))) ( pi-sum ( + a 4 ) b )))) ( * 8 ( pi-sum 1 1000 )) ;Value: 3.139592655589783 ; Abstracting the common pattern, ( define ( sigma term a next b ) ( if ( > a b ) 0 ( + ( term a ) ( sigma term ( next a ) next b )))) ; Problem (2) can be written as, ( define ( inc n ) ( + n 1 )) ( define ( sum-cubes a b ) ( sigma cube a inc b )) ( sum-cubes 2 4 ) ;Value: 99 ; Problem (3) can be written as, ( define ( pi-sum a b ) ( define ( pi-term x ) ( / 1.0 ( * x ( + x 2 )))) ( define ( pi-next x ) ( + x 4 )) ( sigma pi-term a pi-next b )) ( * 8 ( pi-sum 1 1000 )) ;Value: 3.139592655589783","title":"sigma"},{"location":"SICP/ch1-abstraction-procedures/transformation/","text":"transformation \u00b6 ; Derivate of a function ( define ( deriv g ) ( lambda ( x ) ( / ( - ( g ( + x dx )) ( g x )) dx ))) ( define dx 0.00001 ) ; Evaluate derivative of x^3 -> 3x^2 ; i.e. x -> x^3 at x=5 is 75 ( define ( cube x ) ( * x x x )) (( deriv cube ) 5 ) ;Value: 75.00014999664018 ; Newton's method as fixed point process, ; f(x) = x - g(x)/Dg(x) ( define tolerance 0.00001 ) ( define ( fixed-point f first-guess ) ( define ( close-enough? v1 v2 ) ( < ( abs ( - v1 v2 )) tolerance )) ( define ( try guess ) ( let (( next ( f guess ))) ( if ( close-enough? guess next ) next ( try next )))) ( try first-guess )) ( define ( newton-transform g ) ( lambda ( x ) ( - x ( / ( g x ) (( deriv g ) x ))))) ( define ( newtons-method g guess ) ( fixed-point ( newton-transform g ) guess )) ; Finding square root ; y -> y^2 - x ( define ( newton-sqrt x ) ( newtons-method ( lambda ( y ) ( - ( square y ) x )) 1.0 )) ( newton-sqrt 26 ) ;Value: 5.099019513592785 ; Abstractions and first-class procedures ( define ( fixed-point-of-transform g transform guess ) ( fixed-point ( transform g ) guess )) ; Square root v1 (using average damp y->x/y) ( define ( average-damp f ) ( lambda ( x ) (( lambda ( a b ) ( / ( + a b ) 2 )) x ( f x )))) ( define ( sqrt-v1 x ) ( fixed-point-of-transform ( lambda ( y ) ( / x y )) average-damp 1.0 )) ( sqrt-v1 28 ) ;Value: 5.291502622129181 ; Square root v2 (using Newton's transform) ( define ( sqrt-v2 x ) ( fixed-point-of-transform ( lambda ( y ) ( - ( square y ) x )) newton-transform 1.0 )) ( sqrt-v2 28 ) ;Value: 5.291502622129181","title":"transformation"},{"location":"SICP/ch1-abstraction-procedures/transformation/#transformation","text":"; Derivate of a function ( define ( deriv g ) ( lambda ( x ) ( / ( - ( g ( + x dx )) ( g x )) dx ))) ( define dx 0.00001 ) ; Evaluate derivative of x^3 -> 3x^2 ; i.e. x -> x^3 at x=5 is 75 ( define ( cube x ) ( * x x x )) (( deriv cube ) 5 ) ;Value: 75.00014999664018 ; Newton's method as fixed point process, ; f(x) = x - g(x)/Dg(x) ( define tolerance 0.00001 ) ( define ( fixed-point f first-guess ) ( define ( close-enough? v1 v2 ) ( < ( abs ( - v1 v2 )) tolerance )) ( define ( try guess ) ( let (( next ( f guess ))) ( if ( close-enough? guess next ) next ( try next )))) ( try first-guess )) ( define ( newton-transform g ) ( lambda ( x ) ( - x ( / ( g x ) (( deriv g ) x ))))) ( define ( newtons-method g guess ) ( fixed-point ( newton-transform g ) guess )) ; Finding square root ; y -> y^2 - x ( define ( newton-sqrt x ) ( newtons-method ( lambda ( y ) ( - ( square y ) x )) 1.0 )) ( newton-sqrt 26 ) ;Value: 5.099019513592785 ; Abstractions and first-class procedures ( define ( fixed-point-of-transform g transform guess ) ( fixed-point ( transform g ) guess )) ; Square root v1 (using average damp y->x/y) ( define ( average-damp f ) ( lambda ( x ) (( lambda ( a b ) ( / ( + a b ) 2 )) x ( f x )))) ( define ( sqrt-v1 x ) ( fixed-point-of-transform ( lambda ( y ) ( / x y )) average-damp 1.0 )) ( sqrt-v1 28 ) ;Value: 5.291502622129181 ; Square root v2 (using Newton's transform) ( define ( sqrt-v2 x ) ( fixed-point-of-transform ( lambda ( y ) ( - ( square y ) x )) newton-transform 1.0 )) ( sqrt-v2 28 ) ;Value: 5.291502622129181","title":"transformation"},{"location":"SICP/ch2-abstraction-data/2.01/","text":"2.01 \u00b6 ; Define a better version of make-rat that handles both ; positive and negative arguments. make-rat should normalize ; the sign so that if the rational number is positive, both ; the numerator and denominator are positive, and if the ; rational number is negative, only the numerator is negative. ( define ( numer x ) ( car x )) ( define ( denom x ) ( cdr x )) ( define ( print-rat x ) ( newline ) ( display ( numer x )) ( display \"/\" ) ( display ( denom x ))) ( define ( make-rat n d ) ( define g ( gcd n d )) ( let (( n-pos ( abs ( / n g ))) ( d-pos ( abs ( / d g )))) ( cond (( > ( * n d ) 0 ) ( cons n-pos d-pos )) (( < ( * n d ) 0 ) ( cons ( - n-pos ) d-pos ))))) ( print-rat ( make-rat 6 18 )) ;1/3 ( print-rat ( make-rat -6 -18 )) ;1/3 ( print-rat ( make-rat 6 -18 )) ;-1/3 ( print-rat ( make-rat -6 18 )) ;-1/3","title":"2.01"},{"location":"SICP/ch2-abstraction-data/2.01/#201","text":"; Define a better version of make-rat that handles both ; positive and negative arguments. make-rat should normalize ; the sign so that if the rational number is positive, both ; the numerator and denominator are positive, and if the ; rational number is negative, only the numerator is negative. ( define ( numer x ) ( car x )) ( define ( denom x ) ( cdr x )) ( define ( print-rat x ) ( newline ) ( display ( numer x )) ( display \"/\" ) ( display ( denom x ))) ( define ( make-rat n d ) ( define g ( gcd n d )) ( let (( n-pos ( abs ( / n g ))) ( d-pos ( abs ( / d g )))) ( cond (( > ( * n d ) 0 ) ( cons n-pos d-pos )) (( < ( * n d ) 0 ) ( cons ( - n-pos ) d-pos ))))) ( print-rat ( make-rat 6 18 )) ;1/3 ( print-rat ( make-rat -6 -18 )) ;1/3 ( print-rat ( make-rat 6 -18 )) ;-1/3 ( print-rat ( make-rat -6 18 )) ;-1/3","title":"2.01"},{"location":"SICP/ch2-abstraction-data/2.02/","text":"2.02 \u00b6 ; Consider the problem of representing line segments in a plane. ; Each segment is represented as a pair of points: a starting point ; and an ending point. Define a constructor make-segment and ; selectors start-segment and end-segment that define the representation ; of segments in terms of points. Furthermore, a point can be represented ; as a pair of numbers: the x coordinate and the y coordinate. ; Accordingly, specify a constructor make-point and selectors x-point and ; y-point that define this representation. Finally, using your selectors ; and constructors, define a procedure midpoint-segment that takes a ; line segment as argument and returns its midpoint (the point whose ; coordinates are the average of the coordinates of the endpoints). ; To try your procedures, you\u2019ll need a way to print points: ; (define (print-point p) ; (newline) ; (display \"(\") ; (display (x-point p)) ; (display \",\") ; (display (y-point p)) ; (display \")\")) ; Points ( define ( make-point x y ) ( cons x y )) ( define ( x-point point ) ( car point )) ( define ( y-point point ) ( cdr point )) ; Segments ( define ( make-segment point1 point2 ) ( cons point1 point2 )) ( define ( start-segment segment ) ( car segment )) ( define ( end-segment segment ) ( cdr segment )) ; Midpoint ( define ( midpoint-segment segment ) ( make-point ( / ( + ( x-point ( start-segment segment )) ( x-point ( end-segment segment ))) 2 ) ( / ( + ( y-point ( start-segment segment )) ( y-point ( end-segment segment ))) 2 ))) ( define ( print-point p ) ( newline ) ( display \"(\" ) ( display ( x-point p )) ( display \",\" ) ( display ( y-point p )) ( display \")\" )) ; Test ( define point1 ( make-point 1 2 )) ( define point2 ( make-point 2 5 )) ( define segment1 ( make-segment point1 point2 )) ( define midpoint ( midpoint-segment segment1 )) ( print-point midpoint ) ;(3/2,7/2)","title":"2.02"},{"location":"SICP/ch2-abstraction-data/2.02/#202","text":"; Consider the problem of representing line segments in a plane. ; Each segment is represented as a pair of points: a starting point ; and an ending point. Define a constructor make-segment and ; selectors start-segment and end-segment that define the representation ; of segments in terms of points. Furthermore, a point can be represented ; as a pair of numbers: the x coordinate and the y coordinate. ; Accordingly, specify a constructor make-point and selectors x-point and ; y-point that define this representation. Finally, using your selectors ; and constructors, define a procedure midpoint-segment that takes a ; line segment as argument and returns its midpoint (the point whose ; coordinates are the average of the coordinates of the endpoints). ; To try your procedures, you\u2019ll need a way to print points: ; (define (print-point p) ; (newline) ; (display \"(\") ; (display (x-point p)) ; (display \",\") ; (display (y-point p)) ; (display \")\")) ; Points ( define ( make-point x y ) ( cons x y )) ( define ( x-point point ) ( car point )) ( define ( y-point point ) ( cdr point )) ; Segments ( define ( make-segment point1 point2 ) ( cons point1 point2 )) ( define ( start-segment segment ) ( car segment )) ( define ( end-segment segment ) ( cdr segment )) ; Midpoint ( define ( midpoint-segment segment ) ( make-point ( / ( + ( x-point ( start-segment segment )) ( x-point ( end-segment segment ))) 2 ) ( / ( + ( y-point ( start-segment segment )) ( y-point ( end-segment segment ))) 2 ))) ( define ( print-point p ) ( newline ) ( display \"(\" ) ( display ( x-point p )) ( display \",\" ) ( display ( y-point p )) ( display \")\" )) ; Test ( define point1 ( make-point 1 2 )) ( define point2 ( make-point 2 5 )) ( define segment1 ( make-segment point1 point2 )) ( define midpoint ( midpoint-segment segment1 )) ( print-point midpoint ) ;(3/2,7/2)","title":"2.02"},{"location":"SICP/ch2-abstraction-data/2.03/","text":"2.03 \u00b6 ; Implement a representation for rectangles in a plane. ; (Hint: You may want to make use of Exercise 2.2.) In ; terms of your constructors and selectors, create ; procedures that compute the perimeter and the area of ; a given rectangle. Now implement a different representation ; for rectangles. Can you design your system with suitable ; abstraction barriers, so that the same perimeter and area ; procedures will work using either representation? ; Points ( define ( make-point x y ) ( cons x y )) ( define ( x-point point ) ( car point )) ( define ( y-point point ) ( cdr point )) ; Rectangle ; (node1) -------------- ; | | ; | | ; | | ; --------------- (node2) ( define ( make-rect node1 node2 ) ( cons node1 node2 )) ( define ( rect-node1 rect ) ( car rect )) ( define ( rect-node2 rect ) ( cdr rect )) ; Procedure for calculating width (x2 - x1) ( define ( get-rect-width rect ) ( abs ( - ( x-point ( rect-node1 rect )) ( x-point ( rect-node2 rect ))))) ; Procedure for calculating height (y2 - y1) ( define ( get-rect-height rect ) ( abs ( - ( y-point ( rect-node1 rect )) ( y-point ( rect-node2 rect ))))) ; Perimeter ( define ( perimeter rect ) ( * 2 ( + ( get-rect-width rect ) ( get-rect-height rect )))) ; Area ( define ( area rect ) ( * ( get-rect-width rect ) ( get-rect-height rect ))) ; Testing ( define myrect ( make-rect ( make-point 2 4 ) ( make-point 6 9 ))) ( perimeter myrect ) ;Value: 18 ( area myrect ) ;Value: 20 ; ------------------------------- ; Let's define another simplest representation of rectangle ; using just plain numbers (width and height) ; ; width ; ------------------------ ; | | ; | | height ; | | ; ------------------------ ( define ( make-rect-2 width height ) ( cons width height )) ( define ( get-rect-width rect ) ( car rect )) ( define ( get-rect-height rect ) ( cdr rect )) ; Testing ( define myrect2 ( make-rect-2 4 10 )) ( perimeter myrect2 ) ;Value: 28 ( area myrect2 ) ;Value: 40 ; We defined another representation of rectangle and did not ; have to change the implementation of `perimeter` and `area`","title":"2.03"},{"location":"SICP/ch2-abstraction-data/2.03/#203","text":"; Implement a representation for rectangles in a plane. ; (Hint: You may want to make use of Exercise 2.2.) In ; terms of your constructors and selectors, create ; procedures that compute the perimeter and the area of ; a given rectangle. Now implement a different representation ; for rectangles. Can you design your system with suitable ; abstraction barriers, so that the same perimeter and area ; procedures will work using either representation? ; Points ( define ( make-point x y ) ( cons x y )) ( define ( x-point point ) ( car point )) ( define ( y-point point ) ( cdr point )) ; Rectangle ; (node1) -------------- ; | | ; | | ; | | ; --------------- (node2) ( define ( make-rect node1 node2 ) ( cons node1 node2 )) ( define ( rect-node1 rect ) ( car rect )) ( define ( rect-node2 rect ) ( cdr rect )) ; Procedure for calculating width (x2 - x1) ( define ( get-rect-width rect ) ( abs ( - ( x-point ( rect-node1 rect )) ( x-point ( rect-node2 rect ))))) ; Procedure for calculating height (y2 - y1) ( define ( get-rect-height rect ) ( abs ( - ( y-point ( rect-node1 rect )) ( y-point ( rect-node2 rect ))))) ; Perimeter ( define ( perimeter rect ) ( * 2 ( + ( get-rect-width rect ) ( get-rect-height rect )))) ; Area ( define ( area rect ) ( * ( get-rect-width rect ) ( get-rect-height rect ))) ; Testing ( define myrect ( make-rect ( make-point 2 4 ) ( make-point 6 9 ))) ( perimeter myrect ) ;Value: 18 ( area myrect ) ;Value: 20 ; ------------------------------- ; Let's define another simplest representation of rectangle ; using just plain numbers (width and height) ; ; width ; ------------------------ ; | | ; | | height ; | | ; ------------------------ ( define ( make-rect-2 width height ) ( cons width height )) ( define ( get-rect-width rect ) ( car rect )) ( define ( get-rect-height rect ) ( cdr rect )) ; Testing ( define myrect2 ( make-rect-2 4 10 )) ( perimeter myrect2 ) ;Value: 28 ( area myrect2 ) ;Value: 40 ; We defined another representation of rectangle and did not ; have to change the implementation of `perimeter` and `area`","title":"2.03"},{"location":"SICP/ch2-abstraction-data/2.04/","text":"2.04 \u00b6 ; Here is an alternative procedural representation of pairs. ; For this representation, verify that (car (cons x y)) yields ; x for any objects x and y. ( define ( cons x y ) ( lambda ( m ) ( m x y ))) ( define ( car z ) ( z ( lambda ( p q ) p ))) ; What is the corresponding definition of cdr? (Hint: To verify ; that this works, make use of the substitution model of Section 1.1.5.) ; Verify using substitution model ; ; => (car (cons x y)) ; => (car (lambda (m) (m x y))) ; => ((lambda (m) (m x y)) (lamda (p q)) p)) ; => ((lambda (p q) p) x y) ; => x ; `cdr` can be defined as, ( define ( cdr z ) ( z ( lambda ( p q ) q )))","title":"2.04"},{"location":"SICP/ch2-abstraction-data/2.04/#204","text":"; Here is an alternative procedural representation of pairs. ; For this representation, verify that (car (cons x y)) yields ; x for any objects x and y. ( define ( cons x y ) ( lambda ( m ) ( m x y ))) ( define ( car z ) ( z ( lambda ( p q ) p ))) ; What is the corresponding definition of cdr? (Hint: To verify ; that this works, make use of the substitution model of Section 1.1.5.) ; Verify using substitution model ; ; => (car (cons x y)) ; => (car (lambda (m) (m x y))) ; => ((lambda (m) (m x y)) (lamda (p q)) p)) ; => ((lambda (p q) p) x y) ; => x ; `cdr` can be defined as, ( define ( cdr z ) ( z ( lambda ( p q ) q )))","title":"2.04"},{"location":"SICP/ch2-abstraction-data/2.05/","text":"2.05 \u00b6 ; Show that we can represent pairs of nonnegative integers ; using only numbers and arithmetic operations if we represent ; the pair a and b as the integer that is the product 2^a * 3^b. ; Give the corresponding definitions of the procedures cons, car, ; and cdr. ; Answer ; ----------------- ; Let's take two numbers (a,b) => (5, 8) ; If n = 2^5 * 3^8, ; => we can retrieve \"5\" from n by counting the number of times ; n/2 yeilds zero remainder ; Similarly, we cna retrieve \"8\" from n by counting the number of ; times n/3 yields zero remainder ; Let's define a procedure to extact a or b (say x) from n ( define ( extract-exp n x ) ( define ( iter n count ) ( if ( = ( remainder n x ) 0 ) ( iter ( / n x ) ( + count 1 )) count )) ( iter n 0 )) ; Let's write corresponding `cons`, `car` and `cdr` ( define ( cons a b ) ( * ( expt 2 a ) ( expt 3 b ))) ( define ( car x ) ( extract-exp x 2 )) ( define ( cdr x ) ( extract-exp x 3 )) ; Testing ( define pair1 ( cons 5 8 )) ( car pair1 ) ;Value: 5 ( cdr pair1 ) ;Value: 8","title":"2.05"},{"location":"SICP/ch2-abstraction-data/2.05/#205","text":"; Show that we can represent pairs of nonnegative integers ; using only numbers and arithmetic operations if we represent ; the pair a and b as the integer that is the product 2^a * 3^b. ; Give the corresponding definitions of the procedures cons, car, ; and cdr. ; Answer ; ----------------- ; Let's take two numbers (a,b) => (5, 8) ; If n = 2^5 * 3^8, ; => we can retrieve \"5\" from n by counting the number of times ; n/2 yeilds zero remainder ; Similarly, we cna retrieve \"8\" from n by counting the number of ; times n/3 yields zero remainder ; Let's define a procedure to extact a or b (say x) from n ( define ( extract-exp n x ) ( define ( iter n count ) ( if ( = ( remainder n x ) 0 ) ( iter ( / n x ) ( + count 1 )) count )) ( iter n 0 )) ; Let's write corresponding `cons`, `car` and `cdr` ( define ( cons a b ) ( * ( expt 2 a ) ( expt 3 b ))) ( define ( car x ) ( extract-exp x 2 )) ( define ( cdr x ) ( extract-exp x 3 )) ; Testing ( define pair1 ( cons 5 8 )) ( car pair1 ) ;Value: 5 ( cdr pair1 ) ;Value: 8","title":"2.05"},{"location":"SICP/ch2-abstraction-data/2.06/","text":"2.06 \u00b6 ; In case representing pairs as procedures wasn\u2019t mind-boggling enough, ; consider that, in a language that can manipulate procedures, we can ; get by without numbers (at least insofar as nonnegative integers are ; concerned) by implementing 0 and the operation of adding 1 as ( define zero ( lambda ( f ) ( lambda ( x ) x ))) ( define ( add-1 n ) ( lambda ( f ) ( lambda ( x ) ( f (( n f ) x ))))) ; This representation is known as Church numerals, after its inventor, ; Alonzo Church, the logician who invented the \u03bb- calculus. ; Define `one` and `two` directly (not in terms of zero and add- 1). ; (Hint: Use substitution to evaluate (add-1 zero)). Give a direct ; definition of the addition procedure + (not in terms of repeated ; application of add-1). ; (i) Getting `one` by substitution (add-1 zero) ; ------------------------------------------------------------------ ; (add-1 zero) ; (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x)))) ; (lambda (f) (lambda (x) (f ((lambda (x) x) x)))) ; (lambda (f) (lambda (x) (f x))) ( define one ( lambda ( f ) ( lambda ( x ) ( f x )))) ; (ii) Getting `two` by substitution (add-1 one) ; ------------------------------------------------------------------ ; (add-1 one) ; (lambda (f) (lambda (x) (f ((one f) x)))) ; (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x)))) ; (lambda (f) (lambda (x) (f ((lambda (x) (f x)) x)))) ; (lambda (f) (lambda (x) (f (f x)))) ( define two ( lambda ( f ) ( lambda ( x ) ( f ( f x ))))) ; (iii) Generalizing (addition a b) ; (Note: This was confusing to me! Had to look up for the solution. ; A good explanation is available. Just Google) ( define ( addition a b ) ( lambda ( f ) ( lambda ( x ) (( a f ) (( b f ) x )))))","title":"2.06"},{"location":"SICP/ch2-abstraction-data/2.06/#206","text":"; In case representing pairs as procedures wasn\u2019t mind-boggling enough, ; consider that, in a language that can manipulate procedures, we can ; get by without numbers (at least insofar as nonnegative integers are ; concerned) by implementing 0 and the operation of adding 1 as ( define zero ( lambda ( f ) ( lambda ( x ) x ))) ( define ( add-1 n ) ( lambda ( f ) ( lambda ( x ) ( f (( n f ) x ))))) ; This representation is known as Church numerals, after its inventor, ; Alonzo Church, the logician who invented the \u03bb- calculus. ; Define `one` and `two` directly (not in terms of zero and add- 1). ; (Hint: Use substitution to evaluate (add-1 zero)). Give a direct ; definition of the addition procedure + (not in terms of repeated ; application of add-1). ; (i) Getting `one` by substitution (add-1 zero) ; ------------------------------------------------------------------ ; (add-1 zero) ; (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x)))) ; (lambda (f) (lambda (x) (f ((lambda (x) x) x)))) ; (lambda (f) (lambda (x) (f x))) ( define one ( lambda ( f ) ( lambda ( x ) ( f x )))) ; (ii) Getting `two` by substitution (add-1 one) ; ------------------------------------------------------------------ ; (add-1 one) ; (lambda (f) (lambda (x) (f ((one f) x)))) ; (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x)))) ; (lambda (f) (lambda (x) (f ((lambda (x) (f x)) x)))) ; (lambda (f) (lambda (x) (f (f x)))) ( define two ( lambda ( f ) ( lambda ( x ) ( f ( f x ))))) ; (iii) Generalizing (addition a b) ; (Note: This was confusing to me! Had to look up for the solution. ; A good explanation is available. Just Google) ( define ( addition a b ) ( lambda ( f ) ( lambda ( x ) (( a f ) (( b f ) x )))))","title":"2.06"},{"location":"SICP/ch2-abstraction-data/2.07/","text":"2.07 \u00b6 ; Alyssa\u2019s program is incomplete because she has not specified ; the implementation of the interval abstraction. Here is a ; definition of the interval constructor: ( define ( make-interval a b ) ( cons a b )) ; Define selectors upper-bound and lower-bound to complete the implementation. ( define ( add-interval x y ) ( make-interval ( + ( lower-bound x ) ( lower-bound y )) ( + ( upper-bound x ) ( upper-bound y )))) ( define ( mul-interval x y ) ( let (( p1 ( * ( lower-bound x ) ( lower-bound y ))) ( p2 ( * ( lower-bound x ) ( upper-bound y ))) ( p3 ( * ( upper-bound x ) ( lower-bound y ))) ( p4 ( * ( upper-bound x ) ( upper-bound y )))) ( make-interval ( min p1 p2 p3 p4 ) ( max p1 p2 p3 p4 )))) ( define ( div-interval x y ) ( mul-interval x ( make-interval ( / 1.0 ( upper-bound y )) ( / 1.0 ( lower-bound y ))))) ( define ( lower-bound z ) ( car z )) ( define ( upper-bound z ) ( cdr z )) ( define ( print-interval z ) ( newline ) ( display \"[\" ) ( display ( lower-bound z )) ( display \", \" ) ( display ( upper-bound z )) ( display \"]\" )) ; Testing ; (i) Testing addition ; [1.5, 1.8] + [5.6, 5.75] => [7.1, 7.55] ( define interval1 ( make-interval 1.5 1.8 )) ( define interval2 ( make-interval 5.6 5.75 )) ( define interval3 ( add-interval interval1 interval2 )) ( print-interval interval3 ) ; [7.1, 7.55] ; (ii) Testing multiplication ; [1.5, 1.8] * [5.6, 5.75] => [8.4, 10.35] ( define interval4 ( mul-interval interval1 interval2 )) ( print-interval interval4 ) ; [8.399999999999999, 10.35] ; (iii) Testing division ; [1.5, 1.8] / [5.6, 5.75] => [1.5, 1.8] * [0.1739130435, 0.1785714286] ; => [0.26, 0.32] ( define interval5 ( div-interval interval1 interval2 )) ( print-interval interval5 ) ; [.2608695652173913, .32142857142857145] ; (iv) Testing negative ( print-interval ( add-interval ( make-interval -1.5 -1.2 ) ( make-interval -1 2 ))) ; [-2.5, .8] ( print-interval ( mul-interval ( make-interval -1.5 -1.2 ) ( make-interval -1 2 ))) ; [-3., 1.5] ( print-interval ( div-interval ( make-interval -1.5 -1.2 ) ( make-interval -1 2 ))) ; [-.75, 1.5]","title":"2.07"},{"location":"SICP/ch2-abstraction-data/2.07/#207","text":"; Alyssa\u2019s program is incomplete because she has not specified ; the implementation of the interval abstraction. Here is a ; definition of the interval constructor: ( define ( make-interval a b ) ( cons a b )) ; Define selectors upper-bound and lower-bound to complete the implementation. ( define ( add-interval x y ) ( make-interval ( + ( lower-bound x ) ( lower-bound y )) ( + ( upper-bound x ) ( upper-bound y )))) ( define ( mul-interval x y ) ( let (( p1 ( * ( lower-bound x ) ( lower-bound y ))) ( p2 ( * ( lower-bound x ) ( upper-bound y ))) ( p3 ( * ( upper-bound x ) ( lower-bound y ))) ( p4 ( * ( upper-bound x ) ( upper-bound y )))) ( make-interval ( min p1 p2 p3 p4 ) ( max p1 p2 p3 p4 )))) ( define ( div-interval x y ) ( mul-interval x ( make-interval ( / 1.0 ( upper-bound y )) ( / 1.0 ( lower-bound y ))))) ( define ( lower-bound z ) ( car z )) ( define ( upper-bound z ) ( cdr z )) ( define ( print-interval z ) ( newline ) ( display \"[\" ) ( display ( lower-bound z )) ( display \", \" ) ( display ( upper-bound z )) ( display \"]\" )) ; Testing ; (i) Testing addition ; [1.5, 1.8] + [5.6, 5.75] => [7.1, 7.55] ( define interval1 ( make-interval 1.5 1.8 )) ( define interval2 ( make-interval 5.6 5.75 )) ( define interval3 ( add-interval interval1 interval2 )) ( print-interval interval3 ) ; [7.1, 7.55] ; (ii) Testing multiplication ; [1.5, 1.8] * [5.6, 5.75] => [8.4, 10.35] ( define interval4 ( mul-interval interval1 interval2 )) ( print-interval interval4 ) ; [8.399999999999999, 10.35] ; (iii) Testing division ; [1.5, 1.8] / [5.6, 5.75] => [1.5, 1.8] * [0.1739130435, 0.1785714286] ; => [0.26, 0.32] ( define interval5 ( div-interval interval1 interval2 )) ( print-interval interval5 ) ; [.2608695652173913, .32142857142857145] ; (iv) Testing negative ( print-interval ( add-interval ( make-interval -1.5 -1.2 ) ( make-interval -1 2 ))) ; [-2.5, .8] ( print-interval ( mul-interval ( make-interval -1.5 -1.2 ) ( make-interval -1 2 ))) ; [-3., 1.5] ( print-interval ( div-interval ( make-interval -1.5 -1.2 ) ( make-interval -1 2 ))) ; [-.75, 1.5]","title":"2.07"},{"location":"SICP/ch2-abstraction-data/2.08/","text":"2.08 \u00b6 ; Using reasoning analogous to Alyssa\u2019s, describe how the ; difference of two intervals may be computed. Define a ; corresponding subtraction procedure, called `sub-interval`. ( define ( make-interval a b ) ( cons a b )) ( define ( add-interval x y ) ( make-interval ( + ( lower-bound x ) ( lower-bound y )) ( + ( upper-bound x ) ( upper-bound y )))) ( define ( sub-interval x y ) ( make-interval ( - ( lower-bound x ) ( lower-bound y )) ( - ( upper-bound x ) ( upper-bound y ))))","title":"2.08"},{"location":"SICP/ch2-abstraction-data/2.08/#208","text":"; Using reasoning analogous to Alyssa\u2019s, describe how the ; difference of two intervals may be computed. Define a ; corresponding subtraction procedure, called `sub-interval`. ( define ( make-interval a b ) ( cons a b )) ( define ( add-interval x y ) ( make-interval ( + ( lower-bound x ) ( lower-bound y )) ( + ( upper-bound x ) ( upper-bound y )))) ( define ( sub-interval x y ) ( make-interval ( - ( lower-bound x ) ( lower-bound y )) ( - ( upper-bound x ) ( upper-bound y ))))","title":"2.08"},{"location":"SICP/ch2-abstraction-data/2.09/","text":"2.09 \u00b6 ; The width of an interval is half of the difference between its ; upper and lower bounds. The width is a measure of the uncertainty ; of the number specified by the interval. For some arithmetic ; operations the width of the result of combining two intervals is ; a function only of the widths of the argument intervals, whereas ; for others the width of the combination is not a function of the ; widths of the argument intervals. Show that the width of the sum ; (or difference) of two intervals is a function only of the widths ; of the intervals being added (or subtracted). Give examples to ; show that this is not true for multiplication or division. ( define ( make-interval a b ) ( cons a b )) ( define ( lower-bound z ) ( car z )) ( define ( upper-bound z ) ( cdr z )) ( define ( add-interval x y ) ( make-interval ( + ( lower-bound x ) ( lower-bound y )) ( + ( upper-bound x ) ( upper-bound y )))) ( define ( mul-interval x y ) ( let (( p1 ( * ( lower-bound x ) ( lower-bound y ))) ( p2 ( * ( lower-bound x ) ( upper-bound y ))) ( p3 ( * ( upper-bound x ) ( lower-bound y ))) ( p4 ( * ( upper-bound x ) ( upper-bound y )))) ( make-interval ( min p1 p2 p3 p4 ) ( max p1 p2 p3 p4 )))) ; Define `width` ( define ( width-interval z ) ( / ( - ( upper-bound z ) ( lower-bound z )) 2 )) ; (i) Testing with addition ; width1 = (1.8-1.5)/2 = 0.15 ; width2 = (5.75-5.6)/2 = 0.075 ; width1 + width2 = 0.225 ; also, width-add = (7.55 - 7.1)/2 = 0.225 ( define interval1 ( add-interval ( make-interval 1.5 1.8 ) ( make-interval 5.6 5.75 ))) ( width-interval interval1 ) ;Value: .2250000000000001 ; => width of the sum (or difference) of two intervals is a ; function only of the widths of the intervals being added ; (or subtracted) ; (ii) Testing with multiplication ; width1 = 0.15, width2 = 0.075 => width1 * width2 = 0.01125 ; also, width-mul = (10.35 - 8.4)/2 = 0.975 ( define interval2 ( mul-interval ( make-interval 1.5 1.8 ) ( make-interval 5.6 5.75 ))) ( width-interval interval2 ) ;Value: .9750000000000005 ; => width of the multiplication (or division) of two intervals is ; \"not\" a function of widths of intervals being multiplied ; (or divided)","title":"2.09"},{"location":"SICP/ch2-abstraction-data/2.09/#209","text":"; The width of an interval is half of the difference between its ; upper and lower bounds. The width is a measure of the uncertainty ; of the number specified by the interval. For some arithmetic ; operations the width of the result of combining two intervals is ; a function only of the widths of the argument intervals, whereas ; for others the width of the combination is not a function of the ; widths of the argument intervals. Show that the width of the sum ; (or difference) of two intervals is a function only of the widths ; of the intervals being added (or subtracted). Give examples to ; show that this is not true for multiplication or division. ( define ( make-interval a b ) ( cons a b )) ( define ( lower-bound z ) ( car z )) ( define ( upper-bound z ) ( cdr z )) ( define ( add-interval x y ) ( make-interval ( + ( lower-bound x ) ( lower-bound y )) ( + ( upper-bound x ) ( upper-bound y )))) ( define ( mul-interval x y ) ( let (( p1 ( * ( lower-bound x ) ( lower-bound y ))) ( p2 ( * ( lower-bound x ) ( upper-bound y ))) ( p3 ( * ( upper-bound x ) ( lower-bound y ))) ( p4 ( * ( upper-bound x ) ( upper-bound y )))) ( make-interval ( min p1 p2 p3 p4 ) ( max p1 p2 p3 p4 )))) ; Define `width` ( define ( width-interval z ) ( / ( - ( upper-bound z ) ( lower-bound z )) 2 )) ; (i) Testing with addition ; width1 = (1.8-1.5)/2 = 0.15 ; width2 = (5.75-5.6)/2 = 0.075 ; width1 + width2 = 0.225 ; also, width-add = (7.55 - 7.1)/2 = 0.225 ( define interval1 ( add-interval ( make-interval 1.5 1.8 ) ( make-interval 5.6 5.75 ))) ( width-interval interval1 ) ;Value: .2250000000000001 ; => width of the sum (or difference) of two intervals is a ; function only of the widths of the intervals being added ; (or subtracted) ; (ii) Testing with multiplication ; width1 = 0.15, width2 = 0.075 => width1 * width2 = 0.01125 ; also, width-mul = (10.35 - 8.4)/2 = 0.975 ( define interval2 ( mul-interval ( make-interval 1.5 1.8 ) ( make-interval 5.6 5.75 ))) ( width-interval interval2 ) ;Value: .9750000000000005 ; => width of the multiplication (or division) of two intervals is ; \"not\" a function of widths of intervals being multiplied ; (or divided)","title":"2.09"},{"location":"SICP/ch2-abstraction-data/2.10/","text":"2.10 \u00b6 ; Ben Bitdiddle, an expert systems programmer, looks over Alyssa\u2019s ; shoulder and comments that it is not clear what it means to divide ; by an interval that spans zero. Modify Alyssa\u2019s code to check for ; this condition and to signal an error if it occurs. ( define ( make-interval a b ) ( cons a b )) ( define ( lower-bound z ) ( car z )) ( define ( upper-bound z ) ( cdr z )) ; Check for spanning zero condition while dividing ( define ( div-interval x y ) ( if ( <= ( * ( lower-bound y ) ( upper-bound y )) 0 ) ( error \"Cannot divide interval spanning zero\" ) ( mul-interval x ( make-interval ( / 1.0 ( upper-bound y )) ( / 1.0 ( lower-bound y )))))) ; This will produce error ( div-interval ( make-interval 1 1.5 ) ( make-interval -0.5 0.5 )) ;Cannot divide interval spanning zero","title":"2.10"},{"location":"SICP/ch2-abstraction-data/2.10/#210","text":"; Ben Bitdiddle, an expert systems programmer, looks over Alyssa\u2019s ; shoulder and comments that it is not clear what it means to divide ; by an interval that spans zero. Modify Alyssa\u2019s code to check for ; this condition and to signal an error if it occurs. ( define ( make-interval a b ) ( cons a b )) ( define ( lower-bound z ) ( car z )) ( define ( upper-bound z ) ( cdr z )) ; Check for spanning zero condition while dividing ( define ( div-interval x y ) ( if ( <= ( * ( lower-bound y ) ( upper-bound y )) 0 ) ( error \"Cannot divide interval spanning zero\" ) ( mul-interval x ( make-interval ( / 1.0 ( upper-bound y )) ( / 1.0 ( lower-bound y )))))) ; This will produce error ( div-interval ( make-interval 1 1.5 ) ( make-interval -0.5 0.5 )) ;Cannot divide interval spanning zero","title":"2.10"},{"location":"SICP/ch2-abstraction-data/2.11/","text":"2.11 \u00b6 ; In passing, Ben also cryptically comments: \u201cBy testing the ; signs of the endpoints of the intervals, it is possible to ; break mul-interval into nine cases, only one of which ; requires more than two multiplications.\u201d Rewrite this procedure ; using Ben\u2019s suggestion ; Answer ; ------------------------------------ ; The nine cases are based on 3 signs of x and y ; x can have [-ve, -ve], [-ve, +ve] and [+ve, +ve] (3) ; (Note: [+ve, -ve] is NOT possible since order is always [lower, upper]) ; y can have [-ve, -ve], [-ve, +ve] and [+ve, +ve] (3) ; Hence there can be 3x3 = 9 possibilities. ; Let's associate a value to each combination ; [-ve, -ve] => -1, [-ve, +ve] => 0, [+ve, +ve] => 1 ; and define a function that returns us this value ( define ( get-pair-value low up ) ( cond (( and ( < low 0 ) ( < up 0 )) -1 ) (( and ( < low 0 ) ( > up 0 )) 0 ) ( else 1 ))) ; We can modify our `make-interval` to make sure always (a, b) has ; the property a < b ( define ( make-interval a b ) ( cons ( min a b ) ( max a b ))) ( define ( lower-bound z ) ( car z )) ( define ( upper-bound z ) ( cdr z )) ( define ( print-interval z ) ( newline ) ( display \"[\" ) ( display ( lower-bound z )) ( display \", \" ) ( display ( upper-bound z )) ( display \"]\" )) ; Let's rewrite our `mul-interval` procedure ( define ( mul-interval x y ) ( define xlow ( lower-bound x )) ( define xup ( upper-bound x )) ( define ylow ( lower-bound y )) ( define yup ( upper-bound y )) ( define xval ( get-pair-value xlow xup )) ( define yval ( get-pair-value ylow yup )) ( cond (( = xval -1 ) ( cond (( = yval -1 ) ; [-ve, -ve], [-ve, -ve] ( make-interval ( * xup yup ) ( * xlow ylow ))) (( = yval 0 ) ; [-ve, -ve], [-ve, +ve] ( make-interval ( * xlow yup ) ( * xlow ylow ))) ( else ; [-ve, -ve], [+ve, +ve] ( make-interval ( * xlow yup ) ( * xup ylow ))))) (( = xval 0 ) ( cond (( = yval -1 ) ; [-ve, +ve], [-ve, -ve] ( make-interval ( * xup ylow ) ( * xlow ylow ))) (( = yval 0 ) ; [-ve, +ve], [-ve, +ve] ( make-interval ( min ( * xlow yup ) ( * xup ylow )) ( max ( * xlow ylow ) ( * xup yup )))) ( else ; [-ve, +ve], [+ve, +ve] ( make-interval ( * xlow yup ) ( * xup yup ))))) ( else ( cond (( = yval -1 ) ; [+ve, +ve], [-ve, -ve] ( make-interval ( * xup ylow ) ( * xlow yup ))) (( = yval 0 ) ; [+ve, +ve], [-ve, +ve] ( make-interval ( * xup ylow ) ( * xup yup ))) ( else ; [+ve, +ve], [+ve, +ve] ( make-interval ( * xlow ylow ) ( * xup yup ))))))) ; Testing ( print-interval ( mul-interval ( make-interval -1.5 -1.2 ) ( make-interval -1 2 ))) ; [-3., 1.5] ( print-interval ( mul-interval ( make-interval -5 3 ) ( make-interval -2 4 ))) ; [-20, 12]","title":"2.11"},{"location":"SICP/ch2-abstraction-data/2.11/#211","text":"; In passing, Ben also cryptically comments: \u201cBy testing the ; signs of the endpoints of the intervals, it is possible to ; break mul-interval into nine cases, only one of which ; requires more than two multiplications.\u201d Rewrite this procedure ; using Ben\u2019s suggestion ; Answer ; ------------------------------------ ; The nine cases are based on 3 signs of x and y ; x can have [-ve, -ve], [-ve, +ve] and [+ve, +ve] (3) ; (Note: [+ve, -ve] is NOT possible since order is always [lower, upper]) ; y can have [-ve, -ve], [-ve, +ve] and [+ve, +ve] (3) ; Hence there can be 3x3 = 9 possibilities. ; Let's associate a value to each combination ; [-ve, -ve] => -1, [-ve, +ve] => 0, [+ve, +ve] => 1 ; and define a function that returns us this value ( define ( get-pair-value low up ) ( cond (( and ( < low 0 ) ( < up 0 )) -1 ) (( and ( < low 0 ) ( > up 0 )) 0 ) ( else 1 ))) ; We can modify our `make-interval` to make sure always (a, b) has ; the property a < b ( define ( make-interval a b ) ( cons ( min a b ) ( max a b ))) ( define ( lower-bound z ) ( car z )) ( define ( upper-bound z ) ( cdr z )) ( define ( print-interval z ) ( newline ) ( display \"[\" ) ( display ( lower-bound z )) ( display \", \" ) ( display ( upper-bound z )) ( display \"]\" )) ; Let's rewrite our `mul-interval` procedure ( define ( mul-interval x y ) ( define xlow ( lower-bound x )) ( define xup ( upper-bound x )) ( define ylow ( lower-bound y )) ( define yup ( upper-bound y )) ( define xval ( get-pair-value xlow xup )) ( define yval ( get-pair-value ylow yup )) ( cond (( = xval -1 ) ( cond (( = yval -1 ) ; [-ve, -ve], [-ve, -ve] ( make-interval ( * xup yup ) ( * xlow ylow ))) (( = yval 0 ) ; [-ve, -ve], [-ve, +ve] ( make-interval ( * xlow yup ) ( * xlow ylow ))) ( else ; [-ve, -ve], [+ve, +ve] ( make-interval ( * xlow yup ) ( * xup ylow ))))) (( = xval 0 ) ( cond (( = yval -1 ) ; [-ve, +ve], [-ve, -ve] ( make-interval ( * xup ylow ) ( * xlow ylow ))) (( = yval 0 ) ; [-ve, +ve], [-ve, +ve] ( make-interval ( min ( * xlow yup ) ( * xup ylow )) ( max ( * xlow ylow ) ( * xup yup )))) ( else ; [-ve, +ve], [+ve, +ve] ( make-interval ( * xlow yup ) ( * xup yup ))))) ( else ( cond (( = yval -1 ) ; [+ve, +ve], [-ve, -ve] ( make-interval ( * xup ylow ) ( * xlow yup ))) (( = yval 0 ) ; [+ve, +ve], [-ve, +ve] ( make-interval ( * xup ylow ) ( * xup yup ))) ( else ; [+ve, +ve], [+ve, +ve] ( make-interval ( * xlow ylow ) ( * xup yup ))))))) ; Testing ( print-interval ( mul-interval ( make-interval -1.5 -1.2 ) ( make-interval -1 2 ))) ; [-3., 1.5] ( print-interval ( mul-interval ( make-interval -5 3 ) ( make-interval -2 4 ))) ; [-20, 12]","title":"2.11"},{"location":"SICP/ch2-abstraction-data/2.12/","text":"2.12 \u00b6 ; After debugging her program, Alyssa shows it to a potential ; user, who complains that her program solves the wrong problem. ; He wants a program that can deal with numbers represented as ; a center value and an additive tolerance; for example, he ; wants to work with intervals such as 3.5 \u00b1 0.15 rather than ; [3.35, 3.65]. Alyssa returns to her desk and fixes this problem ; by supplying an alternate constructor and alternate selectors: ( define ( make-center-width c w ) ( make-interval ( - c w ) ( + c w ))) ( define ( center i ) ( / ( + ( lower-bound i ) ( upper-bound i )) 2 )) ( define ( width i ) ( / ( - ( upper-bound i ) ( lower-bound i )) 2 )) ; Unfortunately, most of Alyssa\u2019s users are engineers. Real engineering ; situations usually involve measurements with only a small uncertainty, ; measured as the ratio of the width of the interval to the midpoint of ; the interval. Engineers usually specify percentage tolerances on the ; parameters of devices, as in the resistor specifications given earlier. ; Define a constructor `make-center-percent` that takes a center and a ; percentage tolerance and produces the desired interval. You must also ; define a selector percent that produces the percentage tolerance for ; a given interval. The center selector is the same as the one shown above. ; Answer ; -------------------------------- ; Let's define necessary helpers ( define ( make-interval a b ) ( cons ( min a b ) ( max a b ))) ( define ( lower-bound z ) ( car z )) ( define ( upper-bound z ) ( cdr z )) ; Let's construct `make-center-percent` procedure ( define ( make-center-percent c p ) ( make-center-width c ( / ( * c p ) 100 ))) ; `percent` constructor can be written as, ( define ( percent i ) ( * ( / ( width i ) ( center i )) 100.0 )) ; Testing ( define resistor1 ( make-center-percent 5.6 10 )) ( percent resistor1 ) ;Value: 10.000000000000009 ( center resistor1 ) ;Value: 5.6","title":"2.12"},{"location":"SICP/ch2-abstraction-data/2.12/#212","text":"; After debugging her program, Alyssa shows it to a potential ; user, who complains that her program solves the wrong problem. ; He wants a program that can deal with numbers represented as ; a center value and an additive tolerance; for example, he ; wants to work with intervals such as 3.5 \u00b1 0.15 rather than ; [3.35, 3.65]. Alyssa returns to her desk and fixes this problem ; by supplying an alternate constructor and alternate selectors: ( define ( make-center-width c w ) ( make-interval ( - c w ) ( + c w ))) ( define ( center i ) ( / ( + ( lower-bound i ) ( upper-bound i )) 2 )) ( define ( width i ) ( / ( - ( upper-bound i ) ( lower-bound i )) 2 )) ; Unfortunately, most of Alyssa\u2019s users are engineers. Real engineering ; situations usually involve measurements with only a small uncertainty, ; measured as the ratio of the width of the interval to the midpoint of ; the interval. Engineers usually specify percentage tolerances on the ; parameters of devices, as in the resistor specifications given earlier. ; Define a constructor `make-center-percent` that takes a center and a ; percentage tolerance and produces the desired interval. You must also ; define a selector percent that produces the percentage tolerance for ; a given interval. The center selector is the same as the one shown above. ; Answer ; -------------------------------- ; Let's define necessary helpers ( define ( make-interval a b ) ( cons ( min a b ) ( max a b ))) ( define ( lower-bound z ) ( car z )) ( define ( upper-bound z ) ( cdr z )) ; Let's construct `make-center-percent` procedure ( define ( make-center-percent c p ) ( make-center-width c ( / ( * c p ) 100 ))) ; `percent` constructor can be written as, ( define ( percent i ) ( * ( / ( width i ) ( center i )) 100.0 )) ; Testing ( define resistor1 ( make-center-percent 5.6 10 )) ( percent resistor1 ) ;Value: 10.000000000000009 ( center resistor1 ) ;Value: 5.6","title":"2.12"},{"location":"SICP/ch2-abstraction-data/2.13/","text":"2.13 \u00b6 ; Show that under the assumption of small percentage tolerances ; there is a simple formula for the approximate percentage tolerance ; of the product of two intervals in terms of the tolerances of the ; factors. You may simplify the problem by assuming that all numbers ; are positive. ; We can show that the resulting percentage of a and b ; as approximately ; (percentage a) + (percentage b) ; Note: This proof could be wrong, I have not verified it properly ; ; Assuming all numbers are positie, ; [xlow, xup] x [ylow, yup] => [xlow * ylow, xup * yup] ; In terms of center \"c\" and percentage \"p\", ; interval = [c - c(p/100), c + c(p/100)] ; Multiplying a and b, having center \"ca\" and percentage \"pa\" ; [ ; (ca - ca(pa/100)) * (cb - cb(pb/100)), ; (ca + ca(pa/100)) * (cb + cb(pb/100)) ; ] ; [ ; ca * cb * (1 - pa/100) * (1 - pb/100), ; ca * cb * (1 + pa/100) * (1 + pb/100) ; ] ; [ ; ca * cb * (1 - pa/100 - pb/100 - (pa * pb / 10000)), ; ca * cb * (1 + pa/100 + pb/100 + (pa * pb / 10000)) ; ] ; Ignoring (pa * pb / 10000), since pa and pb are very small, ; we can rewrite the equation as, ; [ ; (ca*cb - (ca*cb)((pa + pb)/100)), ; (ca*cb + (ca*cb)((pa + pb)/100)) ; ] ; Which is of the form we started from, where our new center ; is ~ \"ca x cb\", and new percentage is \"pa + pb\" ( define ( make-interval a b ) ( cons ( min a b ) ( max a b ))) ( define ( lower-bound z ) ( car z )) ( define ( upper-bound z ) ( cdr z )) ( define ( make-center-percent c p ) ( make-center-width c ( / ( * c p ) 100 ))) ( define ( make-center-width c w ) ( make-interval ( - c w ) ( + c w ))) ( define ( center i ) ( / ( + ( lower-bound i ) ( upper-bound i )) 2 )) ( define ( width i ) ( / ( - ( upper-bound i ) ( lower-bound i )) 2 )) ( define ( percent i ) ( * ( / ( width i ) ( center i )) 100.0 )) ; Hence our new `mul-interval` can be approximated as, ( define ( mul-interval x y ) ( make-center-percent ( * ( center x ) ( center y )) ( + ( percent x ) ( percent y )))) ; Testing ( define interval1 ( make-center-percent 5.6 10 )) ( define interval2 ( make-center-percent 1.5 5 )) ( define interval3 ( mul-interval interval1 interval2 )) ( center interval3 ) ;Value: 8.399999999999999 ( percent interval3 ) ;Value: 15.","title":"2.13"},{"location":"SICP/ch2-abstraction-data/2.13/#213","text":"; Show that under the assumption of small percentage tolerances ; there is a simple formula for the approximate percentage tolerance ; of the product of two intervals in terms of the tolerances of the ; factors. You may simplify the problem by assuming that all numbers ; are positive. ; We can show that the resulting percentage of a and b ; as approximately ; (percentage a) + (percentage b) ; Note: This proof could be wrong, I have not verified it properly ; ; Assuming all numbers are positie, ; [xlow, xup] x [ylow, yup] => [xlow * ylow, xup * yup] ; In terms of center \"c\" and percentage \"p\", ; interval = [c - c(p/100), c + c(p/100)] ; Multiplying a and b, having center \"ca\" and percentage \"pa\" ; [ ; (ca - ca(pa/100)) * (cb - cb(pb/100)), ; (ca + ca(pa/100)) * (cb + cb(pb/100)) ; ] ; [ ; ca * cb * (1 - pa/100) * (1 - pb/100), ; ca * cb * (1 + pa/100) * (1 + pb/100) ; ] ; [ ; ca * cb * (1 - pa/100 - pb/100 - (pa * pb / 10000)), ; ca * cb * (1 + pa/100 + pb/100 + (pa * pb / 10000)) ; ] ; Ignoring (pa * pb / 10000), since pa and pb are very small, ; we can rewrite the equation as, ; [ ; (ca*cb - (ca*cb)((pa + pb)/100)), ; (ca*cb + (ca*cb)((pa + pb)/100)) ; ] ; Which is of the form we started from, where our new center ; is ~ \"ca x cb\", and new percentage is \"pa + pb\" ( define ( make-interval a b ) ( cons ( min a b ) ( max a b ))) ( define ( lower-bound z ) ( car z )) ( define ( upper-bound z ) ( cdr z )) ( define ( make-center-percent c p ) ( make-center-width c ( / ( * c p ) 100 ))) ( define ( make-center-width c w ) ( make-interval ( - c w ) ( + c w ))) ( define ( center i ) ( / ( + ( lower-bound i ) ( upper-bound i )) 2 )) ( define ( width i ) ( / ( - ( upper-bound i ) ( lower-bound i )) 2 )) ( define ( percent i ) ( * ( / ( width i ) ( center i )) 100.0 )) ; Hence our new `mul-interval` can be approximated as, ( define ( mul-interval x y ) ( make-center-percent ( * ( center x ) ( center y )) ( + ( percent x ) ( percent y )))) ; Testing ( define interval1 ( make-center-percent 5.6 10 )) ( define interval2 ( make-center-percent 1.5 5 )) ( define interval3 ( mul-interval interval1 interval2 )) ( center interval3 ) ;Value: 8.399999999999999 ( percent interval3 ) ;Value: 15.","title":"2.13"},{"location":"SICP/ch2-abstraction-data/2.14/","text":"2.14 \u00b6 ; After considerable work, Alyssa P. Hacker delivers her finished ; system. Several years later, after she has forgotten all about ; it, she gets a frenzied call from an irate user, Lem E. Tweakit. ; It seems that Lem has noticed that the formula for parallel ; resistors can be written in two algebraically equivalent ways: ; R1R2 / (R1 + R2) ; and ; 1 / ((1/R1) + (1/R2)) ; He has written the following two programs, each of which computes ; the parallel-resistors formula differently: ( define ( par1 r1 r2 ) ( div-interval ( mul-interval r1 r2 ) ( add-interval r1 r2 ))) ( define ( par2 r1 r2 ) ( let (( one ( make-interval 1 1 ))) ( div-interval one ( add-interval ( div-interval one r1 ) ( div-interval one r2 ))))) ; Lem complains that Alyssa\u2019s program gives different answers for ; the two ways of computing. This is a serious complaint. ; Demonstrate that Lem is right. Investigate the behavior of the ; system on a variety of arithmetic expressions. Make some intervals ; A and B, and use them in computing the expressions A/A and A/B. ; You will get the most insight by using intervals whose width is a ; small percentage of the center value. Examine the results of the ; computation in center-percent form (see Exercise 2.12). ; Answer ; -------------------------------------- ; Let's get the helpers ( define ( make-interval a b ) ( cons ( min a b ) ( max a b ))) ( define ( lower-bound z ) ( car z )) ( define ( upper-bound z ) ( cdr z )) ( define ( make-center-percent c p ) ( make-center-width c ( / ( * c p ) 100 ))) ( define ( make-center-width c w ) ( make-interval ( - c w ) ( + c w ))) ( define ( center i ) ( / ( + ( lower-bound i ) ( upper-bound i )) 2 )) ( define ( width i ) ( / ( - ( upper-bound i ) ( lower-bound i )) 2 )) ( define ( percent i ) ( * ( / ( width i ) ( center i )) 100.0 )) ( define ( add-interval x y ) ( make-interval ( + ( lower-bound x ) ( lower-bound y )) ( + ( upper-bound x ) ( upper-bound y )))) ( define ( mul-interval x y ) ( let (( p1 ( * ( lower-bound x ) ( lower-bound y ))) ( p2 ( * ( lower-bound x ) ( upper-bound y ))) ( p3 ( * ( upper-bound x ) ( lower-bound y ))) ( p4 ( * ( upper-bound x ) ( upper-bound y )))) ( make-interval ( min p1 p2 p3 p4 ) ( max p1 p2 p3 p4 )))) ( define ( div-interval x y ) ( mul-interval x ( make-interval ( / 1.0 ( upper-bound y )) ( / 1.0 ( lower-bound y ))))) ( define ( print-interval z ) ( newline ) ( display \"[\" ) ( display ( lower-bound z )) ( display \", \" ) ( display ( upper-bound z )) ( display \"]\" )) ; (i) Test Lem's complaint ; Take 2 resistors [3.5, 3.8] and [10, 10.3] ( define computation1 ( par1 ( make-interval 3.5 3.8 ) ( make-interval 10 10.3 ))) ( define computation2 ( par2 ( make-interval 3.5 3.8 ) ( make-interval 10 10.3 ))) ( print-interval computation1 ) ; [2.48, 2.9] ( print-interval computation2 ) ; [2.6, 2.77] ; => Lem's complaint is valid, we get two different results ; (ii) Let's define A and B using center-percent form ( define A ( make-center-percent 50 5 )) ( define B ( make-center-percent 100 8 )) ; Operation A/A ( define AA ( div-interval A A )) ( center AA ) ;Value: 1.0050125313283207 ( percent AA ) ;Value: 9.97506234413964 ; Operation A/B ( define AB ( div-interval A B )) ( center AB ) ;Value: .5052334943639292 ( percent AB ) ;Value: 12.948207171314744 ; => As we can observe, center of A/A is not exactly \"1\" ; also, center of A/B is not exactly \"0.5\" ; Hence there's something flawed in our interval operations ; Let's try one more operation 1/A (which I found out helpful ; for next exercise) ( define one ( make-center-percent 1 0 )) ( define 1 A ( div-interval one A )) ( center 1 A ) ; 2.0050125313283207e-2 (~0.002) ( percent 1 A ) ; 4.999999999999995 (~5%) ; Also, A/1 ( define A1 ( div-interval A one )) ( center A1 ) ;Value: 50. ( percent A1 ) ;Value: 5.","title":"2.14"},{"location":"SICP/ch2-abstraction-data/2.14/#214","text":"; After considerable work, Alyssa P. Hacker delivers her finished ; system. Several years later, after she has forgotten all about ; it, she gets a frenzied call from an irate user, Lem E. Tweakit. ; It seems that Lem has noticed that the formula for parallel ; resistors can be written in two algebraically equivalent ways: ; R1R2 / (R1 + R2) ; and ; 1 / ((1/R1) + (1/R2)) ; He has written the following two programs, each of which computes ; the parallel-resistors formula differently: ( define ( par1 r1 r2 ) ( div-interval ( mul-interval r1 r2 ) ( add-interval r1 r2 ))) ( define ( par2 r1 r2 ) ( let (( one ( make-interval 1 1 ))) ( div-interval one ( add-interval ( div-interval one r1 ) ( div-interval one r2 ))))) ; Lem complains that Alyssa\u2019s program gives different answers for ; the two ways of computing. This is a serious complaint. ; Demonstrate that Lem is right. Investigate the behavior of the ; system on a variety of arithmetic expressions. Make some intervals ; A and B, and use them in computing the expressions A/A and A/B. ; You will get the most insight by using intervals whose width is a ; small percentage of the center value. Examine the results of the ; computation in center-percent form (see Exercise 2.12). ; Answer ; -------------------------------------- ; Let's get the helpers ( define ( make-interval a b ) ( cons ( min a b ) ( max a b ))) ( define ( lower-bound z ) ( car z )) ( define ( upper-bound z ) ( cdr z )) ( define ( make-center-percent c p ) ( make-center-width c ( / ( * c p ) 100 ))) ( define ( make-center-width c w ) ( make-interval ( - c w ) ( + c w ))) ( define ( center i ) ( / ( + ( lower-bound i ) ( upper-bound i )) 2 )) ( define ( width i ) ( / ( - ( upper-bound i ) ( lower-bound i )) 2 )) ( define ( percent i ) ( * ( / ( width i ) ( center i )) 100.0 )) ( define ( add-interval x y ) ( make-interval ( + ( lower-bound x ) ( lower-bound y )) ( + ( upper-bound x ) ( upper-bound y )))) ( define ( mul-interval x y ) ( let (( p1 ( * ( lower-bound x ) ( lower-bound y ))) ( p2 ( * ( lower-bound x ) ( upper-bound y ))) ( p3 ( * ( upper-bound x ) ( lower-bound y ))) ( p4 ( * ( upper-bound x ) ( upper-bound y )))) ( make-interval ( min p1 p2 p3 p4 ) ( max p1 p2 p3 p4 )))) ( define ( div-interval x y ) ( mul-interval x ( make-interval ( / 1.0 ( upper-bound y )) ( / 1.0 ( lower-bound y ))))) ( define ( print-interval z ) ( newline ) ( display \"[\" ) ( display ( lower-bound z )) ( display \", \" ) ( display ( upper-bound z )) ( display \"]\" )) ; (i) Test Lem's complaint ; Take 2 resistors [3.5, 3.8] and [10, 10.3] ( define computation1 ( par1 ( make-interval 3.5 3.8 ) ( make-interval 10 10.3 ))) ( define computation2 ( par2 ( make-interval 3.5 3.8 ) ( make-interval 10 10.3 ))) ( print-interval computation1 ) ; [2.48, 2.9] ( print-interval computation2 ) ; [2.6, 2.77] ; => Lem's complaint is valid, we get two different results ; (ii) Let's define A and B using center-percent form ( define A ( make-center-percent 50 5 )) ( define B ( make-center-percent 100 8 )) ; Operation A/A ( define AA ( div-interval A A )) ( center AA ) ;Value: 1.0050125313283207 ( percent AA ) ;Value: 9.97506234413964 ; Operation A/B ( define AB ( div-interval A B )) ( center AB ) ;Value: .5052334943639292 ( percent AB ) ;Value: 12.948207171314744 ; => As we can observe, center of A/A is not exactly \"1\" ; also, center of A/B is not exactly \"0.5\" ; Hence there's something flawed in our interval operations ; Let's try one more operation 1/A (which I found out helpful ; for next exercise) ( define one ( make-center-percent 1 0 )) ( define 1 A ( div-interval one A )) ( center 1 A ) ; 2.0050125313283207e-2 (~0.002) ( percent 1 A ) ; 4.999999999999995 (~5%) ; Also, A/1 ( define A1 ( div-interval A one )) ( center A1 ) ;Value: 50. ( percent A1 ) ;Value: 5.","title":"2.14"},{"location":"SICP/ch2-abstraction-data/2.15/","text":"2.15 \u00b6 ; Eva Lu Ator, another user, has also noticed the different ; intervals computed by different but algebraically equivalent ; expressions. She says that a formula to compute with intervals ; using Alyssa\u2019s system will produce tighter error bounds if it ; can be written in such a form that no variable that represents ; an uncertain number is repeated. Thus, she says, par2 is a ; \u201cbetter\u201d program for parallel resistances than par1. Is she right? ; Why? ; Eva's hypothesis seems to be correct. From our previous exercise, ; we found that A/A is not exactly \"1\", hence the more we avoid ; repitition, more accurate our operations can be. Although, I am ; not entirely sure of this answer! There can be cases where this is ; not true","title":"2.15"},{"location":"SICP/ch2-abstraction-data/2.15/#215","text":"; Eva Lu Ator, another user, has also noticed the different ; intervals computed by different but algebraically equivalent ; expressions. She says that a formula to compute with intervals ; using Alyssa\u2019s system will produce tighter error bounds if it ; can be written in such a form that no variable that represents ; an uncertain number is repeated. Thus, she says, par2 is a ; \u201cbetter\u201d program for parallel resistances than par1. Is she right? ; Why? ; Eva's hypothesis seems to be correct. From our previous exercise, ; we found that A/A is not exactly \"1\", hence the more we avoid ; repitition, more accurate our operations can be. Although, I am ; not entirely sure of this answer! There can be cases where this is ; not true","title":"2.15"},{"location":"SICP/ch2-abstraction-data/2.16/","text":"2.16 \u00b6 ; Explain, in general, why equivalent algebraic expressions ; may lead to different answers. Can you devise an ; interval-arithmetic package that does not have this shortcoming, ; or is this task impossible? (Warning: This problem is very difficult.) ; Answer ; This seems to include a lot of derivation from interval systems. Although, ; from what I feel, the task seems impossible. i.e. we can not devise ; a package having no shortcoming","title":"2.16"},{"location":"SICP/ch2-abstraction-data/2.16/#216","text":"; Explain, in general, why equivalent algebraic expressions ; may lead to different answers. Can you devise an ; interval-arithmetic package that does not have this shortcoming, ; or is this task impossible? (Warning: This problem is very difficult.) ; Answer ; This seems to include a lot of derivation from interval systems. Although, ; from what I feel, the task seems impossible. i.e. we can not devise ; a package having no shortcoming","title":"2.16"},{"location":"SICP/ch2-abstraction-data/2.17/","text":"2.17 \u00b6 ; Define a procedure last-pair that returns the list that contains ; only the last element of a given (nonempty) list: ; (last-pair (list 23 72 149 34)) ; (34) ( define ( last-pair items ) ( if ( null? ( cdr items )) items ( last-pair ( cdr items )))) ( last-pair ( list 23 72 149 34 )) ;Value 2: (34) ( last-pair ( list 12 )) ;Value 3: (12)","title":"2.17"},{"location":"SICP/ch2-abstraction-data/2.17/#217","text":"; Define a procedure last-pair that returns the list that contains ; only the last element of a given (nonempty) list: ; (last-pair (list 23 72 149 34)) ; (34) ( define ( last-pair items ) ( if ( null? ( cdr items )) items ( last-pair ( cdr items )))) ( last-pair ( list 23 72 149 34 )) ;Value 2: (34) ( last-pair ( list 12 )) ;Value 3: (12)","title":"2.17"},{"location":"SICP/ch2-abstraction-data/2.18/","text":"2.18 \u00b6 ; Define a procedure reverse that takes a list as argument and returns ; a list of the same elements in reverse order: ; (reverse (list 1 4 9 16 25)) ; (25 16 9 4 1) ( define ( append list1 list2 ) ( if ( null? list1 ) list2 ( cons ( car list1 ) ( append ( cdr list1 ) list2 )))) ; Recursive version ( define ( reverse items ) ( if ( null? items ) items ( append ( reverse ( cdr items )) ( list ( car items ))))) ( reverse ( list 1 4 9 16 25 )) ; (25 16 9 4 1) ( reverse ( list 1 )) ; (1) ( reverse ( list 1 7 )) ; (7 1) ; Iterative version ( define ( reverse items ) ( define ( iter a b ) ( if ( null? a ) b ( iter ( cdr a ) ( cons ( car a ) b ))) ) ( iter ( cdr items ) ( list ( car items )))) ( reverse ( list 1 4 9 16 25 )) ; (25 16 9 4 1)","title":"2.18"},{"location":"SICP/ch2-abstraction-data/2.18/#218","text":"; Define a procedure reverse that takes a list as argument and returns ; a list of the same elements in reverse order: ; (reverse (list 1 4 9 16 25)) ; (25 16 9 4 1) ( define ( append list1 list2 ) ( if ( null? list1 ) list2 ( cons ( car list1 ) ( append ( cdr list1 ) list2 )))) ; Recursive version ( define ( reverse items ) ( if ( null? items ) items ( append ( reverse ( cdr items )) ( list ( car items ))))) ( reverse ( list 1 4 9 16 25 )) ; (25 16 9 4 1) ( reverse ( list 1 )) ; (1) ( reverse ( list 1 7 )) ; (7 1) ; Iterative version ( define ( reverse items ) ( define ( iter a b ) ( if ( null? a ) b ( iter ( cdr a ) ( cons ( car a ) b ))) ) ( iter ( cdr items ) ( list ( car items )))) ( reverse ( list 1 4 9 16 25 )) ; (25 16 9 4 1)","title":"2.18"},{"location":"SICP/ch2-abstraction-data/2.19/","text":"2.19 \u00b6 ; Consider the change-counting program of Section 1.2.2. It would be nice ; to be able to easily change the currency used by the program, so that ; we could compute the number of ways to change a British pound, for ; example. As the program is written, the knowledge of the currency is ; distributed partly into the procedure first-denomination and partly ; into the procedure count-change (which knows that there are five kinds ; of U.S. coins). It would be nicer to be able to supply a list of coins ; to be used for making change. ; We want to rewrite the procedure cc so that its second argument is a ; list of the values of the coins to use rather than an integer specifying ; which coins to use. We could then have lists that defined each kind of ; currency: ( define us-coins ( list 50 25 10 5 1 )) ( define uk-coins ( list 100 50 20 10 5 2 1 0.5 )) ; We could then call cc as follows: ; (cc 100 us-coins) ; 292 ; To do this will require changing the program cc somewhat. It will still ; have the same form, but it will access its second argument differently, ; as follows: ( define ( cc amount coin-values ) ( cond (( = amount 0 ) 1 ) (( or ( < amount 0 ) ( no-more? coin-values )) 0 ) ( else ( + ( cc amount ( except-first-denomination coin-values )) ( cc ( - amount ( first-denomination coin-values )) coin-values ))))) ; Define the procedures `first-denomination`, `except-first-denomination`, ; and `no-more`? in terms of primitive operations on list structures. Does ; the order of the list `coin-values` affect the answer produced by cc? ; Why or why not? ; Answer ; ----------------------------------------------------------- ; Define `no-more?`, `except-first-denomination` and `first-denomination` ( define ( no-more? items ) ( null? items )) ( define ( except-first-denomination items ) ( cdr items )) ( define ( first-denomination items ) ( car items )) ; Testing ( cc 100 us-coins ) ;Value: 292 ( cc 100 uk-coins ) ;Value: 104561 (TAKES TIME TO COMPUTE) ; Test the order ( cc 100 ( list 25 50 10 5 1 )) ;Value: 292 ; Order of the list does not matter since search is performed for all ; the combination in our algorithm","title":"2.19"},{"location":"SICP/ch2-abstraction-data/2.19/#219","text":"; Consider the change-counting program of Section 1.2.2. It would be nice ; to be able to easily change the currency used by the program, so that ; we could compute the number of ways to change a British pound, for ; example. As the program is written, the knowledge of the currency is ; distributed partly into the procedure first-denomination and partly ; into the procedure count-change (which knows that there are five kinds ; of U.S. coins). It would be nicer to be able to supply a list of coins ; to be used for making change. ; We want to rewrite the procedure cc so that its second argument is a ; list of the values of the coins to use rather than an integer specifying ; which coins to use. We could then have lists that defined each kind of ; currency: ( define us-coins ( list 50 25 10 5 1 )) ( define uk-coins ( list 100 50 20 10 5 2 1 0.5 )) ; We could then call cc as follows: ; (cc 100 us-coins) ; 292 ; To do this will require changing the program cc somewhat. It will still ; have the same form, but it will access its second argument differently, ; as follows: ( define ( cc amount coin-values ) ( cond (( = amount 0 ) 1 ) (( or ( < amount 0 ) ( no-more? coin-values )) 0 ) ( else ( + ( cc amount ( except-first-denomination coin-values )) ( cc ( - amount ( first-denomination coin-values )) coin-values ))))) ; Define the procedures `first-denomination`, `except-first-denomination`, ; and `no-more`? in terms of primitive operations on list structures. Does ; the order of the list `coin-values` affect the answer produced by cc? ; Why or why not? ; Answer ; ----------------------------------------------------------- ; Define `no-more?`, `except-first-denomination` and `first-denomination` ( define ( no-more? items ) ( null? items )) ( define ( except-first-denomination items ) ( cdr items )) ( define ( first-denomination items ) ( car items )) ; Testing ( cc 100 us-coins ) ;Value: 292 ( cc 100 uk-coins ) ;Value: 104561 (TAKES TIME TO COMPUTE) ; Test the order ( cc 100 ( list 25 50 10 5 1 )) ;Value: 292 ; Order of the list does not matter since search is performed for all ; the combination in our algorithm","title":"2.19"},{"location":"SICP/ch2-abstraction-data/2.20/","text":"2.20 \u00b6 ; The procedures +, *, and list take arbitrary numbers of arguments. One ; way to define such procedures is to use define with dotted-tail notation. ; In a procedure definition, a parameter list that has a dot before the ; last parameter name indicates that, when the procedure is called, the ; initial parameters (if any) will have as values the initial arguments, ; as usual, but the final parameter\u2019s value will be a list of any remaining ; arguments. For instance, given the definition ; (define (f x y . z) \u27e8body\u27e9) ; the procedure f can be called with two or more arguments. If we evaluate ; (f 1 2 3 4 5 6) ; then in the body of f,x will be 1, y will be 2, and z will be ; the list (3 4 5 6). Given the definition ; (define (g . w) \u27e8body\u27e9) ; the procedure g can be called with zero or more arguments. If we evaluate ; (g 1 2 3 4 5 6) ; then in the body of g,w will be the list(1 2 3 4 5 6). ; Use this notation to write a procedure same-parity that takes one or more ; integers and returns a list of all the arguments that have the same even-odd ; parity as the first argument. For example, ; (same-parity 1 2 3 4 5 6 7) => (1 3 5 7) ; (same-parity 2 3 4 5 6 7) => (2 4 6) ; Answer ; ============================================================ ( define ( append list1 list2 ) ( if ( null? list1 ) list2 ( cons ( car list1 ) ( append ( cdr list1 ) list2 )))) ( define ( same-parity a . args ) ( define ( same-par-nums? x y ) ( = ( remainder x 2 ) ( remainder y 2 ))) ( define ( iter margs res ) ( if ( null? margs ) res ( if ( same-par-nums? a ( car margs )) ( iter ( cdr margs ) ( append res ( list ( car margs )))) ( iter ( cdr margs ) res )))) ( iter args ( list a ))) ; Testing ( same-parity 1 2 3 4 5 6 7 ) ; (1 3 5 7) ( same-parity 2 3 4 5 6 7 ) ; (2 4 6)","title":"2.20"},{"location":"SICP/ch2-abstraction-data/2.20/#220","text":"; The procedures +, *, and list take arbitrary numbers of arguments. One ; way to define such procedures is to use define with dotted-tail notation. ; In a procedure definition, a parameter list that has a dot before the ; last parameter name indicates that, when the procedure is called, the ; initial parameters (if any) will have as values the initial arguments, ; as usual, but the final parameter\u2019s value will be a list of any remaining ; arguments. For instance, given the definition ; (define (f x y . z) \u27e8body\u27e9) ; the procedure f can be called with two or more arguments. If we evaluate ; (f 1 2 3 4 5 6) ; then in the body of f,x will be 1, y will be 2, and z will be ; the list (3 4 5 6). Given the definition ; (define (g . w) \u27e8body\u27e9) ; the procedure g can be called with zero or more arguments. If we evaluate ; (g 1 2 3 4 5 6) ; then in the body of g,w will be the list(1 2 3 4 5 6). ; Use this notation to write a procedure same-parity that takes one or more ; integers and returns a list of all the arguments that have the same even-odd ; parity as the first argument. For example, ; (same-parity 1 2 3 4 5 6 7) => (1 3 5 7) ; (same-parity 2 3 4 5 6 7) => (2 4 6) ; Answer ; ============================================================ ( define ( append list1 list2 ) ( if ( null? list1 ) list2 ( cons ( car list1 ) ( append ( cdr list1 ) list2 )))) ( define ( same-parity a . args ) ( define ( same-par-nums? x y ) ( = ( remainder x 2 ) ( remainder y 2 ))) ( define ( iter margs res ) ( if ( null? margs ) res ( if ( same-par-nums? a ( car margs )) ( iter ( cdr margs ) ( append res ( list ( car margs )))) ( iter ( cdr margs ) res )))) ( iter args ( list a ))) ; Testing ( same-parity 1 2 3 4 5 6 7 ) ; (1 3 5 7) ( same-parity 2 3 4 5 6 7 ) ; (2 4 6)","title":"2.20"},{"location":"SICP/ch2-abstraction-data/2.21/","text":"2.21 \u00b6 ; The procedure square-list takes a list of numbers as argument and ; returns a list of the squares of those numbers. ; (square-list (list 1 2 3 4)) ; (1 4 9 16) ; Here are two different definitions of square-list. Complete both of ; them by filling in the missing expressions: ; (define (square-list items) ; (if (null? items) ; nil ; (cons \u27e8??\u27e9 \u27e8??\u27e9))) ; ; (define (square-list items) ; (map \u27e8??\u27e9 \u27e8??\u27e9)) ( define ( square-list items ) ( if ( null? items ) items ( cons ( square ( car items )) ( square-list ( cdr items )))) ) ( square-list ( list 1 2 3 5 )) ; (1 4 9 25) ( define ( square-list items ) ( map square items )) ( square-list ( list 2 4 5 6 )) ; (4 16 25 36)","title":"2.21"},{"location":"SICP/ch2-abstraction-data/2.21/#221","text":"; The procedure square-list takes a list of numbers as argument and ; returns a list of the squares of those numbers. ; (square-list (list 1 2 3 4)) ; (1 4 9 16) ; Here are two different definitions of square-list. Complete both of ; them by filling in the missing expressions: ; (define (square-list items) ; (if (null? items) ; nil ; (cons \u27e8??\u27e9 \u27e8??\u27e9))) ; ; (define (square-list items) ; (map \u27e8??\u27e9 \u27e8??\u27e9)) ( define ( square-list items ) ( if ( null? items ) items ( cons ( square ( car items )) ( square-list ( cdr items )))) ) ( square-list ( list 1 2 3 5 )) ; (1 4 9 25) ( define ( square-list items ) ( map square items )) ( square-list ( list 2 4 5 6 )) ; (4 16 25 36)","title":"2.21"},{"location":"SICP/ch2-abstraction-data/2.22/","text":"2.22 \u00b6 ; Louis Reasoner tries to rewrite the first square-list procedure of ; Exercise 2.21 so that it evolves an iterative process: ( define nil ' ()) ( define ( square-list items ) ( define ( iter things answer ) ( if ( null? things ) answer ( iter ( cdr things ) ( cons ( square ( car things )) answer )))) ( iter items nil )) ( square-list ( list 1 2 3 4 )) ; (16 9 4 1) ; Unfortunately, defining square-list this way produces the answer list ; in the reverse order of the one desired. Why? Louis then tries to fix ; his bug by interchanging the arguments to cons: ( define ( square-list items ) ( define ( iter things answer ) ( if ( null? things ) answer ( iter ( cdr things ) ( cons answer ( square ( car things )))))) ( iter items nil )) ( square-list ( list 1 2 3 4 )) ; ((((() . 1) . 4) . 9) . 16) ; This doesn\u2019t work either. Explain. ; ==================================== ; Answer ; ==================================== ; (i) Prints in reverse order ; => Let's traverse with (1 2 3 4) ; round things answer ; 1 (1 2 3 4) () ; (2 3 4) (cons (square 1) ()) ; (2 3 4) (1) ; 2 (3 4) (cons (square 2) (1)) ; (3 4) (cons 4 (1)) ; (3 4) (4 1) ; 3 (4) (cons (square 3) (4 1)) ; (4) (9 4 1) ; 4 () (16 9 4 1) ; (ii) Prints nested structures ; round things answer ; 1 (1 2 3 4) () ; (2 3 4) (cons () (square 1)) ; (2 3 4) (cons () 1) ; (2 3 4) (() . 1) ; 2 (3 4) (cons (() . 1) (square 2)) ; (3 4) ((() . 1) . 4) ; ... ... ; ((((() . 1) . 4) . 9) . 16) ; To fix this, we must append two lists instead of `cons`","title":"2.22"},{"location":"SICP/ch2-abstraction-data/2.22/#222","text":"; Louis Reasoner tries to rewrite the first square-list procedure of ; Exercise 2.21 so that it evolves an iterative process: ( define nil ' ()) ( define ( square-list items ) ( define ( iter things answer ) ( if ( null? things ) answer ( iter ( cdr things ) ( cons ( square ( car things )) answer )))) ( iter items nil )) ( square-list ( list 1 2 3 4 )) ; (16 9 4 1) ; Unfortunately, defining square-list this way produces the answer list ; in the reverse order of the one desired. Why? Louis then tries to fix ; his bug by interchanging the arguments to cons: ( define ( square-list items ) ( define ( iter things answer ) ( if ( null? things ) answer ( iter ( cdr things ) ( cons answer ( square ( car things )))))) ( iter items nil )) ( square-list ( list 1 2 3 4 )) ; ((((() . 1) . 4) . 9) . 16) ; This doesn\u2019t work either. Explain. ; ==================================== ; Answer ; ==================================== ; (i) Prints in reverse order ; => Let's traverse with (1 2 3 4) ; round things answer ; 1 (1 2 3 4) () ; (2 3 4) (cons (square 1) ()) ; (2 3 4) (1) ; 2 (3 4) (cons (square 2) (1)) ; (3 4) (cons 4 (1)) ; (3 4) (4 1) ; 3 (4) (cons (square 3) (4 1)) ; (4) (9 4 1) ; 4 () (16 9 4 1) ; (ii) Prints nested structures ; round things answer ; 1 (1 2 3 4) () ; (2 3 4) (cons () (square 1)) ; (2 3 4) (cons () 1) ; (2 3 4) (() . 1) ; 2 (3 4) (cons (() . 1) (square 2)) ; (3 4) ((() . 1) . 4) ; ... ... ; ((((() . 1) . 4) . 9) . 16) ; To fix this, we must append two lists instead of `cons`","title":"2.22"},{"location":"SICP/ch2-abstraction-data/2.23/","text":"2.23 \u00b6 ; The procedure for-each is similar to map. It takes as arguments a procedure ; and a list of elements. However, rather than forming a list of the results, ; for-each just applies the procedure to each of the elements in turn, from ; left to right. The values returned by applying the procedure to the elements ; are not used at all\u2014for-each is used with procedures that perform an action, ; such as printing. For example, ; (for-each (lambda (x) (newline) ; (display x)) ; (list 57 321 88)) ; 57 321 88 ; The value returned by the call to for-each (not illustrated above) can be ; something arbitrary, such as true. Give an implementation of for-each. ( define ( for-each proc items ) ( cond (( null? items ) #t ) ( else ( proc ( car items )) ( for-each proc ( cdr items ))))) ( for-each ( lambda ( x ) ( newline ) ( display x )) ( list 57 321 88 )) ; 57 ; 321 ; 88 ; Value: #t","title":"2.23"},{"location":"SICP/ch2-abstraction-data/2.23/#223","text":"; The procedure for-each is similar to map. It takes as arguments a procedure ; and a list of elements. However, rather than forming a list of the results, ; for-each just applies the procedure to each of the elements in turn, from ; left to right. The values returned by applying the procedure to the elements ; are not used at all\u2014for-each is used with procedures that perform an action, ; such as printing. For example, ; (for-each (lambda (x) (newline) ; (display x)) ; (list 57 321 88)) ; 57 321 88 ; The value returned by the call to for-each (not illustrated above) can be ; something arbitrary, such as true. Give an implementation of for-each. ( define ( for-each proc items ) ( cond (( null? items ) #t ) ( else ( proc ( car items )) ( for-each proc ( cdr items ))))) ( for-each ( lambda ( x ) ( newline ) ( display x )) ( list 57 321 88 )) ; 57 ; 321 ; 88 ; Value: #t","title":"2.23"},{"location":"SICP/ch2-abstraction-data/2.24/","text":"2.24 \u00b6 ; Suppose we evaluate the expression (list 1 (list 2 (list 3 4))). Give the ; result printed by the interpreter, the corresponding box-and-pointer ; structure, and the interpretation of this as a tree. ( list 1 ( list 2 ( list 3 4 ))) ; (i) Result printed by interpreter ; (1 (2 (3 4))) ; (ii) Box-and-pointer structure ; --------- --------- --------- ; (1 (2 (3 4))) -> | * | *-|----> | * | *-|------> | * | *-|---> (4, null) ; --------- --------- --------- ; | | | ; v v v ; (1, null) (2, null) (3, null) ; (iii) Tree structure ; (1 (2 (3 4))) ; * ; (1) * * (2 (3 4)) ; (2) * * (3 4) ; (3)* *(4)","title":"2.24"},{"location":"SICP/ch2-abstraction-data/2.24/#224","text":"; Suppose we evaluate the expression (list 1 (list 2 (list 3 4))). Give the ; result printed by the interpreter, the corresponding box-and-pointer ; structure, and the interpretation of this as a tree. ( list 1 ( list 2 ( list 3 4 ))) ; (i) Result printed by interpreter ; (1 (2 (3 4))) ; (ii) Box-and-pointer structure ; --------- --------- --------- ; (1 (2 (3 4))) -> | * | *-|----> | * | *-|------> | * | *-|---> (4, null) ; --------- --------- --------- ; | | | ; v v v ; (1, null) (2, null) (3, null) ; (iii) Tree structure ; (1 (2 (3 4))) ; * ; (1) * * (2 (3 4)) ; (2) * * (3 4) ; (3)* *(4)","title":"2.24"},{"location":"SICP/ch2-abstraction-data/2.25/","text":"2.25 \u00b6 ; Give combinations of cars and cdrs that will pick 7 from each of the ; following lists: ; (1 3 (5 7) 9) ; ((7)) ; (1 (2 (3 (4 (5 (6 7)))))) ; (i) (1 3 (5 7) 9) ( define a ( list 1 3 ( list 5 7 ) 9 )) ( car ( cdr ( car ( cdr ( cdr a ))))) ;Value: 7 ; (ii) ((7)) ( define b ( list ( list 7 ))) ( car ( car b )) ;Value: 7 ; (iii) (1 (2 (3 (4 (5 (6 7)))))) ( define c ( list 1 ( list 2 ( list 3 ( list 4 ( list 5 ( list 6 7 ))))))) ( car ( cdr ( car ( cdr ( car ( cdr ( car ( cdr ( car ( cdr ( car ( cdr c )))))))))))) ;Value: 7","title":"2.25"},{"location":"SICP/ch2-abstraction-data/2.25/#225","text":"; Give combinations of cars and cdrs that will pick 7 from each of the ; following lists: ; (1 3 (5 7) 9) ; ((7)) ; (1 (2 (3 (4 (5 (6 7)))))) ; (i) (1 3 (5 7) 9) ( define a ( list 1 3 ( list 5 7 ) 9 )) ( car ( cdr ( car ( cdr ( cdr a ))))) ;Value: 7 ; (ii) ((7)) ( define b ( list ( list 7 ))) ( car ( car b )) ;Value: 7 ; (iii) (1 (2 (3 (4 (5 (6 7)))))) ( define c ( list 1 ( list 2 ( list 3 ( list 4 ( list 5 ( list 6 7 ))))))) ( car ( cdr ( car ( cdr ( car ( cdr ( car ( cdr ( car ( cdr ( car ( cdr c )))))))))))) ;Value: 7","title":"2.25"},{"location":"SICP/ch2-abstraction-data/2.26/","text":"2.26 \u00b6 ; Suppose we define x and y to be two lists: ; (define x (list 1 2 3)) ; (define y (list 4 5 6)) ; What result is printed by the interpreter in response to evaluating each of ; the following expressions: ; (append x y) ; (cons x y) ; (list x y) ( define x ( list 1 2 3 )) ( define y ( list 4 5 6 )) ( append x y ) ; (1 2 3 4 5 6) ( cons x y ) ; ((1 2 3) 4 5 6) ( list x y ) ; ((1 2 3) (4 5 6))","title":"2.26"},{"location":"SICP/ch2-abstraction-data/2.26/#226","text":"; Suppose we define x and y to be two lists: ; (define x (list 1 2 3)) ; (define y (list 4 5 6)) ; What result is printed by the interpreter in response to evaluating each of ; the following expressions: ; (append x y) ; (cons x y) ; (list x y) ( define x ( list 1 2 3 )) ( define y ( list 4 5 6 )) ( append x y ) ; (1 2 3 4 5 6) ( cons x y ) ; ((1 2 3) 4 5 6) ( list x y ) ; ((1 2 3) (4 5 6))","title":"2.26"},{"location":"SICP/ch2-abstraction-data/2.27/","text":"2.27 \u00b6 ; Modify your `reverse` procedure of Exercise 2.18 to produce a `deep-reverse` ; procedure that takes a list as argument and returns as its value the list ; with its elements reversed and with all sublists deep-reversed as well. ; For example, ; (define x (list (list 1 2) (list 3 4))) ; x ; ((1 2) (3 4)) ; (reverse x) ; ((3 4) (1 2)) ; (deep-reverse x) ; ((4 3) (2 1)) ( define ( deep-reverse x ) ( cond (( null? x ) x ) (( not ( pair? x )) x ) ( else ( append ( deep-reverse ( cdr x )) ( list ( deep-reverse ( car x ))))))) ( define x ( list ( list 1 2 ) ( list 3 4 ))) ( deep-reverse x ) ; ((4 3) (2 1)) ( define y ( list 1 2 )) ( deep-reverse y ) ; (2 1) ( define z ( list 1 ( list 4 6 ))) ( deep-reverse z ) ; ((6 4) 1) ( define a ( list ( list 1 2 ) 3 )) ( deep-reverse a ) ; (3 (2 1)) ( define b ( list ( list ( list 6 3 ) 4 ) 4 ( list 7 8 ))) ( deep-reverse b ) ; ((8 7) 4 (4 (3 6)))","title":"2.27"},{"location":"SICP/ch2-abstraction-data/2.27/#227","text":"; Modify your `reverse` procedure of Exercise 2.18 to produce a `deep-reverse` ; procedure that takes a list as argument and returns as its value the list ; with its elements reversed and with all sublists deep-reversed as well. ; For example, ; (define x (list (list 1 2) (list 3 4))) ; x ; ((1 2) (3 4)) ; (reverse x) ; ((3 4) (1 2)) ; (deep-reverse x) ; ((4 3) (2 1)) ( define ( deep-reverse x ) ( cond (( null? x ) x ) (( not ( pair? x )) x ) ( else ( append ( deep-reverse ( cdr x )) ( list ( deep-reverse ( car x ))))))) ( define x ( list ( list 1 2 ) ( list 3 4 ))) ( deep-reverse x ) ; ((4 3) (2 1)) ( define y ( list 1 2 )) ( deep-reverse y ) ; (2 1) ( define z ( list 1 ( list 4 6 ))) ( deep-reverse z ) ; ((6 4) 1) ( define a ( list ( list 1 2 ) 3 )) ( deep-reverse a ) ; (3 (2 1)) ( define b ( list ( list ( list 6 3 ) 4 ) 4 ( list 7 8 ))) ( deep-reverse b ) ; ((8 7) 4 (4 (3 6)))","title":"2.27"},{"location":"SICP/ch2-abstraction-data/2.28/","text":"2.28 \u00b6 ; Write a procedure fringe that takes as argument a tree (represented as a list) ; and returns a list whose elements are all the leaves of the tree arranged in ; left-to-right order. For example, ; (define x (list (list 1 2) (list 3 4))) ; (fringe x) ; (1 2 3 4) ; (fringe (list x x)) ; (1 2 3 4 1 2 3 4) ( define ( fringe x ) ( cond (( null? x ) x ) (( not ( pair? x )) ( list x )) ( else ( append ( fringe ( car x )) ( fringe ( cdr x )))))) ( define x ( list ( list 1 2 ) ( list 3 4 ))) ( fringe x ) ; (1 2 3 4) ( fringe ( list x x )) ; (1 2 3 4 1 2 3 4)","title":"2.28"},{"location":"SICP/ch2-abstraction-data/2.28/#228","text":"; Write a procedure fringe that takes as argument a tree (represented as a list) ; and returns a list whose elements are all the leaves of the tree arranged in ; left-to-right order. For example, ; (define x (list (list 1 2) (list 3 4))) ; (fringe x) ; (1 2 3 4) ; (fringe (list x x)) ; (1 2 3 4 1 2 3 4) ( define ( fringe x ) ( cond (( null? x ) x ) (( not ( pair? x )) ( list x )) ( else ( append ( fringe ( car x )) ( fringe ( cdr x )))))) ( define x ( list ( list 1 2 ) ( list 3 4 ))) ( fringe x ) ; (1 2 3 4) ( fringe ( list x x )) ; (1 2 3 4 1 2 3 4)","title":"2.28"},{"location":"SICP/ch2-abstraction-data/2.29/","text":"2.29 \u00b6 ; A binary mobile consists of two branches, a left branch and a right branch. ; Each branch is a rod of a certain length, from which hangs either a weight ; or another binary mobile. We can represent a binary mobile using compound ; data by constructing it from two branches (for example, using list): ( define ( make-mobile left right ) ( list left right )) ; A branch is constructed from a length (which must be a number) together ; with a structure, which may be either a number (representing a simple weight) ; or another mobile: ( define ( make-branch length structure ) ( list length structure )) ; (a) Write the corresponding selectors `left-branch` and `right-branch`, which ; return the branches of a mobile, and `branch-length` and `branch-structure`, ; which return the components of a branch. ; Ans ( define ( left-branch mobile ) ( car mobile )) ( define ( right-branch mobile ) ( car ( cdr mobile ))) ; (cdr x) => (right), (car (right)) => right ( define ( branch-length branch ) ( car branch )) ( define ( branch-structure branch ) ( car ( cdr branch ))) ; (b) Using your selectors, define a procedure `total-weight` that returns the ; total weight of a mobile. ; Ans ( define ( total-weight mobile ) ( cond (( null? mobile ) 0 ) (( not ( pair? mobile )) mobile ) ( else ( + ( total-weight ( branch-structure ( left-branch mobile ))) ( total-weight ( branch-structure ( right-branch mobile ))))))) ; Testing ( define m1 ( make-mobile ( make-branch 5 20 ) ( make-branch 6 25 ))) ( left-branch m1 ) ; (5 20) ( right-branch m1 ) ; (6 25) ( branch-length ( left-branch m1 )) ;Value: 5 ( branch-structure ( left-branch m1 )) ; 20 ( branch-length ( right-branch m1 )) ;Value: 6 ( branch-structure ( right-branch m1 )) ;Value: 25 ( total-weight m1 ) ;Value: 45 (20 + 25) ( define m2 ( make-mobile ( make-branch 5 ( make-mobile ( make-branch 8 22 ) ( make-branch 9 10 ))) ( make-branch 6 25 ))) ( total-weight m2 ) ;Value: 57 (22 + 10 +25) ; (c) A mobile is said to be balanced if the torque applied by its top-left ; branch is equal to that applied by its top-right branch (that is, if ; the length of the left rod multiplied by the weight hanging from that ; rod is equal to the corresponding product for the right side) and if ; each of the submobiles hanging off its branches is balanced. Design a ; predicate that tests whether a binary mobile is balanced. ; Torque of a branch = (length) x (total weight of it's structure) ( define ( torque branch ) ( * ( branch-length branch ) ( total-weight ( branch-structure branch )))) ( define ( is-balanced? mobile ) ( if ( not ( pair? mobile )) #t ; Return true for a plain number ( and ( = ( torque ( left-branch mobile )) ( torque ( right-branch mobile ))) ( is-balanced? ( branch-structure ( left-branch mobile ))) ( is-balanced? ( branch-structure ( right-branch mobile ))))) ) ; Testing ( define b1 ( make-mobile ( make-branch 5 10 ) ( make-branch 25 2 ))) ( is-balanced? b1 ) ;Value: #t (5x10 = 25x2 = 50) ( define b2 ( make-mobile ( make-branch 5 ( make-mobile ( make-branch 1 8 ) ( make-branch 4 2 ))) ( make-branch 25 2 ))) ; Here, ; Torque of right-b2 = 25 x 2 = 50 ; Torque of left-b2 = 5 * (weight of structure(left-b2)) ; = 5 * (8 + 2) ; = 50 ; Also, inside structure(left-b2) ; Torques - (1 x 8) = (4 x 2) = 8 ; Hence, mobile is balanced ( is-balanced? b2 ) ;Value: #t ; (d) Suppose we change the representation of mobiles so that the constructors are ( define ( make-mobile left right ) ( cons left right )) ( define ( make-branch length structure ) ( cons length structure )) ; How much do you need to change your programs to convert to the new ; representation? ; Ans: We need to slightly change the definition of the following ( define ( left-branch mobile ) ( car mobile )) ( define ( right-branch mobile ) ( cdr mobile )) ( define ( branch-length branch ) ( car branch )) ( define ( branch-structure branch ) ( cdr branch )) ; Rest will work as it is, ; Testing ; (Redefine `total-weight`) ( define ( total-weight mobile ) ( cond (( null? mobile ) 0 ) (( not ( pair? mobile )) mobile ) ( else ( + ( total-weight ( branch-structure ( left-branch mobile ))) ( total-weight ( branch-structure ( right-branch mobile ))))))) ( define m3 ( make-mobile ( make-branch 5 20 ) ( make-branch 6 25 ))) ( total-weight m3 ) ;Value: 45","title":"2.29"},{"location":"SICP/ch2-abstraction-data/2.29/#229","text":"; A binary mobile consists of two branches, a left branch and a right branch. ; Each branch is a rod of a certain length, from which hangs either a weight ; or another binary mobile. We can represent a binary mobile using compound ; data by constructing it from two branches (for example, using list): ( define ( make-mobile left right ) ( list left right )) ; A branch is constructed from a length (which must be a number) together ; with a structure, which may be either a number (representing a simple weight) ; or another mobile: ( define ( make-branch length structure ) ( list length structure )) ; (a) Write the corresponding selectors `left-branch` and `right-branch`, which ; return the branches of a mobile, and `branch-length` and `branch-structure`, ; which return the components of a branch. ; Ans ( define ( left-branch mobile ) ( car mobile )) ( define ( right-branch mobile ) ( car ( cdr mobile ))) ; (cdr x) => (right), (car (right)) => right ( define ( branch-length branch ) ( car branch )) ( define ( branch-structure branch ) ( car ( cdr branch ))) ; (b) Using your selectors, define a procedure `total-weight` that returns the ; total weight of a mobile. ; Ans ( define ( total-weight mobile ) ( cond (( null? mobile ) 0 ) (( not ( pair? mobile )) mobile ) ( else ( + ( total-weight ( branch-structure ( left-branch mobile ))) ( total-weight ( branch-structure ( right-branch mobile ))))))) ; Testing ( define m1 ( make-mobile ( make-branch 5 20 ) ( make-branch 6 25 ))) ( left-branch m1 ) ; (5 20) ( right-branch m1 ) ; (6 25) ( branch-length ( left-branch m1 )) ;Value: 5 ( branch-structure ( left-branch m1 )) ; 20 ( branch-length ( right-branch m1 )) ;Value: 6 ( branch-structure ( right-branch m1 )) ;Value: 25 ( total-weight m1 ) ;Value: 45 (20 + 25) ( define m2 ( make-mobile ( make-branch 5 ( make-mobile ( make-branch 8 22 ) ( make-branch 9 10 ))) ( make-branch 6 25 ))) ( total-weight m2 ) ;Value: 57 (22 + 10 +25) ; (c) A mobile is said to be balanced if the torque applied by its top-left ; branch is equal to that applied by its top-right branch (that is, if ; the length of the left rod multiplied by the weight hanging from that ; rod is equal to the corresponding product for the right side) and if ; each of the submobiles hanging off its branches is balanced. Design a ; predicate that tests whether a binary mobile is balanced. ; Torque of a branch = (length) x (total weight of it's structure) ( define ( torque branch ) ( * ( branch-length branch ) ( total-weight ( branch-structure branch )))) ( define ( is-balanced? mobile ) ( if ( not ( pair? mobile )) #t ; Return true for a plain number ( and ( = ( torque ( left-branch mobile )) ( torque ( right-branch mobile ))) ( is-balanced? ( branch-structure ( left-branch mobile ))) ( is-balanced? ( branch-structure ( right-branch mobile ))))) ) ; Testing ( define b1 ( make-mobile ( make-branch 5 10 ) ( make-branch 25 2 ))) ( is-balanced? b1 ) ;Value: #t (5x10 = 25x2 = 50) ( define b2 ( make-mobile ( make-branch 5 ( make-mobile ( make-branch 1 8 ) ( make-branch 4 2 ))) ( make-branch 25 2 ))) ; Here, ; Torque of right-b2 = 25 x 2 = 50 ; Torque of left-b2 = 5 * (weight of structure(left-b2)) ; = 5 * (8 + 2) ; = 50 ; Also, inside structure(left-b2) ; Torques - (1 x 8) = (4 x 2) = 8 ; Hence, mobile is balanced ( is-balanced? b2 ) ;Value: #t ; (d) Suppose we change the representation of mobiles so that the constructors are ( define ( make-mobile left right ) ( cons left right )) ( define ( make-branch length structure ) ( cons length structure )) ; How much do you need to change your programs to convert to the new ; representation? ; Ans: We need to slightly change the definition of the following ( define ( left-branch mobile ) ( car mobile )) ( define ( right-branch mobile ) ( cdr mobile )) ( define ( branch-length branch ) ( car branch )) ( define ( branch-structure branch ) ( cdr branch )) ; Rest will work as it is, ; Testing ; (Redefine `total-weight`) ( define ( total-weight mobile ) ( cond (( null? mobile ) 0 ) (( not ( pair? mobile )) mobile ) ( else ( + ( total-weight ( branch-structure ( left-branch mobile ))) ( total-weight ( branch-structure ( right-branch mobile ))))))) ( define m3 ( make-mobile ( make-branch 5 20 ) ( make-branch 6 25 ))) ( total-weight m3 ) ;Value: 45","title":"2.29"},{"location":"SICP/ch2-abstraction-data/2.30/","text":"2.30 \u00b6 ; Define a procedure square-tree analogous to the square-list procedure of ; Exercise 2.21. That is, square-tree should behave as follows: ; (square-tree ; (list 1 ; (list 2 (list 3 4) 5) ; (list 6 7))) ; (1 (4 (9 16) 25) (36 49)) ; Define square-tree both directly (i.e., without using any higher-order procedures) ; and also by using map and recursion. ; (i) Without using higher-order procedure ( define ( square-tree tree ) ( cond (( null? tree ) tree ) (( not ( pair? tree )) ( square tree )) ( else ( cons ( square-tree ( car tree )) ( square-tree ( cdr tree )))))) ( square-tree ( list 1 ( list 2 ( list 3 4 ) 5 ) ( list 6 7 ))) ;Value 2: (1 (4 (9 16) 25) (36 49)) ; (ii) Using `map` ( define ( square-tree tree ) ( map ( lambda ( sub-tree ) ( if ( pair? sub-tree ) ( square-tree sub-tree ) ( square sub-tree ))) tree )) ( square-tree ( list 1 ( list 2 ( list 3 4 ) 5 ) ( list 6 7 ))) ;Value 3: (1 (4 (9 16) 25) (36 49))","title":"2.30"},{"location":"SICP/ch2-abstraction-data/2.30/#230","text":"; Define a procedure square-tree analogous to the square-list procedure of ; Exercise 2.21. That is, square-tree should behave as follows: ; (square-tree ; (list 1 ; (list 2 (list 3 4) 5) ; (list 6 7))) ; (1 (4 (9 16) 25) (36 49)) ; Define square-tree both directly (i.e., without using any higher-order procedures) ; and also by using map and recursion. ; (i) Without using higher-order procedure ( define ( square-tree tree ) ( cond (( null? tree ) tree ) (( not ( pair? tree )) ( square tree )) ( else ( cons ( square-tree ( car tree )) ( square-tree ( cdr tree )))))) ( square-tree ( list 1 ( list 2 ( list 3 4 ) 5 ) ( list 6 7 ))) ;Value 2: (1 (4 (9 16) 25) (36 49)) ; (ii) Using `map` ( define ( square-tree tree ) ( map ( lambda ( sub-tree ) ( if ( pair? sub-tree ) ( square-tree sub-tree ) ( square sub-tree ))) tree )) ( square-tree ( list 1 ( list 2 ( list 3 4 ) 5 ) ( list 6 7 ))) ;Value 3: (1 (4 (9 16) 25) (36 49))","title":"2.30"},{"location":"SICP/ch2-abstraction-data/2.31/","text":"2.31 \u00b6 ; Abstract your answer to Exercise 2.30 to produce a procedure tree-map with the ; property that square-tree could be defined as ; ; (define (square-tree tree) (tree-map square tree)) ( define ( tree-map f tree ) ( map ( lambda ( sub-tree ) ( if ( pair? sub-tree ) ( tree-map f sub-tree ) ( f sub-tree ))) tree )) ( define ( square-tree tree ) ( tree-map square tree )) ( square-tree ( list 1 ( list 2 ( list 3 4 ) 5 ) ( list 6 7 ))) ;Value 2: (1 (4 (9 16) 25) (36 49))","title":"2.31"},{"location":"SICP/ch2-abstraction-data/2.31/#231","text":"; Abstract your answer to Exercise 2.30 to produce a procedure tree-map with the ; property that square-tree could be defined as ; ; (define (square-tree tree) (tree-map square tree)) ( define ( tree-map f tree ) ( map ( lambda ( sub-tree ) ( if ( pair? sub-tree ) ( tree-map f sub-tree ) ( f sub-tree ))) tree )) ( define ( square-tree tree ) ( tree-map square tree )) ( square-tree ( list 1 ( list 2 ( list 3 4 ) 5 ) ( list 6 7 ))) ;Value 2: (1 (4 (9 16) 25) (36 49))","title":"2.31"},{"location":"SICP/ch2-abstraction-data/2.32/","text":"2.32 \u00b6 ; We can represent a set as a list of distinct elements, and we can represent the ; set of all subsets of the set as a list of lists. For example, if the set is ; (1 2 3), then the set of all subsets is (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)). ; Complete the following definition of a procedure that generates the set of subsets ; of a set and give a clear explanation of why it works: ; ; (define (subsets s) ; (if (null? s) ; (list nil) ; (let ((rest (subsets (cdr s)))) ; (append rest (map \u27e8??\u27e9 rest))))) ( define ( subsets s ) ( if ( null? s ) ( list ' ()) ( let (( rest ( subsets ( cdr s )))) ( append rest ( map ( lambda ( x ) ( cons ( car s ) x )) rest ))))) ( subsets ( list 1 2 3 )) ; (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)) ; Explanation ; ================================== ; Let's say S = (1, 2, 3) ; In our recursive step, ; rest = subset (2, 3) ; subset (2, 3) is actually => {(), (2), (3), (2, 3)} ; Also (car S) = 1 ; If we append subset (2, 3) with \"1\" added to each element of subset(2, 3) ; we get back subset (1, 2, 3) ; i.e. ; x = (1) => subset(2, 3) => {(1), (1 2), (1 3), (1 2 3)} ; y = subset(2, 3) ; x + y = {(1), (1 2), (1 3), (1 2 3), (), (2), (3), (2 3)}","title":"2.32"},{"location":"SICP/ch2-abstraction-data/2.32/#232","text":"; We can represent a set as a list of distinct elements, and we can represent the ; set of all subsets of the set as a list of lists. For example, if the set is ; (1 2 3), then the set of all subsets is (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)). ; Complete the following definition of a procedure that generates the set of subsets ; of a set and give a clear explanation of why it works: ; ; (define (subsets s) ; (if (null? s) ; (list nil) ; (let ((rest (subsets (cdr s)))) ; (append rest (map \u27e8??\u27e9 rest))))) ( define ( subsets s ) ( if ( null? s ) ( list ' ()) ( let (( rest ( subsets ( cdr s )))) ( append rest ( map ( lambda ( x ) ( cons ( car s ) x )) rest ))))) ( subsets ( list 1 2 3 )) ; (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)) ; Explanation ; ================================== ; Let's say S = (1, 2, 3) ; In our recursive step, ; rest = subset (2, 3) ; subset (2, 3) is actually => {(), (2), (3), (2, 3)} ; Also (car S) = 1 ; If we append subset (2, 3) with \"1\" added to each element of subset(2, 3) ; we get back subset (1, 2, 3) ; i.e. ; x = (1) => subset(2, 3) => {(1), (1 2), (1 3), (1 2 3)} ; y = subset(2, 3) ; x + y = {(1), (1 2), (1 3), (1 2 3), (), (2), (3), (2 3)}","title":"2.32"},{"location":"SICP/ch2-abstraction-data/2.33/","text":"2.33 \u00b6 ; Fill in the missing expressions to complete the following definitions of some basic ; list-manipulation operations as accumulations: ; ; (define (map p sequence) ; (accumulate (lambda (x y) <??>) nil sequence)) ; (define (append seq1 seq1) ; (accumulate cons <??> <??>)) ; (define (length sequence) ; (accumulate <??> 0 sequence)) ( define nil ' ()) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( map p sequence ) ( accumulate ( lambda ( x y ) ( cons ( p x ) y )) nil sequence )) ( map square ( list 1 2 3 4 )) ; (1 4 9 16) ( define ( append seq1 seq2 ) ( accumulate cons seq2 seq1 )) ( append ( list 1 2 3 4 ) ( list 5 6 7 8 )) ; (1 2 3 4 5 6 7 8) ( define ( length sequence ) ( accumulate ( lambda ( x y ) ( + 1 y )) 0 sequence )) ( length ( list 1 2 3 5 )) ;Value: 4","title":"2.33"},{"location":"SICP/ch2-abstraction-data/2.33/#233","text":"; Fill in the missing expressions to complete the following definitions of some basic ; list-manipulation operations as accumulations: ; ; (define (map p sequence) ; (accumulate (lambda (x y) <??>) nil sequence)) ; (define (append seq1 seq1) ; (accumulate cons <??> <??>)) ; (define (length sequence) ; (accumulate <??> 0 sequence)) ( define nil ' ()) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( map p sequence ) ( accumulate ( lambda ( x y ) ( cons ( p x ) y )) nil sequence )) ( map square ( list 1 2 3 4 )) ; (1 4 9 16) ( define ( append seq1 seq2 ) ( accumulate cons seq2 seq1 )) ( append ( list 1 2 3 4 ) ( list 5 6 7 8 )) ; (1 2 3 4 5 6 7 8) ( define ( length sequence ) ( accumulate ( lambda ( x y ) ( + 1 y )) 0 sequence )) ( length ( list 1 2 3 5 )) ;Value: 4","title":"2.33"},{"location":"SICP/ch2-abstraction-data/2.34/","text":"2.34 \u00b6 ; Evaluating a polynomial in x at a given value of x can be formulated as an ; accumulation. We evaluate the polynomial, ; a_nx^n + a_(n-1)x^n + ... + a_1x + a_0 ; using a well-known algorithm called Horner\u2019s rule, which structures the ; computation as, ; (... (a_nx + a_(n-1))x + ... a1)x + a_0 ; In other words, we start with an, multiply by x, add a_(n\u22121), multiply by x, ; and so on, until we reach a0 ; Fill in the following template to produce a procedure that evaluates a polynomial ; using Horner\u2019s rule. Assume that the coefficients of the polynomial are arranged ; in a sequence, from a0 through an. ; (define (horner-eval x coefficient-sequence) ; (accumulate (lambda (this-coeff higher-terms) \u27e8??\u27e9) ; 0 ; coefficient-sequence)) ; For example, to compute 1 + 3x + 5x^3 + x^5 at x = 2 you would evaluate ; (horner-eval 2 (list 1 3 0 5 0 1)) ( define nil ' ()) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( horner-eval x coefficient-sequence ) ( accumulate ( lambda ( this-coeff higher-terms ) ( + ( * higher-terms x ) this-coeff )) 0 coefficient-sequence )) ( horner-eval 2 ( list 1 3 0 5 0 1 )) ;Value: 79","title":"2.34"},{"location":"SICP/ch2-abstraction-data/2.34/#234","text":"; Evaluating a polynomial in x at a given value of x can be formulated as an ; accumulation. We evaluate the polynomial, ; a_nx^n + a_(n-1)x^n + ... + a_1x + a_0 ; using a well-known algorithm called Horner\u2019s rule, which structures the ; computation as, ; (... (a_nx + a_(n-1))x + ... a1)x + a_0 ; In other words, we start with an, multiply by x, add a_(n\u22121), multiply by x, ; and so on, until we reach a0 ; Fill in the following template to produce a procedure that evaluates a polynomial ; using Horner\u2019s rule. Assume that the coefficients of the polynomial are arranged ; in a sequence, from a0 through an. ; (define (horner-eval x coefficient-sequence) ; (accumulate (lambda (this-coeff higher-terms) \u27e8??\u27e9) ; 0 ; coefficient-sequence)) ; For example, to compute 1 + 3x + 5x^3 + x^5 at x = 2 you would evaluate ; (horner-eval 2 (list 1 3 0 5 0 1)) ( define nil ' ()) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( horner-eval x coefficient-sequence ) ( accumulate ( lambda ( this-coeff higher-terms ) ( + ( * higher-terms x ) this-coeff )) 0 coefficient-sequence )) ( horner-eval 2 ( list 1 3 0 5 0 1 )) ;Value: 79","title":"2.34"},{"location":"SICP/ch2-abstraction-data/2.35/","text":"2.35 \u00b6 ; Redefine count-leaves from Section 2.2.2 as an accumulation: ; ; (define (count-leaves t) ; (accumulate \u27e8??\u27e9 \u27e8??\u27e9 (map \u27e8??\u27e9 \u27e8??\u27e9))) ( define nil ' ()) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( enumerate-tree tree ) ( cond (( null? tree ) nil ) (( not ( pair? tree )) ( list tree )) ( else ( append ( enumerate-tree ( car tree )) ( enumerate-tree ( cdr tree )))))) ( define ( count-leaves tree ) ( accumulate + 0 ( map ( lambda ( x ) 1 ) ( enumerate-tree tree )))) ( count-leaves ( list 1 2 ( list 3 4 ( list 5 6 )))) ;Value: 6","title":"2.35"},{"location":"SICP/ch2-abstraction-data/2.35/#235","text":"; Redefine count-leaves from Section 2.2.2 as an accumulation: ; ; (define (count-leaves t) ; (accumulate \u27e8??\u27e9 \u27e8??\u27e9 (map \u27e8??\u27e9 \u27e8??\u27e9))) ( define nil ' ()) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( enumerate-tree tree ) ( cond (( null? tree ) nil ) (( not ( pair? tree )) ( list tree )) ( else ( append ( enumerate-tree ( car tree )) ( enumerate-tree ( cdr tree )))))) ( define ( count-leaves tree ) ( accumulate + 0 ( map ( lambda ( x ) 1 ) ( enumerate-tree tree )))) ( count-leaves ( list 1 2 ( list 3 4 ( list 5 6 )))) ;Value: 6","title":"2.35"},{"location":"SICP/ch2-abstraction-data/2.36/","text":"2.36 \u00b6 ; The procedure accumulate-n is similar to accumulate except that it takes as its ; third argument a sequence of sequences, which are all assumed to have the same ; number of elements. It applies the designated accumulation procedure to combine ; all the first elements of the sequences, all the second elements of the sequences, ; and so on, and returns a sequence of the results. For instance, if s is a sequence ; containing four sequences, ((1 2 3) (4 5 6) (7 8 9) (10 11 12)), then the value ; of (accumulate-n + 0 s) should be the sequence (22 26 30). Fill in the missing ; expressions in the following definition of accumulate-n: ; (define (accumulate-n op init seqs) ; (if (null? (car seqs)) ; nil ; (cons (accumulate op init \u27e8??\u27e9) ; (accumulate-n op init \u27e8??\u27e9)))) ( define nil ' ()) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( accumulate-n op initial seqs ) ( if ( null? ( car seqs )) nil ( cons ( accumulate op initial ( map car seqs )) ( accumulate-n op initial ( map cdr seqs ))))) ( accumulate-n + 0 ( list ( list 1 2 3 ) ( list 4 5 6 ) ( list 7 8 9 ) ( list 10 11 12 ))) ; (22 26 30)","title":"2.36"},{"location":"SICP/ch2-abstraction-data/2.36/#236","text":"; The procedure accumulate-n is similar to accumulate except that it takes as its ; third argument a sequence of sequences, which are all assumed to have the same ; number of elements. It applies the designated accumulation procedure to combine ; all the first elements of the sequences, all the second elements of the sequences, ; and so on, and returns a sequence of the results. For instance, if s is a sequence ; containing four sequences, ((1 2 3) (4 5 6) (7 8 9) (10 11 12)), then the value ; of (accumulate-n + 0 s) should be the sequence (22 26 30). Fill in the missing ; expressions in the following definition of accumulate-n: ; (define (accumulate-n op init seqs) ; (if (null? (car seqs)) ; nil ; (cons (accumulate op init \u27e8??\u27e9) ; (accumulate-n op init \u27e8??\u27e9)))) ( define nil ' ()) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( accumulate-n op initial seqs ) ( if ( null? ( car seqs )) nil ( cons ( accumulate op initial ( map car seqs )) ( accumulate-n op initial ( map cdr seqs ))))) ( accumulate-n + 0 ( list ( list 1 2 3 ) ( list 4 5 6 ) ( list 7 8 9 ) ( list 10 11 12 ))) ; (22 26 30)","title":"2.36"},{"location":"SICP/ch2-abstraction-data/2.37/","text":"2.37 \u00b6 ; Suppose we represent vectors v = (v_i) as sequences of numbers, and matrices ; m = (m_{ij}) as sequences of vectors (the rows of the matrix). For example, the ; matrix ; 1 2 3 4 ; 4 5 6 6 ; 6 7 8 9 ; is represented as the sequence ((1 2 3 4) (4 5 6 6) (6 7 8 9)). With this ; representation, we can use sequence operations to concisely express the basic ; matrix and vector operations. These operations (which are described in any book ; on matrix algebra) are the following: ; (dot-product v w) returns the sum \u03a3iviwi; ; (matrix-*-vector m v) returns the vector t, whereti =\u03a3jmijvj; ; (matrix-*-matrix m n) returns the matrix p, wherepij =\u03a3kmiknkj; ; (transpose m) returns the matrix n, wherenij =mji. ; ; We can define the dot product as, ; (define (dot-product v w) ; (accumulate + 0 (map * v w))) ; Fill in the missing expressions in the following procedures for computing ; the other matrix operations. (The procedure accumulate-n is defined in ; Exercise 2.36.) ; (define (matrix-*-vector m v) (map \u27e8??\u27e9 m)) ; (define (transpose mat) (accumulate-n \u27e8??\u27e9 \u27e8??\u27e9 mat)) ; (define (matrix-*-matrix m n) (let ((cols (transpose n))) ; (map \u27e8??\u27e9 m))) ( define nil ' ()) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( accumulate-n op initial seqs ) ( if ( null? ( car seqs )) nil ( cons ( accumulate op initial ( map car seqs )) ( accumulate-n op initial ( map cdr seqs ))))) ; Dot product ( define ( dot-product v w ) ( accumulate + 0 ( map * v w ))) ; Matrix x Vector ( define ( matrix-*-vector m v ) ( map ( lambda ( x ) ( dot-product x v )) m )) ; Transpose ( define ( transpose mat ) ( accumulate-n cons nil mat )) ; Matrix x Matrix ( define ( matrix-*-matrix m n ) ( let (( cols ( transpose n ))) ( map ( lambda ( row ) ( matrix-*-vector cols row )) m ))) ; Testing ( define v1 ( list 1 2 3 4 )) ( define v2 ( list 2 3 4 5 )) ; Dot product v1 \\cdot v2 = 1x2 + 2x3 + 3x4 + 4x5 = 40 ( dot-product v1 v2 ) ;Value: 40 ( define m1 ( list ( list 1 3 4 ) ( list 1 0 1 ) ( list 2 1 4 ))) ( define v3 ( list 1 2 3 )) ; m1 x v3 ( matrix-*-vector m1 v3 ) ;(19 4 16) ( define m2 ( list ( list 0 0 1 ) ( list 2 3 5 ) ( list 1 2 9 ))) ( matrix-*-matrix m1 m2 ) ; ((10 17 52) (1 2 10) (6 11 43)) ( transpose m1 ) ; ((1 1 2) (3 0 1) (4 1 4))","title":"2.37"},{"location":"SICP/ch2-abstraction-data/2.37/#237","text":"; Suppose we represent vectors v = (v_i) as sequences of numbers, and matrices ; m = (m_{ij}) as sequences of vectors (the rows of the matrix). For example, the ; matrix ; 1 2 3 4 ; 4 5 6 6 ; 6 7 8 9 ; is represented as the sequence ((1 2 3 4) (4 5 6 6) (6 7 8 9)). With this ; representation, we can use sequence operations to concisely express the basic ; matrix and vector operations. These operations (which are described in any book ; on matrix algebra) are the following: ; (dot-product v w) returns the sum \u03a3iviwi; ; (matrix-*-vector m v) returns the vector t, whereti =\u03a3jmijvj; ; (matrix-*-matrix m n) returns the matrix p, wherepij =\u03a3kmiknkj; ; (transpose m) returns the matrix n, wherenij =mji. ; ; We can define the dot product as, ; (define (dot-product v w) ; (accumulate + 0 (map * v w))) ; Fill in the missing expressions in the following procedures for computing ; the other matrix operations. (The procedure accumulate-n is defined in ; Exercise 2.36.) ; (define (matrix-*-vector m v) (map \u27e8??\u27e9 m)) ; (define (transpose mat) (accumulate-n \u27e8??\u27e9 \u27e8??\u27e9 mat)) ; (define (matrix-*-matrix m n) (let ((cols (transpose n))) ; (map \u27e8??\u27e9 m))) ( define nil ' ()) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( accumulate-n op initial seqs ) ( if ( null? ( car seqs )) nil ( cons ( accumulate op initial ( map car seqs )) ( accumulate-n op initial ( map cdr seqs ))))) ; Dot product ( define ( dot-product v w ) ( accumulate + 0 ( map * v w ))) ; Matrix x Vector ( define ( matrix-*-vector m v ) ( map ( lambda ( x ) ( dot-product x v )) m )) ; Transpose ( define ( transpose mat ) ( accumulate-n cons nil mat )) ; Matrix x Matrix ( define ( matrix-*-matrix m n ) ( let (( cols ( transpose n ))) ( map ( lambda ( row ) ( matrix-*-vector cols row )) m ))) ; Testing ( define v1 ( list 1 2 3 4 )) ( define v2 ( list 2 3 4 5 )) ; Dot product v1 \\cdot v2 = 1x2 + 2x3 + 3x4 + 4x5 = 40 ( dot-product v1 v2 ) ;Value: 40 ( define m1 ( list ( list 1 3 4 ) ( list 1 0 1 ) ( list 2 1 4 ))) ( define v3 ( list 1 2 3 )) ; m1 x v3 ( matrix-*-vector m1 v3 ) ;(19 4 16) ( define m2 ( list ( list 0 0 1 ) ( list 2 3 5 ) ( list 1 2 9 ))) ( matrix-*-matrix m1 m2 ) ; ((10 17 52) (1 2 10) (6 11 43)) ( transpose m1 ) ; ((1 1 2) (3 0 1) (4 1 4))","title":"2.37"},{"location":"SICP/ch2-abstraction-data/2.38/","text":"2.38 \u00b6 ; The accumulate procedure is also known as fold-right, because it combines ; the first element of the sequence with the result of combining all the ; elements to the right. There is also a fold-left, which is similar to fold-right, ; except that it combines elements working in the opposite direction: ( define ( fold-left op initial sequence ) ( define ( iter result rest ) ( if ( null? rest ) result ( iter ( op result ( car rest )) ( cdr rest )))) ( iter initial sequence )) ; What are the values of ; (fold-right / 1 (list 1 2 3)) ; (fold-left / 1 (list 1 2 3)) ; (fold-right list nil (list 1 2 3)) ; (fold-left list nil (list 1 2 3)) ; ; Give a property that op should satisfy to guarantee that fold-right and fold-left ; will produce the same values for any sequence. ( define nil ' ()) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define fold-right accumulate ) ( fold-right / 1 ( list 1 2 3 )) ;Value: 3/2 (3/2/1) ( fold-left / 1 ( list 1 2 3 )) ;Value: 1/6 (1/2/3) ( fold-right list nil ( list 1 2 3 )) ; (1 (2 (3 ()))) ( fold-left list nil ( list 1 2 3 )) ; (((() 1) 2) 3) ; For `fold-left` and `fold-right` to produce same result, ; `op` should be Commutative and Associative","title":"2.38"},{"location":"SICP/ch2-abstraction-data/2.38/#238","text":"; The accumulate procedure is also known as fold-right, because it combines ; the first element of the sequence with the result of combining all the ; elements to the right. There is also a fold-left, which is similar to fold-right, ; except that it combines elements working in the opposite direction: ( define ( fold-left op initial sequence ) ( define ( iter result rest ) ( if ( null? rest ) result ( iter ( op result ( car rest )) ( cdr rest )))) ( iter initial sequence )) ; What are the values of ; (fold-right / 1 (list 1 2 3)) ; (fold-left / 1 (list 1 2 3)) ; (fold-right list nil (list 1 2 3)) ; (fold-left list nil (list 1 2 3)) ; ; Give a property that op should satisfy to guarantee that fold-right and fold-left ; will produce the same values for any sequence. ( define nil ' ()) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define fold-right accumulate ) ( fold-right / 1 ( list 1 2 3 )) ;Value: 3/2 (3/2/1) ( fold-left / 1 ( list 1 2 3 )) ;Value: 1/6 (1/2/3) ( fold-right list nil ( list 1 2 3 )) ; (1 (2 (3 ()))) ( fold-left list nil ( list 1 2 3 )) ; (((() 1) 2) 3) ; For `fold-left` and `fold-right` to produce same result, ; `op` should be Commutative and Associative","title":"2.38"},{"location":"SICP/ch2-abstraction-data/2.39/","text":"2.39 \u00b6 ; Complete the following definitions of reverse (Exercise 2.18) in terms of ; fold-right and fold-left from Exercise 2.38: ; (define (reverse sequence) ; (fold-right (lambda (x y) \u27e8??\u27e9) nil sequence)) ; (define (reverse sequence) ; (fold-left (lambda (x y) \u27e8??\u27e9) nil sequence)) ( define nil ' ()) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define fold-right accumulate ) ( define ( fold-left op initial sequence ) ( define ( iter result rest ) ( if ( null? rest ) result ( iter ( op result ( car rest )) ( cdr rest )))) ( iter initial sequence )) ( define ( reverse sequence ) ( fold-right ( lambda ( x y ) ( append y ( list x ))) nil sequence )) ( reverse ( list 1 2 3 4 )) ;Value 2: (4 3 2 1) ( define ( reverse sequence ) ( fold-left ( lambda ( x y ) ( cons y x )) nil sequence )) ( reverse ( list 1 2 3 4 )) ;Value 3: (4 3 2 1)","title":"2.39"},{"location":"SICP/ch2-abstraction-data/2.39/#239","text":"; Complete the following definitions of reverse (Exercise 2.18) in terms of ; fold-right and fold-left from Exercise 2.38: ; (define (reverse sequence) ; (fold-right (lambda (x y) \u27e8??\u27e9) nil sequence)) ; (define (reverse sequence) ; (fold-left (lambda (x y) \u27e8??\u27e9) nil sequence)) ( define nil ' ()) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define fold-right accumulate ) ( define ( fold-left op initial sequence ) ( define ( iter result rest ) ( if ( null? rest ) result ( iter ( op result ( car rest )) ( cdr rest )))) ( iter initial sequence )) ( define ( reverse sequence ) ( fold-right ( lambda ( x y ) ( append y ( list x ))) nil sequence )) ( reverse ( list 1 2 3 4 )) ;Value 2: (4 3 2 1) ( define ( reverse sequence ) ( fold-left ( lambda ( x y ) ( cons y x )) nil sequence )) ( reverse ( list 1 2 3 4 )) ;Value 3: (4 3 2 1)","title":"2.39"},{"location":"SICP/ch2-abstraction-data/2.40/","text":"2.40 \u00b6 ; Define a procedure unique-pairs that, given an integer n, generates the sequence ; of pairs (i, j) with 1 \u2264 j < i \u2264 n. Use unique-pairs to simplify the definition ; of prime-sum-pairs given above. ; Define helpers ( define nil ' ()) ( define ( enumarate-interval low high ) ( if ( > low high ) nil ( cons low ( enumarate-interval ( + low 1 ) high )))) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( flatmap proc seq ) ( accumulate append nil ( map proc seq ))) ; Construct `unique-pairs` procedure ( define ( unique-pairs n ) ( flatmap ( lambda ( i ) ( map ( lambda ( j ) ( list i j )) ( enumarate-interval 1 ( - i 1 )))) ( enumarate-interval 1 n ))) ( unique-pairs 6 ) ;Value 2: ((2 1) (3 1) (3 2) (4 1) (4 2) (4 3) (5 1) (5 2) (5 3) (5 4) (6 1) (6 2) (6 3) (6 4) (6 5))","title":"2.40"},{"location":"SICP/ch2-abstraction-data/2.40/#240","text":"; Define a procedure unique-pairs that, given an integer n, generates the sequence ; of pairs (i, j) with 1 \u2264 j < i \u2264 n. Use unique-pairs to simplify the definition ; of prime-sum-pairs given above. ; Define helpers ( define nil ' ()) ( define ( enumarate-interval low high ) ( if ( > low high ) nil ( cons low ( enumarate-interval ( + low 1 ) high )))) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( flatmap proc seq ) ( accumulate append nil ( map proc seq ))) ; Construct `unique-pairs` procedure ( define ( unique-pairs n ) ( flatmap ( lambda ( i ) ( map ( lambda ( j ) ( list i j )) ( enumarate-interval 1 ( - i 1 )))) ( enumarate-interval 1 n ))) ( unique-pairs 6 ) ;Value 2: ((2 1) (3 1) (3 2) (4 1) (4 2) (4 3) (5 1) (5 2) (5 3) (5 4) (6 1) (6 2) (6 3) (6 4) (6 5))","title":"2.40"},{"location":"SICP/ch2-abstraction-data/2.41/","text":"2.41 \u00b6 ; Write a procedure to find all ordered triples of distinct positive integers ; i, j, and k less than or equal to a given integer n that sum to a given ; integer s. ; Define helpers ( define nil ' ()) ( define ( enumarate-interval low high ) ( if ( > low high ) nil ( cons low ( enumarate-interval ( + low 1 ) high )))) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( flatmap proc seq ) ( accumulate append nil ( map proc seq ))) ; Construct `triplets-of-sum` ( define ( triplets-of-sum n s ) ( define enumerate-n ( enumarate-interval 1 n )) ( filter ( lambda ( x ) ( = ( accumulate + 0 x ) s )) ( flatmap ( lambda ( i ) ( flatmap ( lambda ( j ) ( map ( lambda ( k ) ( list i j k )) ( enumarate-interval 1 ( - j 1 )))) ( enumarate-interval 1 ( - i 1 )))) enumerate-n ))) ( triplets-of-sum 6 8 ) ;((4 3 1) (5 2 1)) ( triplets-of-sum 6 9 ) ;((4 3 2) (5 3 1) (6 2 1))","title":"2.41"},{"location":"SICP/ch2-abstraction-data/2.41/#241","text":"; Write a procedure to find all ordered triples of distinct positive integers ; i, j, and k less than or equal to a given integer n that sum to a given ; integer s. ; Define helpers ( define nil ' ()) ( define ( enumarate-interval low high ) ( if ( > low high ) nil ( cons low ( enumarate-interval ( + low 1 ) high )))) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( flatmap proc seq ) ( accumulate append nil ( map proc seq ))) ; Construct `triplets-of-sum` ( define ( triplets-of-sum n s ) ( define enumerate-n ( enumarate-interval 1 n )) ( filter ( lambda ( x ) ( = ( accumulate + 0 x ) s )) ( flatmap ( lambda ( i ) ( flatmap ( lambda ( j ) ( map ( lambda ( k ) ( list i j k )) ( enumarate-interval 1 ( - j 1 )))) ( enumarate-interval 1 ( - i 1 )))) enumerate-n ))) ( triplets-of-sum 6 8 ) ;((4 3 1) (5 2 1)) ( triplets-of-sum 6 9 ) ;((4 3 2) (5 3 1) (6 2 1))","title":"2.41"},{"location":"SICP/ch2-abstraction-data/2.42/","text":"2.42 \u00b6 ; The \u201ceight-queens puzzle\u201d asks how to place eight queens on a chessboard so that ; no queen is in check from any other (i.e., no two queens are in the same row, ; column, or diagonal). One possible solution is shown in Figure 2.8. One way to ; solve the puzzle is to work across the board, placing a queen in each column. ; Once we have placed k\u22121 queens, we must place the kth queen in a position where ; it does not check any of the queens already on the board. We can formulate this ; approach recursively: Assume that we have already generated the sequence of all ; possible ways to place k \u2212 1 queens in the first k \u2212 1 columns of the board. For ; each of these ways, generate an extended set of positions by placing a queen in ; each row of the kth column. Now filter these, keeping only the positions for ; which the queen in the kth column is safe with respect to the other queens. This ; produces the sequence of all ways to place k queens in the first k columns. ; By continuing this process, we will produce not only one solution, but all ; solutions to the puzzle. ; We implement this solution as a procedure queens, which returns a sequence of all ; solutions to the problem of placing n queens on an n \u00d7 n chessboard. queens has ; an internal procedure queen-cols that returns the sequence of all ways to place ; queens in the first k columns of the board. ( define ( queens board-size ) ( define ( queen-cols k ) ( if ( = k 0 ) ( list empty-board ) ( filter ( lambda ( positions ) ( safe? k positions )) ( flatmap ( lambda ( rest-of-queens ) ( map ( lambda ( new-row ) ( adjoin-position new-row k rest-of-queens )) ( enumerate-interval 1 board-size ))) ( queen-cols ( - k 1 )))))) ( queen-cols board-size )) ; In this procedure rest-of-queens is a way to place k \u2212 1 queens in the first ; k \u2212 1 columns, and new-row is a proposed row in which to place the queen for ; the kth column. Complete the program by implementing the representation for ; sets of board positions, including the procedure adjoin-position, which adjoins ; a new row-column position to a set of positions, and empty-board, which represents ; an empty set of positions. You must also write the procedure safe?, which ; determines for a set of positions, whether the queen in the kth column is safe ; with respect to the others. (Note that we need only check whether the new queen ; is safe \u2014 the other queens are already guaranteed safe with respect to each other.) ; Define `enumerate-interval`, and `flatmap` procedures ( define nil ' ()) ( define ( enumerate-interval low high ) ( if ( > low high ) nil ( cons low ( enumerate-interval ( + low 1 ) high )))) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( flatmap proc seq ) ( accumulate append nil ( map proc seq ))) ; (i) Define `empty board` ( define empty-board nil ) ; (ii) Define `safe?` procedure ; ; Let's solve the problem part by part. First of all, the data structure ; of `positions`, i.e. one of the argument to `safe?` is as follows ; ; (((1 1) (3 2) (5 3) (1 4)) ; This means, column 1 => (pos 1) ; column 2 => (pos 3) ; column 3 => (pos 5) ; kth-column 4 => (pos 1) ; i.e. Column 1-3 => queens are already safe ; and we want to test at k=4, 4th column and ; whether position \"1\" is safe or not ; ; We can check against each of Col 1-3, for any dangers ; Here, danger for `kth-column` from `nth-col` means 3 conditions ; 1) Position of nth-col = Position of kth-col => Same row ; 2) Diagonal of nth-col in kth-col = kth-col ; 3) Skew-diagonal of nth-col in kth-col = kth-col ( define ( row-diag row-val row k ) ( + row-val ( - k row ))) ( define ( skew-diag row-val row k ) ( - row-val ( - k row ))) ( define ( pair-safe? p1 p2 ) ( define row ( cadr p1 )) ( define row-val ( car p1 )) ( define k ( cadr p2 )) ( define k-val ( car p2 )) ( not ( or ( = row-val k-val ) ( = ( row-diag row-val row k ) k-val ) ( = ( skew-diag row-val row k ) k-val )))) ( define ( safe? k positions ) ; ((1 1) (3 2) (5 3) (1 4)) => (1 4) - test-value ( define test-value ( last positions )) ( define ( iter x positions ) ( cond (( = x k ) #t ) (( pair-safe? ( car positions ) test-value ) ( iter ( + x 1 ) ( cdr positions ))) ( else #f ) ) ) ( iter 1 positions )) ; In the setting, ((1 1) (3 2) (5 3)) ; we can test which row suites for 4th column (k = 4) ; If we draw the board, we can observe that 2nd row is the only ; suitable position ; Let's test this with `safe?` procedure ( safe? 4 ( list ( list 1 1 ) ( list 3 2 ) ( list 5 3 ) ( list 1 4 ))) ;Value: #f ( safe? 4 ( list ( list 1 1 ) ( list 3 2 ) ( list 5 3 ) ( list 2 4 ))) ;Value: #t ( safe? 4 ( list ( list 1 1 ) ( list 3 2 ) ( list 5 3 ) ( list 3 4 ))) ;Value: #f ( safe? 4 ( list ( list 1 1 ) ( list 3 2 ) ( list 5 3 ) ( list 4 4 ))) ;Value: #f ( safe? 4 ( list ( list 1 1 ) ( list 3 2 ) ( list 5 3 ) ( list 5 4 ))) ;Value: #f ; (iii) Define `adjoin-position` procedure ; Example ; ---------------------- ; Input: new-row = 1 ; k = 4 ; rest-of-queens = ((1 1) (3 2) (5 3)) ; Output: ((1 1) (3 2) (5 3) (1 4)) ( define ( adjoin-position new-row k rest-of-queens ) ( append rest-of-queens ( list ( list new-row k )))) ; Testing for queens 4, 5, 6 ( queens 4 ) ; (((2 1) (4 2) (1 3) (3 4)) ; ((3 1) (1 2) (4 3) (2 4))) => 2 solutions ( queens 5 ) ; (((1 1) (3 2) (5 3) (2 4) (4 5)) ; ((1 1) (4 2) (2 3) (5 4) (3 5)) ; ((2 1) (4 2) (1 3) (3 4) (5 5)) ; ((2 1) (5 2) (3 3) (1 4) (4 5)) ; ((3 1) (1 2) (4 3) (2 4) (5 5)) ; ((3 1) (5 2) (2 3) (4 4) (1 5)) ; ((4 1) (1 2) (3 3) (5 4) (2 5)) ; ((4 1) (2 2) (5 3) (3 4) (1 5)) ; ((5 1) (2 2) (4 3) (1 4) (3 5)) ; ((5 1) (3 2) (1 3) (4 4) (2 5))) => 10 solutions ( queens 6 ) ; (((2 1) (4 2) (6 3) (1 4) (3 5) (5 6)) ; ((3 1) (6 2) (2 3) (5 4) (1 5) (4 6)) ; ((4 1) (1 2) (5 3) (2 4) (6 5) (3 6)) ; ((5 1) (3 2) (1 3) (6 4) (4 5) (2 6))) => 4 solutions","title":"2.42"},{"location":"SICP/ch2-abstraction-data/2.42/#242","text":"; The \u201ceight-queens puzzle\u201d asks how to place eight queens on a chessboard so that ; no queen is in check from any other (i.e., no two queens are in the same row, ; column, or diagonal). One possible solution is shown in Figure 2.8. One way to ; solve the puzzle is to work across the board, placing a queen in each column. ; Once we have placed k\u22121 queens, we must place the kth queen in a position where ; it does not check any of the queens already on the board. We can formulate this ; approach recursively: Assume that we have already generated the sequence of all ; possible ways to place k \u2212 1 queens in the first k \u2212 1 columns of the board. For ; each of these ways, generate an extended set of positions by placing a queen in ; each row of the kth column. Now filter these, keeping only the positions for ; which the queen in the kth column is safe with respect to the other queens. This ; produces the sequence of all ways to place k queens in the first k columns. ; By continuing this process, we will produce not only one solution, but all ; solutions to the puzzle. ; We implement this solution as a procedure queens, which returns a sequence of all ; solutions to the problem of placing n queens on an n \u00d7 n chessboard. queens has ; an internal procedure queen-cols that returns the sequence of all ways to place ; queens in the first k columns of the board. ( define ( queens board-size ) ( define ( queen-cols k ) ( if ( = k 0 ) ( list empty-board ) ( filter ( lambda ( positions ) ( safe? k positions )) ( flatmap ( lambda ( rest-of-queens ) ( map ( lambda ( new-row ) ( adjoin-position new-row k rest-of-queens )) ( enumerate-interval 1 board-size ))) ( queen-cols ( - k 1 )))))) ( queen-cols board-size )) ; In this procedure rest-of-queens is a way to place k \u2212 1 queens in the first ; k \u2212 1 columns, and new-row is a proposed row in which to place the queen for ; the kth column. Complete the program by implementing the representation for ; sets of board positions, including the procedure adjoin-position, which adjoins ; a new row-column position to a set of positions, and empty-board, which represents ; an empty set of positions. You must also write the procedure safe?, which ; determines for a set of positions, whether the queen in the kth column is safe ; with respect to the others. (Note that we need only check whether the new queen ; is safe \u2014 the other queens are already guaranteed safe with respect to each other.) ; Define `enumerate-interval`, and `flatmap` procedures ( define nil ' ()) ( define ( enumerate-interval low high ) ( if ( > low high ) nil ( cons low ( enumerate-interval ( + low 1 ) high )))) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( flatmap proc seq ) ( accumulate append nil ( map proc seq ))) ; (i) Define `empty board` ( define empty-board nil ) ; (ii) Define `safe?` procedure ; ; Let's solve the problem part by part. First of all, the data structure ; of `positions`, i.e. one of the argument to `safe?` is as follows ; ; (((1 1) (3 2) (5 3) (1 4)) ; This means, column 1 => (pos 1) ; column 2 => (pos 3) ; column 3 => (pos 5) ; kth-column 4 => (pos 1) ; i.e. Column 1-3 => queens are already safe ; and we want to test at k=4, 4th column and ; whether position \"1\" is safe or not ; ; We can check against each of Col 1-3, for any dangers ; Here, danger for `kth-column` from `nth-col` means 3 conditions ; 1) Position of nth-col = Position of kth-col => Same row ; 2) Diagonal of nth-col in kth-col = kth-col ; 3) Skew-diagonal of nth-col in kth-col = kth-col ( define ( row-diag row-val row k ) ( + row-val ( - k row ))) ( define ( skew-diag row-val row k ) ( - row-val ( - k row ))) ( define ( pair-safe? p1 p2 ) ( define row ( cadr p1 )) ( define row-val ( car p1 )) ( define k ( cadr p2 )) ( define k-val ( car p2 )) ( not ( or ( = row-val k-val ) ( = ( row-diag row-val row k ) k-val ) ( = ( skew-diag row-val row k ) k-val )))) ( define ( safe? k positions ) ; ((1 1) (3 2) (5 3) (1 4)) => (1 4) - test-value ( define test-value ( last positions )) ( define ( iter x positions ) ( cond (( = x k ) #t ) (( pair-safe? ( car positions ) test-value ) ( iter ( + x 1 ) ( cdr positions ))) ( else #f ) ) ) ( iter 1 positions )) ; In the setting, ((1 1) (3 2) (5 3)) ; we can test which row suites for 4th column (k = 4) ; If we draw the board, we can observe that 2nd row is the only ; suitable position ; Let's test this with `safe?` procedure ( safe? 4 ( list ( list 1 1 ) ( list 3 2 ) ( list 5 3 ) ( list 1 4 ))) ;Value: #f ( safe? 4 ( list ( list 1 1 ) ( list 3 2 ) ( list 5 3 ) ( list 2 4 ))) ;Value: #t ( safe? 4 ( list ( list 1 1 ) ( list 3 2 ) ( list 5 3 ) ( list 3 4 ))) ;Value: #f ( safe? 4 ( list ( list 1 1 ) ( list 3 2 ) ( list 5 3 ) ( list 4 4 ))) ;Value: #f ( safe? 4 ( list ( list 1 1 ) ( list 3 2 ) ( list 5 3 ) ( list 5 4 ))) ;Value: #f ; (iii) Define `adjoin-position` procedure ; Example ; ---------------------- ; Input: new-row = 1 ; k = 4 ; rest-of-queens = ((1 1) (3 2) (5 3)) ; Output: ((1 1) (3 2) (5 3) (1 4)) ( define ( adjoin-position new-row k rest-of-queens ) ( append rest-of-queens ( list ( list new-row k )))) ; Testing for queens 4, 5, 6 ( queens 4 ) ; (((2 1) (4 2) (1 3) (3 4)) ; ((3 1) (1 2) (4 3) (2 4))) => 2 solutions ( queens 5 ) ; (((1 1) (3 2) (5 3) (2 4) (4 5)) ; ((1 1) (4 2) (2 3) (5 4) (3 5)) ; ((2 1) (4 2) (1 3) (3 4) (5 5)) ; ((2 1) (5 2) (3 3) (1 4) (4 5)) ; ((3 1) (1 2) (4 3) (2 4) (5 5)) ; ((3 1) (5 2) (2 3) (4 4) (1 5)) ; ((4 1) (1 2) (3 3) (5 4) (2 5)) ; ((4 1) (2 2) (5 3) (3 4) (1 5)) ; ((5 1) (2 2) (4 3) (1 4) (3 5)) ; ((5 1) (3 2) (1 3) (4 4) (2 5))) => 10 solutions ( queens 6 ) ; (((2 1) (4 2) (6 3) (1 4) (3 5) (5 6)) ; ((3 1) (6 2) (2 3) (5 4) (1 5) (4 6)) ; ((4 1) (1 2) (5 3) (2 4) (6 5) (3 6)) ; ((5 1) (3 2) (1 3) (6 4) (4 5) (2 6))) => 4 solutions","title":"2.42"},{"location":"SICP/ch2-abstraction-data/2.43/","text":"2.43 \u00b6 ; Louis Reasoner is having a terrible time doing Exercise 2.42. His queens ; procedure seems to work, but it runs extremely slowly. (Louis never does ; manage to wait long enough for it to solve even the 6 \u00d7 6 case.) When Louis ; asks Eva Lu Ator for help, she points out that he has interchanged the order ; of the nested mappings in the flatmap, writing it as ; ; (flatmap ; (lambda (new-row) ; (map (lambda (rest-of-queens) ; (adjoin-position new-row k rest-of-queens)) ; (queen-cols (- k 1)))) ; (enumerate-interval 1 board-size)) ; ; Explain why this interchange makes the program run slowly. Estimate how long ; it will take Louis\u2019s program to solve the eight-queens puzzle, assuming that ; the program in Exercise 2.42 solves the puzzle in time T. ; Answer ; ============================================== ; In Louis's program, position of `queen-cols` and `enumerate-interval` is ; exchanged. Hence for every item in `enumerate-interval`, `queen-cols` gets ; called. Hence during every recursion, it is calculated `board-size` times ; There is unnecessary duplication of (size^size) times ; If previous program takes time T, we have (size^size) x T for Louis's program","title":"2.43"},{"location":"SICP/ch2-abstraction-data/2.43/#243","text":"; Louis Reasoner is having a terrible time doing Exercise 2.42. His queens ; procedure seems to work, but it runs extremely slowly. (Louis never does ; manage to wait long enough for it to solve even the 6 \u00d7 6 case.) When Louis ; asks Eva Lu Ator for help, she points out that he has interchanged the order ; of the nested mappings in the flatmap, writing it as ; ; (flatmap ; (lambda (new-row) ; (map (lambda (rest-of-queens) ; (adjoin-position new-row k rest-of-queens)) ; (queen-cols (- k 1)))) ; (enumerate-interval 1 board-size)) ; ; Explain why this interchange makes the program run slowly. Estimate how long ; it will take Louis\u2019s program to solve the eight-queens puzzle, assuming that ; the program in Exercise 2.42 solves the puzzle in time T. ; Answer ; ============================================== ; In Louis's program, position of `queen-cols` and `enumerate-interval` is ; exchanged. Hence for every item in `enumerate-interval`, `queen-cols` gets ; called. Hence during every recursion, it is calculated `board-size` times ; There is unnecessary duplication of (size^size) times ; If previous program takes time T, we have (size^size) x T for Louis's program","title":"2.43"},{"location":"SICP/ch2-abstraction-data/2.44/","text":"2.44 \u00b6 ; Define the procedure up-split used by corner- split. It is similar to right-split, except that ; it switches the roles of below and beside. # lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ( define wave einstein ) ; Make compatible with the text book ( define ( up-split painter n ) ( if ( = n 0 ) painter ( let (( smaller ( up-split painter ( - n 1 )))) ( below painter ( beside smaller smaller ))))) ; Testing ( define us1 ( up-split wave 3 )) ( paint us1 )","title":"2.44"},{"location":"SICP/ch2-abstraction-data/2.44/#244","text":"; Define the procedure up-split used by corner- split. It is similar to right-split, except that ; it switches the roles of below and beside. # lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ( define wave einstein ) ; Make compatible with the text book ( define ( up-split painter n ) ( if ( = n 0 ) painter ( let (( smaller ( up-split painter ( - n 1 )))) ( below painter ( beside smaller smaller ))))) ; Testing ( define us1 ( up-split wave 3 )) ( paint us1 )","title":"2.44"},{"location":"SICP/ch2-abstraction-data/2.45/","text":"2.45 \u00b6 ; right-split and up-split can be expressed as instances of a general splitting operation. Define a procedure ; split with the property that evaluating ; (define right-split (split beside below)) ; (define up-split (split below beside)) ; produces procedures right-split and up-split with the same behaviors as the ones already defined. # lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ( define wave einstein ) ; Make compatible with the text book ( define ( split s1 s2 ) ( define ( splitter painter n ) ( if ( = n 0 ) painter ( let (( smaller ( splitter painter ( - n 1 )))) ( s1 painter ( s2 smaller smaller ))))) ( lambda ( painter n ) ( splitter painter n ))) ( define right-split ( split beside below )) ( define up-split ( split below beside )) ( define rs3 ( right-split wave 3 )) ( display \"Right split\\n\" ) ( paint rs3 ) ( define us3 ( up-split wave 3 )) ( display \"\\nUp split\\n\" ) ( paint us3 )","title":"2.45"},{"location":"SICP/ch2-abstraction-data/2.45/#245","text":"; right-split and up-split can be expressed as instances of a general splitting operation. Define a procedure ; split with the property that evaluating ; (define right-split (split beside below)) ; (define up-split (split below beside)) ; produces procedures right-split and up-split with the same behaviors as the ones already defined. # lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ( define wave einstein ) ; Make compatible with the text book ( define ( split s1 s2 ) ( define ( splitter painter n ) ( if ( = n 0 ) painter ( let (( smaller ( splitter painter ( - n 1 )))) ( s1 painter ( s2 smaller smaller ))))) ( lambda ( painter n ) ( splitter painter n ))) ( define right-split ( split beside below )) ( define up-split ( split below beside )) ( define rs3 ( right-split wave 3 )) ( display \"Right split\\n\" ) ( paint rs3 ) ( define us3 ( up-split wave 3 )) ( display \"\\nUp split\\n\" ) ( paint us3 )","title":"2.45"},{"location":"SICP/ch2-abstraction-data/2.46/","text":"2.46 \u00b6 ; A two-dimensional vector v running from the origin to a point can be represented ; as a pair consisting of an x-coordinate and a y-coordinate. Implement a data ; abstraction for vectors by giving a constructor make-vect and corresponding ; selectors xcor-vect and ycor-vect. In terms of your selectors and constructor, ; implement procedures add-vect, sub-vect, and scale-vect that perform the ; operations vector addition, vector subtraction, and multiplying a vector by a ; scalar: ; (x1,y1)+(x2,y2)=(x1 +x2,y1 +y2), ; (x1,y1)\u2212(x2,y2)=(x1 \u2212x2,y1 \u2212y2), ; s \u00b7 (x , y) = (sx , sy). ( define ( make-vect x y ) ( cons x y )) ( define ( xcor-vect v ) ( car v )) ( define ( ycor-vect v ) ( cdr v )) ; Vector operaitons ( define ( add-vect v1 v2 ) ( make-vect ( + ( xcor-vect v1 ) ( xcor-vect v2 )) ( + ( ycor-vect v1 ) ( ycor-vect v2 )))) ( define ( sub-vect v1 v2 ) ( make-vect ( - ( xcor-vect v1 ) ( xcor-vect v2 )) ( - ( ycor-vect v1 ) ( ycor-vect v2 )))) ( define ( scale-vect s vect ) ( make-vect ( * s ( xcor-vect vect )) ( * s ( ycor-vect vect )))) ; Testing ( add-vect ( make-vect 1 3 ) ( make-vect 2 8 )) ;(3 . 11) ( sub-vect ( make-vect 2 5 ) ( make-vect 0 3 )) ;(2 . 2) ( scale-vect 4 ( make-vect 3 5 )) ;(12 . 20)","title":"2.46"},{"location":"SICP/ch2-abstraction-data/2.46/#246","text":"; A two-dimensional vector v running from the origin to a point can be represented ; as a pair consisting of an x-coordinate and a y-coordinate. Implement a data ; abstraction for vectors by giving a constructor make-vect and corresponding ; selectors xcor-vect and ycor-vect. In terms of your selectors and constructor, ; implement procedures add-vect, sub-vect, and scale-vect that perform the ; operations vector addition, vector subtraction, and multiplying a vector by a ; scalar: ; (x1,y1)+(x2,y2)=(x1 +x2,y1 +y2), ; (x1,y1)\u2212(x2,y2)=(x1 \u2212x2,y1 \u2212y2), ; s \u00b7 (x , y) = (sx , sy). ( define ( make-vect x y ) ( cons x y )) ( define ( xcor-vect v ) ( car v )) ( define ( ycor-vect v ) ( cdr v )) ; Vector operaitons ( define ( add-vect v1 v2 ) ( make-vect ( + ( xcor-vect v1 ) ( xcor-vect v2 )) ( + ( ycor-vect v1 ) ( ycor-vect v2 )))) ( define ( sub-vect v1 v2 ) ( make-vect ( - ( xcor-vect v1 ) ( xcor-vect v2 )) ( - ( ycor-vect v1 ) ( ycor-vect v2 )))) ( define ( scale-vect s vect ) ( make-vect ( * s ( xcor-vect vect )) ( * s ( ycor-vect vect )))) ; Testing ( add-vect ( make-vect 1 3 ) ( make-vect 2 8 )) ;(3 . 11) ( sub-vect ( make-vect 2 5 ) ( make-vect 0 3 )) ;(2 . 2) ( scale-vect 4 ( make-vect 3 5 )) ;(12 . 20)","title":"2.46"},{"location":"SICP/ch2-abstraction-data/2.47/","text":"2.47 \u00b6 ; Here are two possible constructors for frames: ; (define (make-frame origin edge1 edge2) (list origin edge1 edge2)) ; (define (make-frame origin edge1 edge2) (cons origin (cons edge1 edge2))) ; For each constructor supply the appropriate selectors to produce an implementation for frames. ( define ( make-vect x y ) ( cons x y )) ( define ( xcor-vect v ) ( car v )) ( define ( ycor-vect v ) ( cdr v )) ; Implementation 1 ( define ( make-frame origin edge1 edge2 ) ( list origin edge1 edge2 )) ( define ( frame-origin frame ) ( car frame )) ( define ( frame-edge1 frame ) ( cadr frame )) ( define ( frame-edge2 frame ) ( cadr ( cdr frame ))) ( define f1 ( make-frame ( make-vect 1 1 ) ( make-vect 2 3 ) ( make-vect 7 8 ))) ; ((1 . 1) (2 . 3) (7 . 8)) ( frame-origin f1 ) ; (1 . 1) ( frame-edge1 f1 ) ; (2 . 3) ( frame-edge2 f1 ) ; (7 . 8) ; Implementation 2 ( define ( make-frame origin edge1 edge2 ) ( cons origin ( cons edge1 edge2 ))) ( define ( frame-origin frame ) ( car frame )) ( define ( frame-edge1 frame ) ( cadr frame )) ( define ( frame-edge2 frame ) ( cdr ( cdr frame ))) ( define f2 ( make-frame ( make-vect 1 1 ) ( make-vect 2 3 ) ( make-vect 7 8 ))) ; ((1 . 1) (2 . 3) 7 . 8) ( frame-origin f2 ) ; (1 . 1) ( frame-edge1 f2 ) ; (2 . 3) ( frame-edge2 f2 ) ; (7 . 8)","title":"2.47"},{"location":"SICP/ch2-abstraction-data/2.47/#247","text":"; Here are two possible constructors for frames: ; (define (make-frame origin edge1 edge2) (list origin edge1 edge2)) ; (define (make-frame origin edge1 edge2) (cons origin (cons edge1 edge2))) ; For each constructor supply the appropriate selectors to produce an implementation for frames. ( define ( make-vect x y ) ( cons x y )) ( define ( xcor-vect v ) ( car v )) ( define ( ycor-vect v ) ( cdr v )) ; Implementation 1 ( define ( make-frame origin edge1 edge2 ) ( list origin edge1 edge2 )) ( define ( frame-origin frame ) ( car frame )) ( define ( frame-edge1 frame ) ( cadr frame )) ( define ( frame-edge2 frame ) ( cadr ( cdr frame ))) ( define f1 ( make-frame ( make-vect 1 1 ) ( make-vect 2 3 ) ( make-vect 7 8 ))) ; ((1 . 1) (2 . 3) (7 . 8)) ( frame-origin f1 ) ; (1 . 1) ( frame-edge1 f1 ) ; (2 . 3) ( frame-edge2 f1 ) ; (7 . 8) ; Implementation 2 ( define ( make-frame origin edge1 edge2 ) ( cons origin ( cons edge1 edge2 ))) ( define ( frame-origin frame ) ( car frame )) ( define ( frame-edge1 frame ) ( cadr frame )) ( define ( frame-edge2 frame ) ( cdr ( cdr frame ))) ( define f2 ( make-frame ( make-vect 1 1 ) ( make-vect 2 3 ) ( make-vect 7 8 ))) ; ((1 . 1) (2 . 3) 7 . 8) ( frame-origin f2 ) ; (1 . 1) ( frame-edge1 f2 ) ; (2 . 3) ( frame-edge2 f2 ) ; (7 . 8)","title":"2.47"},{"location":"SICP/ch2-abstraction-data/2.48/","text":"2.48 \u00b6 ; A directed line segment in the plane can be represented as a pair of vectors \u2014 ; the vector running from the origin to the start-point of the segment, and the ; vector running from the origin to the end-point of the segment. Use your vector ; representation from Exercise 2.46 to define a representation for segments with ; a constructor make-segment and selectors start-segment and end-segment. ( define ( make-vect x y ) ( cons x y )) ( define ( make-segment v1 v2 ) ( cons v1 v2 )) ( define ( start-segment segment ) ( car segment )) ( define ( end-segment segment ) ( cdr segment )) ; Testing ( define s1 ( make-segment ( make-vect 1 2 ) ( make-vect 2 3 ))) ( start-segment s1 ) ; (1 . 2) ( end-segment s1 ) ; (2 . 3)","title":"2.48"},{"location":"SICP/ch2-abstraction-data/2.48/#248","text":"; A directed line segment in the plane can be represented as a pair of vectors \u2014 ; the vector running from the origin to the start-point of the segment, and the ; vector running from the origin to the end-point of the segment. Use your vector ; representation from Exercise 2.46 to define a representation for segments with ; a constructor make-segment and selectors start-segment and end-segment. ( define ( make-vect x y ) ( cons x y )) ( define ( make-segment v1 v2 ) ( cons v1 v2 )) ( define ( start-segment segment ) ( car segment )) ( define ( end-segment segment ) ( cdr segment )) ; Testing ( define s1 ( make-segment ( make-vect 1 2 ) ( make-vect 2 3 ))) ( start-segment s1 ) ; (1 . 2) ( end-segment s1 ) ; (2 . 3)","title":"2.48"},{"location":"SICP/ch2-abstraction-data/2.49/","text":"2.49 \u00b6 ; Use segments->painter to define the following primitive painters ; a. The painter that draws the outline of the designated frame. ; b. The painter that draws an \u201cX\u201d byconnecting opposite corners of the frame. ; c. The painter that draws a diamond shape by connecting the midpoints of the sides of the frame. ; d. The wave painter. # lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ; NOTE: Procedure `segments->painter` is already preset in \"soegaard\" package ( define ( make-vect x y ) ( cons x y )) ( define ( xcor-vect v ) ( car v )) ( define ( ycor-vect v ) ( cdr v )) ( define ( make-segment v1 v2 ) ( cons v1 v2 )) ( define ( start-segment segment ) ( car segment )) ( define ( end-segment segment ) ( cdr segment )) ; (a) Outline of a frame (unit square) ; For some reason, giving \"1.0\" does not render a few edges, hence using 0.99 instead ( define outline-list ( list ( make-segment ( make-vect 0 0 ) ( make-vect 0 0.99 )) ( make-segment ( make-vect 0 0 ) ( make-vect 0.99 0 )) ( make-segment ( make-vect 0.99 0 ) ( make-vect 0.99 0.99 )) ( make-segment ( make-vect 0 0.99 ) ( make-vect 0.99 0.99 )))) ( define outline ( segments->painter outline-list )) ( display \"Outline of frame\\n\" ) ( paint outline ) ; (b) \"X\" mark ( define x-list ( list ( make-segment ( make-vect 0 0 ) ( make-vect 1 1 )) ( make-segment ( make-vect 0 1 ) ( make-vect 1 0 )))) ( define x-mark ( segments->painter x-list )) ( display \"\\nX-mark\\n\" ) ( paint x-mark ) ; (c) Diamond ( define diamond-list ( list ( make-segment ( make-vect 0 0.5 ) ( make-vect 0.5 0 )) ( make-segment ( make-vect 0 0.5 ) ( make-vect 0.5 1 )) ( make-segment ( make-vect 0.5 1 ) ( make-vect 1 0.5 )) ( make-segment ( make-vect 1 0.5 ) ( make-vect 0.5 0 )))) ( define diamond ( segments->painter diamond-list )) ( display \"\\nDiamond\\n\" ) ( paint diamond ) ; (d) Wave shape ; Suggestion: Draw the shape on 0-100 rough scale and figure out line segments :) ; Also, excuse me for the wierd shape ( define wave-list ( list ( make-segment ( make-vect 0.01 0.8 ) ( make-vect 0.1 0.56 )) ( make-segment ( make-vect 0.1 0.56 ) ( make-vect 0.2 0.6 )) ( make-segment ( make-vect 0.2 0.6 ) ( make-vect 0.3 0.58 )) ( make-segment ( make-vect 0.3 0.58 ) ( make-vect 0.2 0.75 )) ( make-segment ( make-vect 0.2 0.75 ) ( make-vect 0.4 1 )) ( make-segment ( make-vect 0.6 1 ) ( make-vect 0.8 0.75 )) ( make-segment ( make-vect 0.8 0.75 ) ( make-vect 0.7 0.58 )) ( make-segment ( make-vect 0.7 0.58 ) ( make-vect 0.8 0.6 )) ( make-segment ( make-vect 0.8 0.6 ) ( make-vect 1 0.4 )) ( make-segment ( make-vect 0 0.61 ) ( make-vect 0.1 0.35 )) ( make-segment ( make-vect 0.1 0.35 ) ( make-vect 0.2 0.5 )) ( make-segment ( make-vect 0.2 0.5 ) ( make-vect 0.3 0.35 )) ( make-segment ( make-vect 0.3 0.35 ) ( make-vect 0.2 0 )) ( make-segment ( make-vect 0.3 0 ) ( make-vect 0.5 0.25 )) ( make-segment ( make-vect 0.5 0.25 ) ( make-vect 0.65 0 )) ( make-segment ( make-vect 0.75 0 ) ( make-vect 0.6 0.4 )) ( make-segment ( make-vect 0.6 0.4 ) ( make-vect 1 0.2 )))) ( define wave ( segments->painter wave-list )) ( display \"\\nWave\\n\" ) ( paint wave )","title":"2.49"},{"location":"SICP/ch2-abstraction-data/2.49/#249","text":"; Use segments->painter to define the following primitive painters ; a. The painter that draws the outline of the designated frame. ; b. The painter that draws an \u201cX\u201d byconnecting opposite corners of the frame. ; c. The painter that draws a diamond shape by connecting the midpoints of the sides of the frame. ; d. The wave painter. # lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ; NOTE: Procedure `segments->painter` is already preset in \"soegaard\" package ( define ( make-vect x y ) ( cons x y )) ( define ( xcor-vect v ) ( car v )) ( define ( ycor-vect v ) ( cdr v )) ( define ( make-segment v1 v2 ) ( cons v1 v2 )) ( define ( start-segment segment ) ( car segment )) ( define ( end-segment segment ) ( cdr segment )) ; (a) Outline of a frame (unit square) ; For some reason, giving \"1.0\" does not render a few edges, hence using 0.99 instead ( define outline-list ( list ( make-segment ( make-vect 0 0 ) ( make-vect 0 0.99 )) ( make-segment ( make-vect 0 0 ) ( make-vect 0.99 0 )) ( make-segment ( make-vect 0.99 0 ) ( make-vect 0.99 0.99 )) ( make-segment ( make-vect 0 0.99 ) ( make-vect 0.99 0.99 )))) ( define outline ( segments->painter outline-list )) ( display \"Outline of frame\\n\" ) ( paint outline ) ; (b) \"X\" mark ( define x-list ( list ( make-segment ( make-vect 0 0 ) ( make-vect 1 1 )) ( make-segment ( make-vect 0 1 ) ( make-vect 1 0 )))) ( define x-mark ( segments->painter x-list )) ( display \"\\nX-mark\\n\" ) ( paint x-mark ) ; (c) Diamond ( define diamond-list ( list ( make-segment ( make-vect 0 0.5 ) ( make-vect 0.5 0 )) ( make-segment ( make-vect 0 0.5 ) ( make-vect 0.5 1 )) ( make-segment ( make-vect 0.5 1 ) ( make-vect 1 0.5 )) ( make-segment ( make-vect 1 0.5 ) ( make-vect 0.5 0 )))) ( define diamond ( segments->painter diamond-list )) ( display \"\\nDiamond\\n\" ) ( paint diamond ) ; (d) Wave shape ; Suggestion: Draw the shape on 0-100 rough scale and figure out line segments :) ; Also, excuse me for the wierd shape ( define wave-list ( list ( make-segment ( make-vect 0.01 0.8 ) ( make-vect 0.1 0.56 )) ( make-segment ( make-vect 0.1 0.56 ) ( make-vect 0.2 0.6 )) ( make-segment ( make-vect 0.2 0.6 ) ( make-vect 0.3 0.58 )) ( make-segment ( make-vect 0.3 0.58 ) ( make-vect 0.2 0.75 )) ( make-segment ( make-vect 0.2 0.75 ) ( make-vect 0.4 1 )) ( make-segment ( make-vect 0.6 1 ) ( make-vect 0.8 0.75 )) ( make-segment ( make-vect 0.8 0.75 ) ( make-vect 0.7 0.58 )) ( make-segment ( make-vect 0.7 0.58 ) ( make-vect 0.8 0.6 )) ( make-segment ( make-vect 0.8 0.6 ) ( make-vect 1 0.4 )) ( make-segment ( make-vect 0 0.61 ) ( make-vect 0.1 0.35 )) ( make-segment ( make-vect 0.1 0.35 ) ( make-vect 0.2 0.5 )) ( make-segment ( make-vect 0.2 0.5 ) ( make-vect 0.3 0.35 )) ( make-segment ( make-vect 0.3 0.35 ) ( make-vect 0.2 0 )) ( make-segment ( make-vect 0.3 0 ) ( make-vect 0.5 0.25 )) ( make-segment ( make-vect 0.5 0.25 ) ( make-vect 0.65 0 )) ( make-segment ( make-vect 0.75 0 ) ( make-vect 0.6 0.4 )) ( make-segment ( make-vect 0.6 0.4 ) ( make-vect 1 0.2 )))) ( define wave ( segments->painter wave-list )) ( display \"\\nWave\\n\" ) ( paint wave )","title":"2.49"},{"location":"SICP/ch2-abstraction-data/2.50/","text":"2.50 \u00b6 ; Define the transformation flip-horiz, which flips painters horizontally, ; and transformations that rotate painters counterclockwise by 180 degrees ; and 270 degrees. # lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ; Helpers ( define ( xcor-vect v ) ( car v )) ( define ( ycor-vect v ) ( cdr v )) ( define ( sub-vect v1 v2 ) ( make-vect ( - ( xcor-vect v1 ) ( xcor-vect v2 )) ( - ( ycor-vect v1 ) ( ycor-vect v2 )))) ( define ( transform-painter painter origin corner1 corner2 ) ( lambda ( frame ) ( let (( m ( frame-coord-map frame ))) ( let (( new-origin ( m origin ))) ( painter ( make-frame new-origin ( sub-vect ( m corner1 ) new-origin ) ( sub-vect ( m corner2 ) new-origin ))))))) ; (i) Flip horizontally ( define ( flip-horiz painter ) ( transform-painter painter ( make-vect 1 0 ) ( make-vect 0 0 ) ( make-vect 1 1 ))) ; Test horizontal flip ( define f1-list ( list ( make-segment ( make-vect 0.3 0.3 ) ( make-vect 0.3 0.7 )) ( make-segment ( make-vect 0.3 0.7 ) ( make-vect 0.7 0.5 )) ( make-segment ( make-vect 0.7 0.5 ) ( make-vect 0.3 0.3 )))) ( define f1 ( segments->painter f1-list )) ( display \"\\nFrame f1\\n\" ) ( paint f1 ) ( display \"\\nFrame flipped horizontally f1\\n\" ) ( paint ( flip-horiz f1 )) ; (ii) Counterclockwise 180deg ( define ( rotate180 painter ) ( transform-painter painter ( make-vect 1 1 ) ( make-vect 0 1 ) ( make-vect 1 0 ))) ( display \"\\nFrame rotate counter clockwise 180deg f1\\n\" ) ( paint ( rotate180 f1 )) ; (iii) Counterclockwise 270deg ( define ( rotate270 painter ) ( transform-painter painter ( make-vect 0 1 ) ( make-vect 0 0 ) ( make-vect 1 1 ))) ( display \"\\nFrame rotate counter clockwise 270deg f1\\n\" ) ( paint ( rotate270 f1 ))","title":"2.50"},{"location":"SICP/ch2-abstraction-data/2.50/#250","text":"; Define the transformation flip-horiz, which flips painters horizontally, ; and transformations that rotate painters counterclockwise by 180 degrees ; and 270 degrees. # lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ; Helpers ( define ( xcor-vect v ) ( car v )) ( define ( ycor-vect v ) ( cdr v )) ( define ( sub-vect v1 v2 ) ( make-vect ( - ( xcor-vect v1 ) ( xcor-vect v2 )) ( - ( ycor-vect v1 ) ( ycor-vect v2 )))) ( define ( transform-painter painter origin corner1 corner2 ) ( lambda ( frame ) ( let (( m ( frame-coord-map frame ))) ( let (( new-origin ( m origin ))) ( painter ( make-frame new-origin ( sub-vect ( m corner1 ) new-origin ) ( sub-vect ( m corner2 ) new-origin ))))))) ; (i) Flip horizontally ( define ( flip-horiz painter ) ( transform-painter painter ( make-vect 1 0 ) ( make-vect 0 0 ) ( make-vect 1 1 ))) ; Test horizontal flip ( define f1-list ( list ( make-segment ( make-vect 0.3 0.3 ) ( make-vect 0.3 0.7 )) ( make-segment ( make-vect 0.3 0.7 ) ( make-vect 0.7 0.5 )) ( make-segment ( make-vect 0.7 0.5 ) ( make-vect 0.3 0.3 )))) ( define f1 ( segments->painter f1-list )) ( display \"\\nFrame f1\\n\" ) ( paint f1 ) ( display \"\\nFrame flipped horizontally f1\\n\" ) ( paint ( flip-horiz f1 )) ; (ii) Counterclockwise 180deg ( define ( rotate180 painter ) ( transform-painter painter ( make-vect 1 1 ) ( make-vect 0 1 ) ( make-vect 1 0 ))) ( display \"\\nFrame rotate counter clockwise 180deg f1\\n\" ) ( paint ( rotate180 f1 )) ; (iii) Counterclockwise 270deg ( define ( rotate270 painter ) ( transform-painter painter ( make-vect 0 1 ) ( make-vect 0 0 ) ( make-vect 1 1 ))) ( display \"\\nFrame rotate counter clockwise 270deg f1\\n\" ) ( paint ( rotate270 f1 ))","title":"2.50"},{"location":"SICP/ch2-abstraction-data/2.51/","text":"2.51 \u00b6 ; Define the below operation for painters. below takes two painters as arguments. The resulting painter, given ; a frame, draws with the first painter in the bottom of the frame and with the second painter in the top. ; Define below in two different ways \u2014 first by writing a procedure that is analogous to the beside procedure ; given above, and again in terms of beside and suitable rotation operations (from Exercise 2.50). # lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ; Helpers ( define ( xcor-vect v ) ( car v )) ( define ( ycor-vect v ) ( cdr v )) ( define ( sub-vect v1 v2 ) ( make-vect ( - ( xcor-vect v1 ) ( xcor-vect v2 )) ( - ( ycor-vect v1 ) ( ycor-vect v2 )))) ( define ( transform-painter painter origin corner1 corner2 ) ( lambda ( frame ) ( let (( m ( frame-coord-map frame ))) ( let (( new-origin ( m origin ))) ( painter ( make-frame new-origin ( sub-vect ( m corner1 ) new-origin ) ( sub-vect ( m corner2 ) new-origin ))))))) ; (i) Below procedure analogous to `beside` ( define ( below painter1 painter2 ) ( let (( split-point ( make-vect 0 0.5 ))) ( let (( paint-bottom ( transform-painter painter1 ( make-vect 0 0 ) ( make-vect 1 0 ) split-point )) ( paint-top ( transform-painter painter2 split-point ( make-vect 1 0.5 ) ( make-vect 0 1 )))) ( lambda ( frame ) ( paint-bottom frame ) ( paint-top frame ))))) ; Test ( define f1-list ( list ( make-segment ( make-vect 0.3 0.3 ) ( make-vect 0.5 0.7 )) ( make-segment ( make-vect 0.5 0.7 ) ( make-vect 0.8 0.3 )))) ( define f1 ( segments->painter f1-list )) ( display \"\\nFrame 1\\n\" ) ( paint f1 ) ( display \"\\nBelow Frame1 & Frame1\\n\" ) ( paint ( below f1 f1 )) ; (ii) Below procedure using beside and rotation ( define ( below2 painter1 painter2 ) ( rotate270 ( beside ( rotate90 painter2 ) ( rotate90 painter1 )))) ; Test ( display \"\\nBelow Frame1 & Frame1\\n\" ) ( paint ( below2 f1 f1 ))","title":"2.51"},{"location":"SICP/ch2-abstraction-data/2.51/#251","text":"; Define the below operation for painters. below takes two painters as arguments. The resulting painter, given ; a frame, draws with the first painter in the bottom of the frame and with the second painter in the top. ; Define below in two different ways \u2014 first by writing a procedure that is analogous to the beside procedure ; given above, and again in terms of beside and suitable rotation operations (from Exercise 2.50). # lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ; Helpers ( define ( xcor-vect v ) ( car v )) ( define ( ycor-vect v ) ( cdr v )) ( define ( sub-vect v1 v2 ) ( make-vect ( - ( xcor-vect v1 ) ( xcor-vect v2 )) ( - ( ycor-vect v1 ) ( ycor-vect v2 )))) ( define ( transform-painter painter origin corner1 corner2 ) ( lambda ( frame ) ( let (( m ( frame-coord-map frame ))) ( let (( new-origin ( m origin ))) ( painter ( make-frame new-origin ( sub-vect ( m corner1 ) new-origin ) ( sub-vect ( m corner2 ) new-origin ))))))) ; (i) Below procedure analogous to `beside` ( define ( below painter1 painter2 ) ( let (( split-point ( make-vect 0 0.5 ))) ( let (( paint-bottom ( transform-painter painter1 ( make-vect 0 0 ) ( make-vect 1 0 ) split-point )) ( paint-top ( transform-painter painter2 split-point ( make-vect 1 0.5 ) ( make-vect 0 1 )))) ( lambda ( frame ) ( paint-bottom frame ) ( paint-top frame ))))) ; Test ( define f1-list ( list ( make-segment ( make-vect 0.3 0.3 ) ( make-vect 0.5 0.7 )) ( make-segment ( make-vect 0.5 0.7 ) ( make-vect 0.8 0.3 )))) ( define f1 ( segments->painter f1-list )) ( display \"\\nFrame 1\\n\" ) ( paint f1 ) ( display \"\\nBelow Frame1 & Frame1\\n\" ) ( paint ( below f1 f1 )) ; (ii) Below procedure using beside and rotation ( define ( below2 painter1 painter2 ) ( rotate270 ( beside ( rotate90 painter2 ) ( rotate90 painter1 )))) ; Test ( display \"\\nBelow Frame1 & Frame1\\n\" ) ( paint ( below2 f1 f1 ))","title":"2.51"},{"location":"SICP/ch2-abstraction-data/2.52/","text":"2.52 \u00b6 ; Make changes to the square limit of wave shown in Figure 2.9 by working at each ; of the levels described above. In particular: ; a. Add some segments to the primitive wave painter of Exercise 2.49 (to add a ; smile, for example). ; b. Change the pattern constructed by corner-split (for example, by using only ; one copy of the up-split and right-split images instead of two). ; c. Modify the version of square-limit that uses square-of-four so as to assemble ; the corners in a different pattern. (For example, you might make the big Mr. ; Rogers look outward from each corner of the square.) # lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ; (a) Added a weird v shaped smile :> ( define wave-list ( list ( make-segment ( make-vect 0.01 0.8 ) ( make-vect 0.1 0.56 )) ( make-segment ( make-vect 0.1 0.56 ) ( make-vect 0.2 0.6 )) ( make-segment ( make-vect 0.2 0.6 ) ( make-vect 0.3 0.58 )) ( make-segment ( make-vect 0.3 0.58 ) ( make-vect 0.2 0.75 )) ( make-segment ( make-vect 0.2 0.75 ) ( make-vect 0.4 1 )) ( make-segment ( make-vect 0.6 1 ) ( make-vect 0.8 0.75 )) ( make-segment ( make-vect 0.8 0.75 ) ( make-vect 0.7 0.58 )) ( make-segment ( make-vect 0.7 0.58 ) ( make-vect 0.8 0.6 )) ( make-segment ( make-vect 0.8 0.6 ) ( make-vect 1 0.4 )) ( make-segment ( make-vect 0 0.61 ) ( make-vect 0.1 0.35 )) ( make-segment ( make-vect 0.1 0.35 ) ( make-vect 0.2 0.5 )) ( make-segment ( make-vect 0.2 0.5 ) ( make-vect 0.3 0.35 )) ( make-segment ( make-vect 0.3 0.35 ) ( make-vect 0.2 0 )) ( make-segment ( make-vect 0.3 0 ) ( make-vect 0.5 0.25 )) ( make-segment ( make-vect 0.5 0.25 ) ( make-vect 0.65 0 )) ( make-segment ( make-vect 0.75 0 ) ( make-vect 0.6 0.4 )) ( make-segment ( make-vect 0.6 0.4 ) ( make-vect 1 0.2 )) ( make-segment ( make-vect 0.4 0.8 ) ( make-vect 0.5 0.6 )) ( make-segment ( make-vect 0.5 0.6 ) ( make-vect 0.6 0.8 )))) ( define wave ( segments->painter wave-list )) ( display \"\\nWave with wierd smile\\n\" ) ( paint wave ) ; (b) Corner split using only 1 copy of up-split and right-split ( define ( up-split painter n ) ( if ( = n 0 ) painter ( let (( smaller ( up-split painter ( - n 1 )))) ( below painter ( beside smaller smaller ))))) ( define ( right-split painter n ) ( if ( = n 0 ) painter ( let (( smaller ( right-split painter ( - n 1 )))) ( beside painter ( below smaller smaller ))))) ( define ( corner-split painter n ) ( if ( = n 0 ) painter ( let (( up ( up-split painter ( - n 1 ))) ( right ( right-split painter ( - n 1 )))) ( let (( top-left up ) ( bottom-right right ) ( corner ( corner-split painter ( - n 1 )))) ( beside ( below painter top-left ) ( below bottom-right corner )))))) ( display \"\\nCorner split modifined\\n\" ) ( paint ( corner-split wave 3 )) ; (c) Modified square-limit ( define ( square-of-four tl tr bl br ) ( lambda ( painter ) ( let (( top ( beside ( tl painter ) ( tr painter ))) ( bottom ( beside ( bl painter ) ( br painter )))) ( below bottom top )))) ( define ( square-limit painter n ) ( let (( combine4 ( square-of-four rotate270 rotate180 identity rotate90 ))) ( combine4 ( corner-split painter n )))) ( display \"\\nOutward square-limit\\n\" ) ( paint ( square-limit wave 2 ))","title":"2.52"},{"location":"SICP/ch2-abstraction-data/2.52/#252","text":"; Make changes to the square limit of wave shown in Figure 2.9 by working at each ; of the levels described above. In particular: ; a. Add some segments to the primitive wave painter of Exercise 2.49 (to add a ; smile, for example). ; b. Change the pattern constructed by corner-split (for example, by using only ; one copy of the up-split and right-split images instead of two). ; c. Modify the version of square-limit that uses square-of-four so as to assemble ; the corners in a different pattern. (For example, you might make the big Mr. ; Rogers look outward from each corner of the square.) # lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ; (a) Added a weird v shaped smile :> ( define wave-list ( list ( make-segment ( make-vect 0.01 0.8 ) ( make-vect 0.1 0.56 )) ( make-segment ( make-vect 0.1 0.56 ) ( make-vect 0.2 0.6 )) ( make-segment ( make-vect 0.2 0.6 ) ( make-vect 0.3 0.58 )) ( make-segment ( make-vect 0.3 0.58 ) ( make-vect 0.2 0.75 )) ( make-segment ( make-vect 0.2 0.75 ) ( make-vect 0.4 1 )) ( make-segment ( make-vect 0.6 1 ) ( make-vect 0.8 0.75 )) ( make-segment ( make-vect 0.8 0.75 ) ( make-vect 0.7 0.58 )) ( make-segment ( make-vect 0.7 0.58 ) ( make-vect 0.8 0.6 )) ( make-segment ( make-vect 0.8 0.6 ) ( make-vect 1 0.4 )) ( make-segment ( make-vect 0 0.61 ) ( make-vect 0.1 0.35 )) ( make-segment ( make-vect 0.1 0.35 ) ( make-vect 0.2 0.5 )) ( make-segment ( make-vect 0.2 0.5 ) ( make-vect 0.3 0.35 )) ( make-segment ( make-vect 0.3 0.35 ) ( make-vect 0.2 0 )) ( make-segment ( make-vect 0.3 0 ) ( make-vect 0.5 0.25 )) ( make-segment ( make-vect 0.5 0.25 ) ( make-vect 0.65 0 )) ( make-segment ( make-vect 0.75 0 ) ( make-vect 0.6 0.4 )) ( make-segment ( make-vect 0.6 0.4 ) ( make-vect 1 0.2 )) ( make-segment ( make-vect 0.4 0.8 ) ( make-vect 0.5 0.6 )) ( make-segment ( make-vect 0.5 0.6 ) ( make-vect 0.6 0.8 )))) ( define wave ( segments->painter wave-list )) ( display \"\\nWave with wierd smile\\n\" ) ( paint wave ) ; (b) Corner split using only 1 copy of up-split and right-split ( define ( up-split painter n ) ( if ( = n 0 ) painter ( let (( smaller ( up-split painter ( - n 1 )))) ( below painter ( beside smaller smaller ))))) ( define ( right-split painter n ) ( if ( = n 0 ) painter ( let (( smaller ( right-split painter ( - n 1 )))) ( beside painter ( below smaller smaller ))))) ( define ( corner-split painter n ) ( if ( = n 0 ) painter ( let (( up ( up-split painter ( - n 1 ))) ( right ( right-split painter ( - n 1 )))) ( let (( top-left up ) ( bottom-right right ) ( corner ( corner-split painter ( - n 1 )))) ( beside ( below painter top-left ) ( below bottom-right corner )))))) ( display \"\\nCorner split modifined\\n\" ) ( paint ( corner-split wave 3 )) ; (c) Modified square-limit ( define ( square-of-four tl tr bl br ) ( lambda ( painter ) ( let (( top ( beside ( tl painter ) ( tr painter ))) ( bottom ( beside ( bl painter ) ( br painter )))) ( below bottom top )))) ( define ( square-limit painter n ) ( let (( combine4 ( square-of-four rotate270 rotate180 identity rotate90 ))) ( combine4 ( corner-split painter n )))) ( display \"\\nOutward square-limit\\n\" ) ( paint ( square-limit wave 2 ))","title":"2.52"},{"location":"SICP/ch2-abstraction-data/2.53/","text":"2.53 \u00b6 ; What would the interpreter print in response to evaluating each of the ; following expressions? ( define ( memq item x ) ( cond (( null? x ) false ) (( eq? item ( car x )) x ) ( else ( memq item ( cdr x ))))) ( list 'a 'b 'c ) ; (a b c) ( list ( list 'george )) ; ((george)) ( cdr ' (( x1 x2 ) ( y1 y2 ))) ; ((y1 y2)) ( cadr ' (( x1 x2 ) ( y1 y2 ))) ; (y1 y2) ( pair? ( car ' ( a short list ))) ; #f ( memq 'red ' (( red shoes ) ( blue socks ))) ; #f ( memq 'red ' ( red shoes blue socks )) ; (red shoes blue socks)","title":"2.53"},{"location":"SICP/ch2-abstraction-data/2.53/#253","text":"; What would the interpreter print in response to evaluating each of the ; following expressions? ( define ( memq item x ) ( cond (( null? x ) false ) (( eq? item ( car x )) x ) ( else ( memq item ( cdr x ))))) ( list 'a 'b 'c ) ; (a b c) ( list ( list 'george )) ; ((george)) ( cdr ' (( x1 x2 ) ( y1 y2 ))) ; ((y1 y2)) ( cadr ' (( x1 x2 ) ( y1 y2 ))) ; (y1 y2) ( pair? ( car ' ( a short list ))) ; #f ( memq 'red ' (( red shoes ) ( blue socks ))) ; #f ( memq 'red ' ( red shoes blue socks )) ; (red shoes blue socks)","title":"2.53"},{"location":"SICP/ch2-abstraction-data/2.54/","text":"2.54 \u00b6 ; Two lists are said to be equal? if they contain equal elements arranged in the ; same order. For example, ; (equal? '(this is a list) '(this is a list)) ; is true, but ; (equal? '(this is a list) '(this (is a) list)) ; is false. To be more precise, we can define `equal?` recursively in terms of the ; basic eq? equality of symbols by saying that a and b are `equal?` if they are ; both symbols and the symbols are eq?, or if they are both lists such that (car a) ; is equal? to (car b) and (cdr a) is equal? to (cdr b). Using this idea, ; implement equal? as a procedure. ( define ( equal? list1 list2 ) ( cond (( not ( or ( pair? list1 ) ( pair? list2 ))) ( eq? list1 list2 )) (( and ( pair? list1 ) ( pair? list2 )) ( and ( equal? ( car list1 ) ( car list2 )) ( equal? ( cdr list1 ) ( cdr list2 )))) ( else #f ))) ( equal? ' ( 1 2 3 ) ' ( 1 2 3 )) ; #t ( equal? ' ( 1 ( 4 5 ) 6 ) ' ( 1 ( 4 5 ) 6 )) ; #t ( equal? ' ( 1 2 3 ( 4 5 )) ' ( 1 2 ( 3 4 ) 5 )) ; #f","title":"2.54"},{"location":"SICP/ch2-abstraction-data/2.54/#254","text":"; Two lists are said to be equal? if they contain equal elements arranged in the ; same order. For example, ; (equal? '(this is a list) '(this is a list)) ; is true, but ; (equal? '(this is a list) '(this (is a) list)) ; is false. To be more precise, we can define `equal?` recursively in terms of the ; basic eq? equality of symbols by saying that a and b are `equal?` if they are ; both symbols and the symbols are eq?, or if they are both lists such that (car a) ; is equal? to (car b) and (cdr a) is equal? to (cdr b). Using this idea, ; implement equal? as a procedure. ( define ( equal? list1 list2 ) ( cond (( not ( or ( pair? list1 ) ( pair? list2 ))) ( eq? list1 list2 )) (( and ( pair? list1 ) ( pair? list2 )) ( and ( equal? ( car list1 ) ( car list2 )) ( equal? ( cdr list1 ) ( cdr list2 )))) ( else #f ))) ( equal? ' ( 1 2 3 ) ' ( 1 2 3 )) ; #t ( equal? ' ( 1 ( 4 5 ) 6 ) ' ( 1 ( 4 5 ) 6 )) ; #t ( equal? ' ( 1 2 3 ( 4 5 )) ' ( 1 2 ( 3 4 ) 5 )) ; #f","title":"2.54"},{"location":"SICP/ch2-abstraction-data/2.55/","text":"2.55 \u00b6 ; Eva Lu Ator types to the interpreter the ex-pression ( car ' 'abracadabra ) ; To her surprise, the interpreter prints back quote. Explain. ; Interpreter treats ''abracadabra as ; '(quote abracadabra) ; Hence, (car ...) gives \"quote\"","title":"2.55"},{"location":"SICP/ch2-abstraction-data/2.55/#255","text":"; Eva Lu Ator types to the interpreter the ex-pression ( car ' 'abracadabra ) ; To her surprise, the interpreter prints back quote. Explain. ; Interpreter treats ''abracadabra as ; '(quote abracadabra) ; Hence, (car ...) gives \"quote\"","title":"2.55"},{"location":"SICP/ch2-abstraction-data/2.56/","text":"2.56 \u00b6 ; Show how to extend the basic differentiator to handle more kinds of expressions. ; For instance, implement the differentiation rule ; d/dx(u^n) = n u^(n-1) d/dx(u) ; by adding a new clause to the deriv program and defining appropriate procedures ; `exponentiation?`, `base`, `exponent`, and `make-exponentiation`. (You may use ; the symbol ** to denote exponentiation.) Build in the rules that anything raised ; to the power 0 is 1 and anything raised to the power 1 is the thing itself. ( define ( =number? exp num ) ( and ( number? exp ) ( = exp num ))) ; Define exponent related prodecures ( define ( exponentiation? x ) ( and ( pair? x ) ( eq? ( car x ) '** ))) ( define ( make-exponent b e ) ( cond (( =number? e 0 ) 1 ) (( =number? e 1 ) b ) (( and ( number? b ) ( number? e )) ( expt b e )) ( else ( list '** b e )))) ( define ( base e ) ( cadr e )) ( define ( exponent e ) ( caddr e )) ( make-exponent 2 5 ) ;Value: 32 ( make-exponent 'x 0 ) ;Value: 1 ( make-exponent 'y 1 ) ;y ( make-exponent 'x 'y ) ;(** x y) ( make-exponent 2 'x ) ;(** 2 x) ; Modify `deriv` to support exponentiation ( define ( deriv exp var ) ( cond (( number? exp ) 0 ) (( variable? exp ) ( if ( same-variable? exp var ) 1 0 )) (( sum? exp ) ( make-sum ( deriv ( addend exp ) var ) ( deriv ( augend exp ) var ))) (( product? exp ) ( make-sum ( make-product ( multiplier exp ) ( deriv ( multiplicand exp ) var )) ( make-product ( deriv ( multiplier exp ) var ) ( multiplicand exp )))) (( exponentiation? exp ) ( make-product ( exponent exp ) ( make-product ( make-exponent ( base exp ) ( make-sum ( exponent exp ) -1 )) ( deriv ( base exp ) var )))) ( else ( error \"unknown expression type: DERIV\" exp )))) ( define ( variable? x ) ( symbol? x )) ( define ( same-variable? v1 v2 ) ( and ( variable? v1 ) ( variable? v2 ) ( eq? v1 v2 ))) ( define ( sum? x ) ( and ( pair? x ) ( eq? ( car x ) '+ ))) ( define ( addend s ) ( cadr s )) ( define ( augend s ) ( caddr s )) ( define ( product? x ) ( and ( pair? x ) ( eq? ( car x ) '* ))) ( define ( multiplier p ) ( cadr p )) ( define ( multiplicand p ) ( caddr p )) ( define ( make-sum a1 a2 ) ( cond (( =number? a1 0 ) a2 ) (( =number? a2 0 ) a1 ) (( and ( number? a1 ) ( number? a2 )) ( + a1 a2 )) ( else ( list '+ a1 a2 )))) ( define ( make-product m1 m2 ) ( cond (( or ( =number? m1 0 ) ( =number? m2 0 )) 0 ) (( =number? m1 1 ) m2 ) (( =number? m2 1 ) m1 ) (( and ( number? m1 ) ( number? m2 )) ( * m1 m2 )) ( else ( list '* m1 m2 )))) ( deriv ' ( ** x 3 ) 'x ) ; (* 3 (** x 2)) ( deriv ' ( ** x n ) 'x ) ; (* n (** x (+ n -1)))","title":"2.56"},{"location":"SICP/ch2-abstraction-data/2.56/#256","text":"; Show how to extend the basic differentiator to handle more kinds of expressions. ; For instance, implement the differentiation rule ; d/dx(u^n) = n u^(n-1) d/dx(u) ; by adding a new clause to the deriv program and defining appropriate procedures ; `exponentiation?`, `base`, `exponent`, and `make-exponentiation`. (You may use ; the symbol ** to denote exponentiation.) Build in the rules that anything raised ; to the power 0 is 1 and anything raised to the power 1 is the thing itself. ( define ( =number? exp num ) ( and ( number? exp ) ( = exp num ))) ; Define exponent related prodecures ( define ( exponentiation? x ) ( and ( pair? x ) ( eq? ( car x ) '** ))) ( define ( make-exponent b e ) ( cond (( =number? e 0 ) 1 ) (( =number? e 1 ) b ) (( and ( number? b ) ( number? e )) ( expt b e )) ( else ( list '** b e )))) ( define ( base e ) ( cadr e )) ( define ( exponent e ) ( caddr e )) ( make-exponent 2 5 ) ;Value: 32 ( make-exponent 'x 0 ) ;Value: 1 ( make-exponent 'y 1 ) ;y ( make-exponent 'x 'y ) ;(** x y) ( make-exponent 2 'x ) ;(** 2 x) ; Modify `deriv` to support exponentiation ( define ( deriv exp var ) ( cond (( number? exp ) 0 ) (( variable? exp ) ( if ( same-variable? exp var ) 1 0 )) (( sum? exp ) ( make-sum ( deriv ( addend exp ) var ) ( deriv ( augend exp ) var ))) (( product? exp ) ( make-sum ( make-product ( multiplier exp ) ( deriv ( multiplicand exp ) var )) ( make-product ( deriv ( multiplier exp ) var ) ( multiplicand exp )))) (( exponentiation? exp ) ( make-product ( exponent exp ) ( make-product ( make-exponent ( base exp ) ( make-sum ( exponent exp ) -1 )) ( deriv ( base exp ) var )))) ( else ( error \"unknown expression type: DERIV\" exp )))) ( define ( variable? x ) ( symbol? x )) ( define ( same-variable? v1 v2 ) ( and ( variable? v1 ) ( variable? v2 ) ( eq? v1 v2 ))) ( define ( sum? x ) ( and ( pair? x ) ( eq? ( car x ) '+ ))) ( define ( addend s ) ( cadr s )) ( define ( augend s ) ( caddr s )) ( define ( product? x ) ( and ( pair? x ) ( eq? ( car x ) '* ))) ( define ( multiplier p ) ( cadr p )) ( define ( multiplicand p ) ( caddr p )) ( define ( make-sum a1 a2 ) ( cond (( =number? a1 0 ) a2 ) (( =number? a2 0 ) a1 ) (( and ( number? a1 ) ( number? a2 )) ( + a1 a2 )) ( else ( list '+ a1 a2 )))) ( define ( make-product m1 m2 ) ( cond (( or ( =number? m1 0 ) ( =number? m2 0 )) 0 ) (( =number? m1 1 ) m2 ) (( =number? m2 1 ) m1 ) (( and ( number? m1 ) ( number? m2 )) ( * m1 m2 )) ( else ( list '* m1 m2 )))) ( deriv ' ( ** x 3 ) 'x ) ; (* 3 (** x 2)) ( deriv ' ( ** x n ) 'x ) ; (* n (** x (+ n -1)))","title":"2.56"},{"location":"SICP/ch2-abstraction-data/2.57/","text":"2.57 \u00b6 ; Extend the differentiation program to handle sums and products of arbitrary ; numbers of (two or more) terms. Then the last example above could be expressed ; as ; (deriv '(* x y (+ x 3)) 'x) ; Try to do this by changing only the representation for sums and products, ; without changing the deriv procedure at all. For example, the addend of a sum ; would be the first term, and the augend would be the sum of the rest of the terms. ; New definitions for `augend` and `multiplcand` are, ; ==================================================== ( define ( augend s ) ( if ( null? ( cdddr s )) ( caddr s ) ( make-sum ( caddr s ) ( cadddr s )))) ( define ( multiplicand p ) ( if ( null? ( cdddr p )) ( caddr p ) ( make-product ( caddr p ) ( cadddr p )))) ; ==================================================== ; Testing ( define ( variable? x ) ( symbol? x )) ( define ( same-variable? v1 v2 ) ( and ( variable? v1 ) ( variable? v2 ) ( eq? v1 v2 ))) ( define ( =number? exp num ) ( and ( number? exp ) ( = exp num ))) ( define ( sum? x ) ( and ( pair? x ) ( eq? ( car x ) '+ ))) ( define ( addend s ) ( cadr s )) ( define ( make-sum a1 a2 ) ( cond (( =number? a1 0 ) a2 ) (( =number? a2 0 ) a1 ) (( and ( number? a1 ) ( number? a2 )) ( + a1 a2 )) ( else ( list '+ a1 a2 )))) ( define ( product? x ) ( and ( pair? x ) ( eq? ( car x ) '* ))) ( define ( multiplier p ) ( cadr p )) ( define ( make-product m1 m2 ) ( cond (( or ( =number? m1 0 ) ( =number? m2 0 )) 0 ) (( =number? m1 1 ) m2 ) (( =number? m2 1 ) m1 ) (( and ( number? m1 ) ( number? m2 )) ( * m1 m2 )) ( else ( list '* m1 m2 )))) ( define ( deriv exp var ) ( cond (( number? exp ) 0 ) (( variable? exp ) ( if ( same-variable? exp var ) 1 0 )) (( sum? exp ) ( make-sum ( deriv ( addend exp ) var ) ( deriv ( augend exp ) var ))) (( product? exp ) ( make-sum ( make-product ( multiplier exp ) ( deriv ( multiplicand exp ) var )) ( make-product ( deriv ( multiplier exp ) var ) ( multiplicand exp )))) ( else ( error \"unknown expression type: DERIV\" exp )))) ( deriv ' ( * x y ( + x 3 )) 'x ) ; (+ (* x y) (* y (+ x 3))) ( deriv ' ( * x y ( + x 3 y )) 'x ) ; (+ (* x y) (* y (+ x 3 y)))","title":"2.57"},{"location":"SICP/ch2-abstraction-data/2.57/#257","text":"; Extend the differentiation program to handle sums and products of arbitrary ; numbers of (two or more) terms. Then the last example above could be expressed ; as ; (deriv '(* x y (+ x 3)) 'x) ; Try to do this by changing only the representation for sums and products, ; without changing the deriv procedure at all. For example, the addend of a sum ; would be the first term, and the augend would be the sum of the rest of the terms. ; New definitions for `augend` and `multiplcand` are, ; ==================================================== ( define ( augend s ) ( if ( null? ( cdddr s )) ( caddr s ) ( make-sum ( caddr s ) ( cadddr s )))) ( define ( multiplicand p ) ( if ( null? ( cdddr p )) ( caddr p ) ( make-product ( caddr p ) ( cadddr p )))) ; ==================================================== ; Testing ( define ( variable? x ) ( symbol? x )) ( define ( same-variable? v1 v2 ) ( and ( variable? v1 ) ( variable? v2 ) ( eq? v1 v2 ))) ( define ( =number? exp num ) ( and ( number? exp ) ( = exp num ))) ( define ( sum? x ) ( and ( pair? x ) ( eq? ( car x ) '+ ))) ( define ( addend s ) ( cadr s )) ( define ( make-sum a1 a2 ) ( cond (( =number? a1 0 ) a2 ) (( =number? a2 0 ) a1 ) (( and ( number? a1 ) ( number? a2 )) ( + a1 a2 )) ( else ( list '+ a1 a2 )))) ( define ( product? x ) ( and ( pair? x ) ( eq? ( car x ) '* ))) ( define ( multiplier p ) ( cadr p )) ( define ( make-product m1 m2 ) ( cond (( or ( =number? m1 0 ) ( =number? m2 0 )) 0 ) (( =number? m1 1 ) m2 ) (( =number? m2 1 ) m1 ) (( and ( number? m1 ) ( number? m2 )) ( * m1 m2 )) ( else ( list '* m1 m2 )))) ( define ( deriv exp var ) ( cond (( number? exp ) 0 ) (( variable? exp ) ( if ( same-variable? exp var ) 1 0 )) (( sum? exp ) ( make-sum ( deriv ( addend exp ) var ) ( deriv ( augend exp ) var ))) (( product? exp ) ( make-sum ( make-product ( multiplier exp ) ( deriv ( multiplicand exp ) var )) ( make-product ( deriv ( multiplier exp ) var ) ( multiplicand exp )))) ( else ( error \"unknown expression type: DERIV\" exp )))) ( deriv ' ( * x y ( + x 3 )) 'x ) ; (+ (* x y) (* y (+ x 3))) ( deriv ' ( * x y ( + x 3 y )) 'x ) ; (+ (* x y) (* y (+ x 3 y)))","title":"2.57"},{"location":"SICP/ch2-abstraction-data/2.58.a/","text":"2.58.a \u00b6 ; New definitions of sum and product ; ============================================================ ( define ( sum? x ) ( and ( pair? x ) ( eq? ( cadr x ) '+ ))) ( define ( make-sum a1 a2 ) ( cond (( =number? a1 0 ) a2 ) (( =number? a2 0 ) a1 ) (( and ( number? a1 ) ( number? a2 )) ( + a1 a2 )) ( else ( list a1 '+ a2 )))) ( define ( addend s ) ( car s )) ( define ( augend s ) ( caddr s )) ( define ( product? x ) ( and ( pair? x ) ( eq? ( cadr x ) '* ))) ( define ( make-product m1 m2 ) ( cond (( or ( =number? m1 0 ) ( =number? m2 0 )) 0 ) (( =number? m1 1 ) m2 ) (( =number? m2 1 ) m1 ) (( and ( number? m1 ) ( number? m2 )) ( * m1 m2 )) ( else ( list m1 '* m2 )))) ( define ( multiplier p ) ( car p )) ( define ( multiplicand p ) ( caddr p )) ; ============================================================ ; Testing ( define ( variable? x ) ( symbol? x )) ( define ( same-variable? v1 v2 ) ( and ( variable? v1 ) ( variable? v2 ) ( eq? v1 v2 ))) ( define ( =number? exp num ) ( and ( number? exp ) ( = exp num ))) ( define ( deriv exp var ) ( cond (( number? exp ) 0 ) (( variable? exp ) ( if ( same-variable? exp var ) 1 0 )) (( sum? exp ) ( make-sum ( deriv ( addend exp ) var ) ( deriv ( augend exp ) var ))) (( product? exp ) ( make-sum ( make-product ( multiplier exp ) ( deriv ( multiplicand exp ) var )) ( make-product ( deriv ( multiplier exp ) var ) ( multiplicand exp )))) ( else ( error \"unknown expression type: DERIV\" exp )))) ( deriv ' ( x + 3 ) 'x ) ; Value: 1 ( deriv ' ( x * y ) 'x ) ; Value: y ( deriv ' ( x + ( 3 * ( x + ( y + 2 )))) 'x ) ; Value: 4","title":"2.58.a"},{"location":"SICP/ch2-abstraction-data/2.58.a/#258a","text":"; New definitions of sum and product ; ============================================================ ( define ( sum? x ) ( and ( pair? x ) ( eq? ( cadr x ) '+ ))) ( define ( make-sum a1 a2 ) ( cond (( =number? a1 0 ) a2 ) (( =number? a2 0 ) a1 ) (( and ( number? a1 ) ( number? a2 )) ( + a1 a2 )) ( else ( list a1 '+ a2 )))) ( define ( addend s ) ( car s )) ( define ( augend s ) ( caddr s )) ( define ( product? x ) ( and ( pair? x ) ( eq? ( cadr x ) '* ))) ( define ( make-product m1 m2 ) ( cond (( or ( =number? m1 0 ) ( =number? m2 0 )) 0 ) (( =number? m1 1 ) m2 ) (( =number? m2 1 ) m1 ) (( and ( number? m1 ) ( number? m2 )) ( * m1 m2 )) ( else ( list m1 '* m2 )))) ( define ( multiplier p ) ( car p )) ( define ( multiplicand p ) ( caddr p )) ; ============================================================ ; Testing ( define ( variable? x ) ( symbol? x )) ( define ( same-variable? v1 v2 ) ( and ( variable? v1 ) ( variable? v2 ) ( eq? v1 v2 ))) ( define ( =number? exp num ) ( and ( number? exp ) ( = exp num ))) ( define ( deriv exp var ) ( cond (( number? exp ) 0 ) (( variable? exp ) ( if ( same-variable? exp var ) 1 0 )) (( sum? exp ) ( make-sum ( deriv ( addend exp ) var ) ( deriv ( augend exp ) var ))) (( product? exp ) ( make-sum ( make-product ( multiplier exp ) ( deriv ( multiplicand exp ) var )) ( make-product ( deriv ( multiplier exp ) var ) ( multiplicand exp )))) ( else ( error \"unknown expression type: DERIV\" exp )))) ( deriv ' ( x + 3 ) 'x ) ; Value: 1 ( deriv ' ( x * y ) 'x ) ; Value: y ( deriv ' ( x + ( 3 * ( x + ( y + 2 )))) 'x ) ; Value: 4","title":"2.58.a"},{"location":"SICP/ch2-abstraction-data/2.59/","text":"2.59 \u00b6 ; Implement the union-set operation for the unordered-list representation of sets. ( define ( union-set set1 set2 ) ( cond (( and ( null? set1 ) ( not ( null? set2 ))) set2 ) (( and ( null? set2 ) ( not ( null? set1 ))) set1 ) (( element-of-set? ( car set1 ) set2 ) ( union-set ( cdr set1 ) set2 )) ( else ( cons ( car set1 ) ( union-set ( cdr set1 ) set2 ))))) ( define ( element-of-set? x set ) ( cond (( null? set ) false ) (( equal? x ( car set )) #t ) ( else ( element-of-set? x ( cdr set ))))) ( union-set ( list 1 2 3 4 ) ( list 2 3 4 5 6 )) ;Value 2: (1 2 3 4 5 6)","title":"2.59"},{"location":"SICP/ch2-abstraction-data/2.59/#259","text":"; Implement the union-set operation for the unordered-list representation of sets. ( define ( union-set set1 set2 ) ( cond (( and ( null? set1 ) ( not ( null? set2 ))) set2 ) (( and ( null? set2 ) ( not ( null? set1 ))) set1 ) (( element-of-set? ( car set1 ) set2 ) ( union-set ( cdr set1 ) set2 )) ( else ( cons ( car set1 ) ( union-set ( cdr set1 ) set2 ))))) ( define ( element-of-set? x set ) ( cond (( null? set ) false ) (( equal? x ( car set )) #t ) ( else ( element-of-set? x ( cdr set ))))) ( union-set ( list 1 2 3 4 ) ( list 2 3 4 5 6 )) ;Value 2: (1 2 3 4 5 6)","title":"2.59"},{"location":"SICP/ch2-abstraction-data/2.60/","text":"2.60 \u00b6 ; We specified that a set would be represented as a list with no duplicates. Now ; suppose we allow duplicates. For instance, the set {1, 2, 3} could be represented ; as the list (2 3 2 1 3 2 2). Design procedures element-of-set?, adjoin-set, ; union-set, and intersection-set that operate on this representation. How does ; the efficiency of each compare with the corresponding procedure for the ; non-duplicate representation? Are there applications for which you would use ; this representation in preference to the non-duplicate one? ; Unchanged ( define ( element-of-set? x set ) ( cond (( null? set ) false ) (( equal? x ( car set )) #t ) ( else ( element-of-set? x ( cdr set ))))) ( define ( adjoin-set x set ) ( cons x set )) ( define ( union-set set1 set2 ) ( append set1 set2 )) ( define ( intersection-set set1 set2 ) ( cond (( or ( null? set1 ) ( null? set2 )) ' ()) (( element-of-set? ( car set1 ) set2 ) ( cons ( car set1 ) ( intersection-set ( cdr set1 ) set2 ))) ( else ( intersection-set ( cdr set1 ) set2 )))) ( intersection-set ( list 1 1 3 3 4 5 ) ( list 3 3 5 )) ; (3 3 5) ( union-set ( list 1 2 2 3 ) ( list 3 4 7 )) ; (1 2 2 3 3 4 7) ; Note: For intersection, i quite didn't get the question, hence assuming the method ; remains the same as previous ; Both `adjoin-set` and `union-set` have O(1) running time","title":"2.60"},{"location":"SICP/ch2-abstraction-data/2.60/#260","text":"; We specified that a set would be represented as a list with no duplicates. Now ; suppose we allow duplicates. For instance, the set {1, 2, 3} could be represented ; as the list (2 3 2 1 3 2 2). Design procedures element-of-set?, adjoin-set, ; union-set, and intersection-set that operate on this representation. How does ; the efficiency of each compare with the corresponding procedure for the ; non-duplicate representation? Are there applications for which you would use ; this representation in preference to the non-duplicate one? ; Unchanged ( define ( element-of-set? x set ) ( cond (( null? set ) false ) (( equal? x ( car set )) #t ) ( else ( element-of-set? x ( cdr set ))))) ( define ( adjoin-set x set ) ( cons x set )) ( define ( union-set set1 set2 ) ( append set1 set2 )) ( define ( intersection-set set1 set2 ) ( cond (( or ( null? set1 ) ( null? set2 )) ' ()) (( element-of-set? ( car set1 ) set2 ) ( cons ( car set1 ) ( intersection-set ( cdr set1 ) set2 ))) ( else ( intersection-set ( cdr set1 ) set2 )))) ( intersection-set ( list 1 1 3 3 4 5 ) ( list 3 3 5 )) ; (3 3 5) ( union-set ( list 1 2 2 3 ) ( list 3 4 7 )) ; (1 2 2 3 3 4 7) ; Note: For intersection, i quite didn't get the question, hence assuming the method ; remains the same as previous ; Both `adjoin-set` and `union-set` have O(1) running time","title":"2.60"},{"location":"SICP/ch2-abstraction-data/2.61/","text":"2.61 \u00b6 ; Give an implementation of adjoin-set using the ordered representation. By ; analogy with element-of-set? show how to take advantage of the ordering to ; produce a procedure that requires on the average about half as many steps as ; with the unordered representation. ( define ( adjoin-set x set ) ( cond (( null? set ) ( list x )) (( = ( car set ) x ) set ) (( > ( car set ) x ) ( cons x set )) ( else ( cons ( car set ) ( adjoin-set x ( cdr set )))))) ; Testing ( adjoin-set 5 ( list 1 3 4 9 )) ; (1 3 4 5 9) ( adjoin-set 5 ( list 1 3 4 5 )) ; (1 3 4 5)","title":"2.61"},{"location":"SICP/ch2-abstraction-data/2.61/#261","text":"; Give an implementation of adjoin-set using the ordered representation. By ; analogy with element-of-set? show how to take advantage of the ordering to ; produce a procedure that requires on the average about half as many steps as ; with the unordered representation. ( define ( adjoin-set x set ) ( cond (( null? set ) ( list x )) (( = ( car set ) x ) set ) (( > ( car set ) x ) ( cons x set )) ( else ( cons ( car set ) ( adjoin-set x ( cdr set )))))) ; Testing ( adjoin-set 5 ( list 1 3 4 9 )) ; (1 3 4 5 9) ( adjoin-set 5 ( list 1 3 4 5 )) ; (1 3 4 5)","title":"2.61"},{"location":"SICP/ch2-abstraction-data/2.62/","text":"2.62 \u00b6 ; Give a \u0398(n) implementation of union-set for sets represented as ordered lists. ( define ( union-set set1 set2 ) ( cond (( null? set1 ) set2 ) (( null? set2 ) set1 ) ( else ( let (( x1 ( car set1 )) ( x2 ( car set2 ))) ( cond (( = x1 x2 ) ( cons x1 ( union-set ( cdr set1 ) ( cdr set2 )))) (( > x1 x2 ) ( cons x2 ( union-set set1 ( cdr set2 )))) ( else ( cons x1 ( union-set ( cdr set1 ) set2 )))))))) ; Testing ( union-set ( list 1 3 4 6 ) ( list 2 5 6 7 )) ;(1 2 3 4 5 6 7)","title":"2.62"},{"location":"SICP/ch2-abstraction-data/2.62/#262","text":"; Give a \u0398(n) implementation of union-set for sets represented as ordered lists. ( define ( union-set set1 set2 ) ( cond (( null? set1 ) set2 ) (( null? set2 ) set1 ) ( else ( let (( x1 ( car set1 )) ( x2 ( car set2 ))) ( cond (( = x1 x2 ) ( cons x1 ( union-set ( cdr set1 ) ( cdr set2 )))) (( > x1 x2 ) ( cons x2 ( union-set set1 ( cdr set2 )))) ( else ( cons x1 ( union-set ( cdr set1 ) set2 )))))))) ; Testing ( union-set ( list 1 3 4 6 ) ( list 2 5 6 7 )) ;(1 2 3 4 5 6 7)","title":"2.62"},{"location":"SICP/ch2-abstraction-data/2.63/","text":"2.63 \u00b6 ; Each of the following two procedures converts a binary tree to a list. ( define ( tree->list-1 tree ) ( if ( null? tree ) ' () ( append ( tree->list-1 ( left-branch tree )) ( cons ( entry tree ) ( tree->list-1 ( right-branch tree )))))) ( define ( tree->list-2 tree ) ( define ( copy-to-list tree result-list ) ( if ( null? tree ) result-list ( copy-to-list ( left-branch tree ) ( cons ( entry tree ) ( copy-to-list ( right-branch tree ) result-list ))))) ( copy-to-list tree ' ())) ; (a) Do the two procedures produce the same result for ; every tree? If not, how do the results differ? What lists ; do the two procedures produce for the trees in Figure 2.16? ( define ( entry tree ) ( car tree )) ( define ( left-branch tree ) ( cadr tree )) ( define ( right-branch tree ) ( caddr tree )) ( define ( make-tree entry left right ) ( list entry left right )) ; Test for all 3 trees in Figure 2.16 ( define tree1 ( list 7 ( list 3 ( list 1 ' () ' ()) ( list 5 ' () ' ())) ( list 9 ' () ( list 11 ' () ' ())))) ( define tree2 ( list 3 ( list 1 ' () ' ()) ( list 7 ( list 5 ' () ' ()) ( list 9 ' () ( list 11 ' () ' ()))))) ( define tree3 ( list 5 ( list 3 ( list 1 ' () ' ()) ' ()) ( list 9 ( list 7 ' () ' ()) ( list 11 ' () ' ())))) ( tree->list-1 tree1 ) ;(1 3 5 7 9 11) ( tree->list-2 tree1 ) ;(1 3 5 7 9 11) ( tree->list-1 tree2 ) ;(1 3 5 7 9 11) ( tree->list-2 tree2 ) ;(1 3 5 7 9 11) ( tree->list-1 tree3 ) ;(1 3 5 7 9 11) ( tree->list-2 tree3 ) ;(1 3 5 7 9 11) ; Ans: Both the procedures produce the same results for every tree ; For all 3 figures in Fig 2.16, list is (1 3 5 7 9 11) ; (b) Do the two procedures have the same order of growth in the number of ; steps required to convert a balanced tree with n elements to a list? ; If not, which one grows more slowly? ; Ans ; tree->list-1 takes O(n log n) time ; tree->list-2 takes O(n) time","title":"2.63"},{"location":"SICP/ch2-abstraction-data/2.63/#263","text":"; Each of the following two procedures converts a binary tree to a list. ( define ( tree->list-1 tree ) ( if ( null? tree ) ' () ( append ( tree->list-1 ( left-branch tree )) ( cons ( entry tree ) ( tree->list-1 ( right-branch tree )))))) ( define ( tree->list-2 tree ) ( define ( copy-to-list tree result-list ) ( if ( null? tree ) result-list ( copy-to-list ( left-branch tree ) ( cons ( entry tree ) ( copy-to-list ( right-branch tree ) result-list ))))) ( copy-to-list tree ' ())) ; (a) Do the two procedures produce the same result for ; every tree? If not, how do the results differ? What lists ; do the two procedures produce for the trees in Figure 2.16? ( define ( entry tree ) ( car tree )) ( define ( left-branch tree ) ( cadr tree )) ( define ( right-branch tree ) ( caddr tree )) ( define ( make-tree entry left right ) ( list entry left right )) ; Test for all 3 trees in Figure 2.16 ( define tree1 ( list 7 ( list 3 ( list 1 ' () ' ()) ( list 5 ' () ' ())) ( list 9 ' () ( list 11 ' () ' ())))) ( define tree2 ( list 3 ( list 1 ' () ' ()) ( list 7 ( list 5 ' () ' ()) ( list 9 ' () ( list 11 ' () ' ()))))) ( define tree3 ( list 5 ( list 3 ( list 1 ' () ' ()) ' ()) ( list 9 ( list 7 ' () ' ()) ( list 11 ' () ' ())))) ( tree->list-1 tree1 ) ;(1 3 5 7 9 11) ( tree->list-2 tree1 ) ;(1 3 5 7 9 11) ( tree->list-1 tree2 ) ;(1 3 5 7 9 11) ( tree->list-2 tree2 ) ;(1 3 5 7 9 11) ( tree->list-1 tree3 ) ;(1 3 5 7 9 11) ( tree->list-2 tree3 ) ;(1 3 5 7 9 11) ; Ans: Both the procedures produce the same results for every tree ; For all 3 figures in Fig 2.16, list is (1 3 5 7 9 11) ; (b) Do the two procedures have the same order of growth in the number of ; steps required to convert a balanced tree with n elements to a list? ; If not, which one grows more slowly? ; Ans ; tree->list-1 takes O(n log n) time ; tree->list-2 takes O(n) time","title":"2.63"},{"location":"SICP/ch2-abstraction-data/2.64/","text":"2.64 \u00b6 ; The following procedure list->tree converts an ordered list to a balanced ; binary tree. The helper procedure partial-tree takes as arguments an integer ; n and list of at least n elements and constructs a balanced tree containing ; the first n elements of the list. The result returned by partial-tree is a ; pair (formed with cons) whose car is the constructed tree and whose cdr is ; the list of elements not included in the tree. ( define ( list->tree elements ) ( car ( partial-tree elements ( length elements )))) ( define ( partial-tree elts n ) ( if ( = n 0 ) ( cons ' () elts ) ( let (( left-size ( quotient ( - n 1 ) 2 ))) ( let (( left-result ( partial-tree elts left-size ))) ( let (( left-tree ( car left-result )) ( non-left-elts ( cdr left-result )) ( right-size ( - n ( + left-size 1 )))) ( let (( this-entry ( car non-left-elts )) ( right-result ( partial-tree ( cdr non-left-elts ) right-size ))) ( let (( right-tree ( car right-result )) ( remaining-elts ( cdr right-result ))) ( cons ( make-tree this-entry left-tree right-tree ) remaining-elts )))))))) ; (a) Write a short paragraph explaining as clearly as you can how partial-tree ; works. Draw the tree produced by list->tree for the list (1 3 5 7 9 11). ; Procedure `partial-tree` will construct a tree of `elts`, where root is the middle ; element (median) and left-subtree is `partial-tree` of elements less than middle ; element (this-entry) and right-substree is `partial-tree` of elements greater than ; `this-entry` ; For (1 3 5 7 9 11), it constructs the following tree ; 5 ; / \\ ; 1 9 ; \\ / \\ ; 3 7 11 ; (b) What is the order of growth in the number of steps required by list->tree to ; convert a list of n elements? ; T(n) = 2T(n/2) + O(1) ; T(n) = O(n)","title":"2.64"},{"location":"SICP/ch2-abstraction-data/2.64/#264","text":"; The following procedure list->tree converts an ordered list to a balanced ; binary tree. The helper procedure partial-tree takes as arguments an integer ; n and list of at least n elements and constructs a balanced tree containing ; the first n elements of the list. The result returned by partial-tree is a ; pair (formed with cons) whose car is the constructed tree and whose cdr is ; the list of elements not included in the tree. ( define ( list->tree elements ) ( car ( partial-tree elements ( length elements )))) ( define ( partial-tree elts n ) ( if ( = n 0 ) ( cons ' () elts ) ( let (( left-size ( quotient ( - n 1 ) 2 ))) ( let (( left-result ( partial-tree elts left-size ))) ( let (( left-tree ( car left-result )) ( non-left-elts ( cdr left-result )) ( right-size ( - n ( + left-size 1 )))) ( let (( this-entry ( car non-left-elts )) ( right-result ( partial-tree ( cdr non-left-elts ) right-size ))) ( let (( right-tree ( car right-result )) ( remaining-elts ( cdr right-result ))) ( cons ( make-tree this-entry left-tree right-tree ) remaining-elts )))))))) ; (a) Write a short paragraph explaining as clearly as you can how partial-tree ; works. Draw the tree produced by list->tree for the list (1 3 5 7 9 11). ; Procedure `partial-tree` will construct a tree of `elts`, where root is the middle ; element (median) and left-subtree is `partial-tree` of elements less than middle ; element (this-entry) and right-substree is `partial-tree` of elements greater than ; `this-entry` ; For (1 3 5 7 9 11), it constructs the following tree ; 5 ; / \\ ; 1 9 ; \\ / \\ ; 3 7 11 ; (b) What is the order of growth in the number of steps required by list->tree to ; convert a list of n elements? ; T(n) = 2T(n/2) + O(1) ; T(n) = O(n)","title":"2.64"},{"location":"SICP/ch2-abstraction-data/2.65/","text":"2.65 \u00b6 ; Use the results of Exercise 2.63 and Exercise 2.64 to give \u0398(n) implementations ; of `union-set` and `intersection-set` for sets implemented as (balanced) binary ; trees ( define ( entry tree ) ( car tree )) ( define ( left-branch tree ) ( cadr tree )) ( define ( right-branch tree ) ( caddr tree )) ( define ( make-tree entry left right ) ( list entry left right )) ( define ( tree->list tree ) ( define ( copy-to-list tree result-list ) ( if ( null? tree ) result-list ( copy-to-list ( left-branch tree ) ( cons ( entry tree ) ( copy-to-list ( right-branch tree ) result-list ))))) ( copy-to-list tree ' ())) ( define ( list->tree elements ) ( car ( partial-tree elements ( length elements )))) ( define ( partial-tree elts n ) ( if ( = n 0 ) ( cons ' () elts ) ( let (( left-size ( quotient ( - n 1 ) 2 ))) ( let (( left-result ( partial-tree elts left-size ))) ( let (( left-tree ( car left-result )) ( non-left-elts ( cdr left-result )) ( right-size ( - n ( + left-size 1 )))) ( let (( this-entry ( car non-left-elts )) ( right-result ( partial-tree ( cdr non-left-elts ) right-size ))) ( let (( right-tree ( car right-result )) ( remaining-elts ( cdr right-result ))) ( cons ( make-tree this-entry left-tree right-tree ) remaining-elts )))))))) ; Union using ordered list ( define ( union-set-list set1 set2 ) ( cond (( null? set1 ) set2 ) (( null? set2 ) set1 ) ( else ( let (( x1 ( car set1 )) ( x2 ( car set2 ))) ( cond (( = x1 x2 ) ( cons x1 ( union-set-list ( cdr set1 ) ( cdr set2 )))) (( > x1 x2 ) ( cons x2 ( union-set-list set1 ( cdr set2 )))) ( else ( cons x1 ( union-set-list ( cdr set1 ) set2 )))))))) ( define ( union-set set1 set2 ) ( list->tree ( union-set-list ( tree->list set1 ) ( tree->list set2 )))) ; Intersection using ordered list ( define ( intersection-set-list set1 set2 ) ( if ( or ( null? set1 ) ( null? set2 )) ' () ( let (( x1 ( car set1 )) ( x2 ( car set2 ))) ( cond (( = x1 x2 ) ( cons x1 ( intersection-set-list ( cdr set1 ) ( cdr set2 )))) (( < x1 x2 ) ( intersection-set-list ( cdr set1 ) set2 )) (( < x2 x1 ) ( intersection-set-list set1 ( cdr set2 ))))))) ( define ( intersection-set set1 set2 ) ( list->tree ( intersection-set-list ( tree->list set1 ) ( tree->list set2 )))) ( tree->list ( union-set ( list->tree ' ( 1 2 3 5 6 8 12 )) ( list->tree ' ( 5 6 9 10 12 13 15 )))) ; (1 2 3 5 6 8 9 10 12 13 15) ( tree->list ( intersection-set ( list->tree ' ( 1 2 3 5 6 8 12 )) ( list->tree ' ( 5 6 9 10 12 13 15 )))) ; (5 6 12)","title":"2.65"},{"location":"SICP/ch2-abstraction-data/2.65/#265","text":"; Use the results of Exercise 2.63 and Exercise 2.64 to give \u0398(n) implementations ; of `union-set` and `intersection-set` for sets implemented as (balanced) binary ; trees ( define ( entry tree ) ( car tree )) ( define ( left-branch tree ) ( cadr tree )) ( define ( right-branch tree ) ( caddr tree )) ( define ( make-tree entry left right ) ( list entry left right )) ( define ( tree->list tree ) ( define ( copy-to-list tree result-list ) ( if ( null? tree ) result-list ( copy-to-list ( left-branch tree ) ( cons ( entry tree ) ( copy-to-list ( right-branch tree ) result-list ))))) ( copy-to-list tree ' ())) ( define ( list->tree elements ) ( car ( partial-tree elements ( length elements )))) ( define ( partial-tree elts n ) ( if ( = n 0 ) ( cons ' () elts ) ( let (( left-size ( quotient ( - n 1 ) 2 ))) ( let (( left-result ( partial-tree elts left-size ))) ( let (( left-tree ( car left-result )) ( non-left-elts ( cdr left-result )) ( right-size ( - n ( + left-size 1 )))) ( let (( this-entry ( car non-left-elts )) ( right-result ( partial-tree ( cdr non-left-elts ) right-size ))) ( let (( right-tree ( car right-result )) ( remaining-elts ( cdr right-result ))) ( cons ( make-tree this-entry left-tree right-tree ) remaining-elts )))))))) ; Union using ordered list ( define ( union-set-list set1 set2 ) ( cond (( null? set1 ) set2 ) (( null? set2 ) set1 ) ( else ( let (( x1 ( car set1 )) ( x2 ( car set2 ))) ( cond (( = x1 x2 ) ( cons x1 ( union-set-list ( cdr set1 ) ( cdr set2 )))) (( > x1 x2 ) ( cons x2 ( union-set-list set1 ( cdr set2 )))) ( else ( cons x1 ( union-set-list ( cdr set1 ) set2 )))))))) ( define ( union-set set1 set2 ) ( list->tree ( union-set-list ( tree->list set1 ) ( tree->list set2 )))) ; Intersection using ordered list ( define ( intersection-set-list set1 set2 ) ( if ( or ( null? set1 ) ( null? set2 )) ' () ( let (( x1 ( car set1 )) ( x2 ( car set2 ))) ( cond (( = x1 x2 ) ( cons x1 ( intersection-set-list ( cdr set1 ) ( cdr set2 )))) (( < x1 x2 ) ( intersection-set-list ( cdr set1 ) set2 )) (( < x2 x1 ) ( intersection-set-list set1 ( cdr set2 ))))))) ( define ( intersection-set set1 set2 ) ( list->tree ( intersection-set-list ( tree->list set1 ) ( tree->list set2 )))) ( tree->list ( union-set ( list->tree ' ( 1 2 3 5 6 8 12 )) ( list->tree ' ( 5 6 9 10 12 13 15 )))) ; (1 2 3 5 6 8 9 10 12 13 15) ( tree->list ( intersection-set ( list->tree ' ( 1 2 3 5 6 8 12 )) ( list->tree ' ( 5 6 9 10 12 13 15 )))) ; (5 6 12)","title":"2.65"},{"location":"SICP/ch2-abstraction-data/2.66/","text":"2.66 \u00b6 ; Implement the lookup procedure for the case where the set of records is ; structured as a binary tree, ordered by the numerical values of the keys. ( define ( entry tree ) ( car tree )) ( define ( left-branch tree ) ( cadr tree )) ( define ( right-branch tree ) ( caddr tree )) ( define ( key record ) ( car record )) ( define ( lookup given-key set-of-records ) ( cond (( null? set-of-records ) #f ) (( = given-key ( key ( entry set-of-records ))) ( entry set-of-records )) (( < given-key ( key ( entry set-of-records ))) ( lookup given-key ( left-branch set-of-records ))) (( > given-key ( key ( entry set-of-records ))) ( lookup given-key ( right-branch set-of-records ))))) ; Testing ( define tree1 ( list ( cons 7 \"Emp7\" ) ( list ( cons 3 \"Emp3\" ) ( list ( cons 1 \"Emp1\" ) ' () ' ()) ( list ( cons 5 \"Emp5\" ) ' () ' ())) ( list ( cons 9 \"Emp9\" ) ' () ( list ( cons 11 \"Emp11\" ) ' () ' ())))) ( lookup 7 tree1 ) ;(7 . \"Emp7\") ( lookup 12 tree1 ) ;#f","title":"2.66"},{"location":"SICP/ch2-abstraction-data/2.66/#266","text":"; Implement the lookup procedure for the case where the set of records is ; structured as a binary tree, ordered by the numerical values of the keys. ( define ( entry tree ) ( car tree )) ( define ( left-branch tree ) ( cadr tree )) ( define ( right-branch tree ) ( caddr tree )) ( define ( key record ) ( car record )) ( define ( lookup given-key set-of-records ) ( cond (( null? set-of-records ) #f ) (( = given-key ( key ( entry set-of-records ))) ( entry set-of-records )) (( < given-key ( key ( entry set-of-records ))) ( lookup given-key ( left-branch set-of-records ))) (( > given-key ( key ( entry set-of-records ))) ( lookup given-key ( right-branch set-of-records ))))) ; Testing ( define tree1 ( list ( cons 7 \"Emp7\" ) ( list ( cons 3 \"Emp3\" ) ( list ( cons 1 \"Emp1\" ) ' () ' ()) ( list ( cons 5 \"Emp5\" ) ' () ' ())) ( list ( cons 9 \"Emp9\" ) ' () ( list ( cons 11 \"Emp11\" ) ' () ' ())))) ( lookup 7 tree1 ) ;(7 . \"Emp7\") ( lookup 12 tree1 ) ;#f","title":"2.66"},{"location":"SICP/ch2-abstraction-data/2.67/","text":"2.67 \u00b6 ; Define an encoding tree and a sample message: ; (define sample-tree ; (make-code-tree (make-leaf 'A 4) ; (make-code-tree ; (make-leaf 'B 2) ; (make-code-tree ; (make-leaf 'D 1) ; (make-leaf 'C 1))))) ; (define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0)) ; Answer ; Define procedures ( define ( make-leaf symbol weight ) ( list 'leaf symbol weight )) ( define ( leaf? object ) ( eq? ( car object ) 'leaf )) ( define ( symbol-leaf x ) ( cadr x )) ( define ( weight-leaf x ) ( caddr x )) ( define ( make-code-tree left right ) ( list left right ( append ( symbols left ) ( symbols right )) ( + ( weight left ) ( weight right )))) ( define ( left-branch tree ) ( car tree )) ( define ( right-branch tree ) ( cadr tree )) ( define ( symbols tree ) ( if ( leaf? tree ) ( list ( symbol-leaf tree )) ( caddr tree ))) ( define ( weight tree ) ( if ( leaf? tree ) ( weight-leaf tree ) ( cadddr tree ))) ( define ( decode bits tree ) ( define ( decode-1 bits current-branch ) ( if ( null? bits ) ' () ( let (( next-branch ( choose-branch ( car bits ) current-branch ))) ( if ( leaf? next-branch ) ( cons ( symbol-leaf next-branch ) ( decode-1 ( cdr bits ) tree )) ( decode-1 ( cdr bits ) next-branch ))))) ( decode-1 bits tree )) ( define ( choose-branch bit branch ) ( cond (( = bit 0 ) ( left-branch branch )) (( = bit 1 ) ( right-branch branch )) ( else ( error \"bad bit: CHOOSE-BRANCH\" bit )))) ( define ( adjoin-set x set ) ( cond (( null? set ) ( list x )) (( < ( weight x ) ( weight ( car set ))) ( cons x set )) ( else ( cons ( car set ) ( adjoin-set x ( cdr set )))))) ( define ( make-leaf-set pairs ) ( if ( null? pairs ) ' () ( let (( pair ( car pairs ))) ( adjoin-set ( make-leaf ( car pair ) ; symbol ( cadr pair )) ; frequency ( make-leaf-set ( cdr pairs )))))) ( define sample-tree ( make-code-tree ( make-leaf 'A 4 ) ( make-code-tree ( make-leaf 'B 2 ) ( make-code-tree ( make-leaf 'D 1 ) ( make-leaf 'C 1 ))))) ( define sample-message ' ( 0 1 1 0 0 1 0 1 0 1 1 1 0 )) ; Testing ( decode sample-message sample-tree ) ; (0 1 1 0 0 1 0 1 0 1 1 1 0) ; (A D A B B C A) ; (a d a b b c a)","title":"2.67"},{"location":"SICP/ch2-abstraction-data/2.67/#267","text":"; Define an encoding tree and a sample message: ; (define sample-tree ; (make-code-tree (make-leaf 'A 4) ; (make-code-tree ; (make-leaf 'B 2) ; (make-code-tree ; (make-leaf 'D 1) ; (make-leaf 'C 1))))) ; (define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0)) ; Answer ; Define procedures ( define ( make-leaf symbol weight ) ( list 'leaf symbol weight )) ( define ( leaf? object ) ( eq? ( car object ) 'leaf )) ( define ( symbol-leaf x ) ( cadr x )) ( define ( weight-leaf x ) ( caddr x )) ( define ( make-code-tree left right ) ( list left right ( append ( symbols left ) ( symbols right )) ( + ( weight left ) ( weight right )))) ( define ( left-branch tree ) ( car tree )) ( define ( right-branch tree ) ( cadr tree )) ( define ( symbols tree ) ( if ( leaf? tree ) ( list ( symbol-leaf tree )) ( caddr tree ))) ( define ( weight tree ) ( if ( leaf? tree ) ( weight-leaf tree ) ( cadddr tree ))) ( define ( decode bits tree ) ( define ( decode-1 bits current-branch ) ( if ( null? bits ) ' () ( let (( next-branch ( choose-branch ( car bits ) current-branch ))) ( if ( leaf? next-branch ) ( cons ( symbol-leaf next-branch ) ( decode-1 ( cdr bits ) tree )) ( decode-1 ( cdr bits ) next-branch ))))) ( decode-1 bits tree )) ( define ( choose-branch bit branch ) ( cond (( = bit 0 ) ( left-branch branch )) (( = bit 1 ) ( right-branch branch )) ( else ( error \"bad bit: CHOOSE-BRANCH\" bit )))) ( define ( adjoin-set x set ) ( cond (( null? set ) ( list x )) (( < ( weight x ) ( weight ( car set ))) ( cons x set )) ( else ( cons ( car set ) ( adjoin-set x ( cdr set )))))) ( define ( make-leaf-set pairs ) ( if ( null? pairs ) ' () ( let (( pair ( car pairs ))) ( adjoin-set ( make-leaf ( car pair ) ; symbol ( cadr pair )) ; frequency ( make-leaf-set ( cdr pairs )))))) ( define sample-tree ( make-code-tree ( make-leaf 'A 4 ) ( make-code-tree ( make-leaf 'B 2 ) ( make-code-tree ( make-leaf 'D 1 ) ( make-leaf 'C 1 ))))) ( define sample-message ' ( 0 1 1 0 0 1 0 1 0 1 1 1 0 )) ; Testing ( decode sample-message sample-tree ) ; (0 1 1 0 0 1 0 1 0 1 1 1 0) ; (A D A B B C A) ; (a d a b b c a)","title":"2.67"},{"location":"SICP/ch2-abstraction-data/2.68/","text":"2.68 \u00b6 ; The `encode` procedure takes as arguments a message and a tree and produces ; the list of bits that gives the encoded message. ( define ( encode message tree ) ( if ( null? message ) ' () ( append ( encode-symbol ( car message ) tree ) ( encode ( cdr message ) tree )))) ; `encode-symbol` is a procedure, which you must write, that returns the list ; of bits that encodes a given symbol according to a given tree. You should ; design `encode-symbol` so that it signals an error if the symbol is not in ; the tree at all. Test your procedure by encoding the result you obtained in ; Exercise 2.67 with the sample tree and seeing whether it is the same as the ; original sample message. ; Helpers ( define ( make-leaf symbol weight ) ( list 'leaf symbol weight )) ( define ( leaf? object ) ( eq? ( car object ) 'leaf )) ( define ( symbol-leaf x ) ( cadr x )) ( define ( weight-leaf x ) ( caddr x )) ( define ( make-code-tree left right ) ( list left right ( append ( symbols left ) ( symbols right )) ( + ( weight left ) ( weight right )))) ( define ( left-branch tree ) ( car tree )) ( define ( right-branch tree ) ( cadr tree )) ( define ( symbols tree ) ( if ( leaf? tree ) ( list ( symbol-leaf tree )) ( caddr tree ))) ( define ( weight tree ) ( if ( leaf? tree ) ( weight-leaf tree ) ( cadddr tree ))) ( define ( decode bits tree ) ( define ( decode-1 bits current-branch ) ( if ( null? bits ) ' () ( let (( next-branch ( choose-branch ( car bits ) current-branch ))) ( if ( leaf? next-branch ) ( cons ( symbol-leaf next-branch ) ( decode-1 ( cdr bits ) tree )) ( decode-1 ( cdr bits ) next-branch ))))) ( decode-1 bits tree )) ( define ( choose-branch bit branch ) ( cond (( = bit 0 ) ( left-branch branch )) (( = bit 1 ) ( right-branch branch )) ( else ( error \"bad bit: CHOOSE-BRANCH\" bit )))) ( define ( adjoin-set x set ) ( cond (( null? set ) ( list x )) (( < ( weight x ) ( weight ( car set ))) ( cons x set )) ( else ( cons ( car set ) ( adjoin-set x ( cdr set )))))) ( define ( make-leaf-set pairs ) ( if ( null? pairs ) ' () ( let (( pair ( car pairs ))) ( adjoin-set ( make-leaf ( car pair ) ; symbol ( cadr pair )) ; frequency ( make-leaf-set ( cdr pairs )))))) ( define ( element-of-set? x set ) ( cond (( null? set ) false ) (( equal? x ( car set )) true ) ( else ( element-of-set? x ( cdr set ))))) ; Encode-symbol procedure ( define ( encode-symbol symbol tree ) ( cond (( leaf? tree ) ' ()) (( element-of-set? symbol ( symbols tree )) ( let (( left ( left-branch tree )) ( right ( right-branch tree ))) ( if ( element-of-set? symbol ( symbols left )) ( cons 0 ( encode-symbol symbol left )) ( cons 1 ( encode-symbol symbol right ))))) ( else ( error \"Bad symbol\" symbol )))) ; Testing ( define sample-tree ( make-code-tree ( make-leaf 'A 4 ) ( make-code-tree ( make-leaf 'B 2 ) ( make-code-tree ( make-leaf 'D 1 ) ( make-leaf 'C 1 ))))) ( define sample-message ' ( 0 1 1 0 0 1 0 1 0 1 1 1 0 )) ( define decoded-message ( decode sample-message sample-tree )) ( encode decoded-message sample-tree ) ; (0 1 1 0 0 1 0 1 0 1 1 1 0)","title":"2.68"},{"location":"SICP/ch2-abstraction-data/2.68/#268","text":"; The `encode` procedure takes as arguments a message and a tree and produces ; the list of bits that gives the encoded message. ( define ( encode message tree ) ( if ( null? message ) ' () ( append ( encode-symbol ( car message ) tree ) ( encode ( cdr message ) tree )))) ; `encode-symbol` is a procedure, which you must write, that returns the list ; of bits that encodes a given symbol according to a given tree. You should ; design `encode-symbol` so that it signals an error if the symbol is not in ; the tree at all. Test your procedure by encoding the result you obtained in ; Exercise 2.67 with the sample tree and seeing whether it is the same as the ; original sample message. ; Helpers ( define ( make-leaf symbol weight ) ( list 'leaf symbol weight )) ( define ( leaf? object ) ( eq? ( car object ) 'leaf )) ( define ( symbol-leaf x ) ( cadr x )) ( define ( weight-leaf x ) ( caddr x )) ( define ( make-code-tree left right ) ( list left right ( append ( symbols left ) ( symbols right )) ( + ( weight left ) ( weight right )))) ( define ( left-branch tree ) ( car tree )) ( define ( right-branch tree ) ( cadr tree )) ( define ( symbols tree ) ( if ( leaf? tree ) ( list ( symbol-leaf tree )) ( caddr tree ))) ( define ( weight tree ) ( if ( leaf? tree ) ( weight-leaf tree ) ( cadddr tree ))) ( define ( decode bits tree ) ( define ( decode-1 bits current-branch ) ( if ( null? bits ) ' () ( let (( next-branch ( choose-branch ( car bits ) current-branch ))) ( if ( leaf? next-branch ) ( cons ( symbol-leaf next-branch ) ( decode-1 ( cdr bits ) tree )) ( decode-1 ( cdr bits ) next-branch ))))) ( decode-1 bits tree )) ( define ( choose-branch bit branch ) ( cond (( = bit 0 ) ( left-branch branch )) (( = bit 1 ) ( right-branch branch )) ( else ( error \"bad bit: CHOOSE-BRANCH\" bit )))) ( define ( adjoin-set x set ) ( cond (( null? set ) ( list x )) (( < ( weight x ) ( weight ( car set ))) ( cons x set )) ( else ( cons ( car set ) ( adjoin-set x ( cdr set )))))) ( define ( make-leaf-set pairs ) ( if ( null? pairs ) ' () ( let (( pair ( car pairs ))) ( adjoin-set ( make-leaf ( car pair ) ; symbol ( cadr pair )) ; frequency ( make-leaf-set ( cdr pairs )))))) ( define ( element-of-set? x set ) ( cond (( null? set ) false ) (( equal? x ( car set )) true ) ( else ( element-of-set? x ( cdr set ))))) ; Encode-symbol procedure ( define ( encode-symbol symbol tree ) ( cond (( leaf? tree ) ' ()) (( element-of-set? symbol ( symbols tree )) ( let (( left ( left-branch tree )) ( right ( right-branch tree ))) ( if ( element-of-set? symbol ( symbols left )) ( cons 0 ( encode-symbol symbol left )) ( cons 1 ( encode-symbol symbol right ))))) ( else ( error \"Bad symbol\" symbol )))) ; Testing ( define sample-tree ( make-code-tree ( make-leaf 'A 4 ) ( make-code-tree ( make-leaf 'B 2 ) ( make-code-tree ( make-leaf 'D 1 ) ( make-leaf 'C 1 ))))) ( define sample-message ' ( 0 1 1 0 0 1 0 1 0 1 1 1 0 )) ( define decoded-message ( decode sample-message sample-tree )) ( encode decoded-message sample-tree ) ; (0 1 1 0 0 1 0 1 0 1 1 1 0)","title":"2.68"},{"location":"SICP/ch2-abstraction-data/2.69/","text":"2.69 \u00b6 ; The following procedure takes as its argument a list of symbol-frequency pairs ; (where no symbol appears in more than one pair) and generates a Huffman encoding ; tree according to the Huffman algorithm. ( define ( generate-huffman-tree pairs ) ( successive-merge ( make-leaf-set pairs ))) ; `make-leaf-set` is the procedure given above that transforms the list of pairs ; into an ordered set of leaves. `successive-merge` is the procedure you must write, ; using `make-code-tree` to successively merge the smallest-weight elements of the ; set until there is only one element left, which is the desired Huffman tree. (This ; procedure is slightly tricky, but not really complicated. If you find yourself ; designing a complex procedure, then you are almost certainly doing something wrong. ; You can take significant advantage of the fact that we are using an ordered set ; representation.) ; helpers ( define ( make-leaf symbol weight ) ( list 'leaf symbol weight )) ( define ( leaf? object ) ( eq? ( car object ) 'leaf )) ( define ( symbol-leaf x ) ( cadr x )) ( define ( weight-leaf x ) ( caddr x )) ( define ( make-code-tree left right ) ( list left right ( append ( symbols left ) ( symbols right )) ( + ( weight left ) ( weight right )))) ( define ( left-branch tree ) ( car tree )) ( define ( right-branch tree ) ( cadr tree )) ( define ( symbols tree ) ( if ( leaf? tree ) ( list ( symbol-leaf tree )) ( caddr tree ))) ( define ( weight tree ) ( if ( leaf? tree ) ( weight-leaf tree ) ( cadddr tree ))) ( define ( decode bits tree ) ( define ( decode-1 bits current-branch ) ( if ( null? bits ) ' () ( let (( next-branch ( choose-branch ( car bits ) current-branch ))) ( if ( leaf? next-branch ) ( cons ( symbol-leaf next-branch ) ( decode-1 ( cdr bits ) tree )) ( decode-1 ( cdr bits ) next-branch ))))) ( decode-1 bits tree )) ( define ( choose-branch bit branch ) ( cond (( = bit 0 ) ( left-branch branch )) (( = bit 1 ) ( right-branch branch )) ( else ( error \"bad bit: CHOOSE-BRANCH\" bit )))) ( define ( adjoin-set x set ) ( cond (( null? set ) ( list x )) (( < ( weight x ) ( weight ( car set ))) ( cons x set )) ( else ( cons ( car set ) ( adjoin-set x ( cdr set )))))) ( define ( make-leaf-set pairs ) ( if ( null? pairs ) ' () ( let (( pair ( car pairs ))) ( adjoin-set ( make-leaf ( car pair ) ; symbol ( cadr pair )) ; frequency ( make-leaf-set ( cdr pairs )))))) ; Successive merge procedure ( define ( successive-merge leaf-set ) ( if ( null? ( cdr leaf-set )) ( car leaf-set ) ( successive-merge ( adjoin-set ( make-code-tree ( car leaf-set ) ( cadr leaf-set )) ( cddr leaf-set ))))) ; Testing ( generate-huffman-tree ' (( A 4 ) ( B 2 ) ( C 1 ) ( D 1 ))) ; ((leaf a 4) ((leaf b 2) ((leaf d 1) (leaf c 1) (d c) 2) (b d c) 4) (a b d c) 8) ( generate-huffman-tree ' (( A 3 ) ( B 5 ) ( C 8 ) ( D 8 ))) ; (((leaf a 3) (leaf b 5) (a b) 8) ((leaf d 8) (leaf c 8) (d c) 16) (a b d c) 24)","title":"2.69"},{"location":"SICP/ch2-abstraction-data/2.69/#269","text":"; The following procedure takes as its argument a list of symbol-frequency pairs ; (where no symbol appears in more than one pair) and generates a Huffman encoding ; tree according to the Huffman algorithm. ( define ( generate-huffman-tree pairs ) ( successive-merge ( make-leaf-set pairs ))) ; `make-leaf-set` is the procedure given above that transforms the list of pairs ; into an ordered set of leaves. `successive-merge` is the procedure you must write, ; using `make-code-tree` to successively merge the smallest-weight elements of the ; set until there is only one element left, which is the desired Huffman tree. (This ; procedure is slightly tricky, but not really complicated. If you find yourself ; designing a complex procedure, then you are almost certainly doing something wrong. ; You can take significant advantage of the fact that we are using an ordered set ; representation.) ; helpers ( define ( make-leaf symbol weight ) ( list 'leaf symbol weight )) ( define ( leaf? object ) ( eq? ( car object ) 'leaf )) ( define ( symbol-leaf x ) ( cadr x )) ( define ( weight-leaf x ) ( caddr x )) ( define ( make-code-tree left right ) ( list left right ( append ( symbols left ) ( symbols right )) ( + ( weight left ) ( weight right )))) ( define ( left-branch tree ) ( car tree )) ( define ( right-branch tree ) ( cadr tree )) ( define ( symbols tree ) ( if ( leaf? tree ) ( list ( symbol-leaf tree )) ( caddr tree ))) ( define ( weight tree ) ( if ( leaf? tree ) ( weight-leaf tree ) ( cadddr tree ))) ( define ( decode bits tree ) ( define ( decode-1 bits current-branch ) ( if ( null? bits ) ' () ( let (( next-branch ( choose-branch ( car bits ) current-branch ))) ( if ( leaf? next-branch ) ( cons ( symbol-leaf next-branch ) ( decode-1 ( cdr bits ) tree )) ( decode-1 ( cdr bits ) next-branch ))))) ( decode-1 bits tree )) ( define ( choose-branch bit branch ) ( cond (( = bit 0 ) ( left-branch branch )) (( = bit 1 ) ( right-branch branch )) ( else ( error \"bad bit: CHOOSE-BRANCH\" bit )))) ( define ( adjoin-set x set ) ( cond (( null? set ) ( list x )) (( < ( weight x ) ( weight ( car set ))) ( cons x set )) ( else ( cons ( car set ) ( adjoin-set x ( cdr set )))))) ( define ( make-leaf-set pairs ) ( if ( null? pairs ) ' () ( let (( pair ( car pairs ))) ( adjoin-set ( make-leaf ( car pair ) ; symbol ( cadr pair )) ; frequency ( make-leaf-set ( cdr pairs )))))) ; Successive merge procedure ( define ( successive-merge leaf-set ) ( if ( null? ( cdr leaf-set )) ( car leaf-set ) ( successive-merge ( adjoin-set ( make-code-tree ( car leaf-set ) ( cadr leaf-set )) ( cddr leaf-set ))))) ; Testing ( generate-huffman-tree ' (( A 4 ) ( B 2 ) ( C 1 ) ( D 1 ))) ; ((leaf a 4) ((leaf b 2) ((leaf d 1) (leaf c 1) (d c) 2) (b d c) 4) (a b d c) 8) ( generate-huffman-tree ' (( A 3 ) ( B 5 ) ( C 8 ) ( D 8 ))) ; (((leaf a 3) (leaf b 5) (a b) 8) ((leaf d 8) (leaf c 8) (d c) 16) (a b d c) 24)","title":"2.69"},{"location":"SICP/ch2-abstraction-data/2.70/","text":"2.70 \u00b6 ; The following eight-symbol alphabet with associated relative frequencies was ; designed to efficiently encode the lyrics of 1950s rock songs. (Note that the ; \u201csymbols\u201d of an \u201calphabet\u201d need not be individual letters.) ; ``` ; A 2 GET 2 SHA 3 WAH 1 ; BOOM 1 JOB 2 NA 16 YIP 9 ; ``` ; Use `generate-huffman-tree` (Exercise 2.69) to generate a corresponding Huffman ; tree, and use encode (Exercise 2.68) to encode the following message: ; Get a job ; Sha na na na na na na na na ; Get a job ; Sha na na na na na na na na ; Wah yip yip yip yip yip yip yip yip yip ; Sha boom ; ; How many bits are required for the encoding? What is the smallest number of bits ; that would be needed to encode this song if we used a fixed-length code for the ; eight-symbol alphabet? ; Helpers ( define ( make-leaf symbol weight ) ( list 'leaf symbol weight )) ( define ( leaf? object ) ( eq? ( car object ) 'leaf )) ( define ( symbol-leaf x ) ( cadr x )) ( define ( weight-leaf x ) ( caddr x )) ( define ( make-code-tree left right ) ( list left right ( append ( symbols left ) ( symbols right )) ( + ( weight left ) ( weight right )))) ( define ( left-branch tree ) ( car tree )) ( define ( right-branch tree ) ( cadr tree )) ( define ( symbols tree ) ( if ( leaf? tree ) ( list ( symbol-leaf tree )) ( caddr tree ))) ( define ( weight tree ) ( if ( leaf? tree ) ( weight-leaf tree ) ( cadddr tree ))) ( define ( decode bits tree ) ( define ( decode-1 bits current-branch ) ( if ( null? bits ) ' () ( let (( next-branch ( choose-branch ( car bits ) current-branch ))) ( if ( leaf? next-branch ) ( cons ( symbol-leaf next-branch ) ( decode-1 ( cdr bits ) tree )) ( decode-1 ( cdr bits ) next-branch ))))) ( decode-1 bits tree )) ( define ( choose-branch bit branch ) ( cond (( = bit 0 ) ( left-branch branch )) (( = bit 1 ) ( right-branch branch )) ( else ( error \"bad bit: CHOOSE-BRANCH\" bit )))) ( define ( adjoin-set x set ) ( cond (( null? set ) ( list x )) (( < ( weight x ) ( weight ( car set ))) ( cons x set )) ( else ( cons ( car set ) ( adjoin-set x ( cdr set )))))) ( define ( make-leaf-set pairs ) ( if ( null? pairs ) ' () ( let (( pair ( car pairs ))) ( adjoin-set ( make-leaf ( car pair ) ; symbol ( cadr pair )) ; frequency ( make-leaf-set ( cdr pairs )))))) ; Successive merge procedure ( define ( successive-merge leaf-set ) ( if ( null? ( cdr leaf-set )) ( car leaf-set ) ( successive-merge ( adjoin-set ( make-code-tree ( car leaf-set ) ( cadr leaf-set )) ( cddr leaf-set ))))) ( define ( generate-huffman-tree pairs ) ( successive-merge ( make-leaf-set pairs ))) ( define ( encode message tree ) ( if ( null? message ) ' () ( append ( encode-symbol ( car message ) tree ) ( encode ( cdr message ) tree )))) ( define ( encode-symbol symbol tree ) ( cond (( leaf? tree ) ' ()) (( element-of-set? symbol ( symbols tree )) ( let (( left ( left-branch tree )) ( right ( right-branch tree ))) ( if ( element-of-set? symbol ( symbols left )) ( cons 0 ( encode-symbol symbol left )) ( cons 1 ( encode-symbol symbol right ))))) ( else ( error \"Bad symbol\" symbol )))) ( define ( element-of-set? x set ) ( cond (( null? set ) false ) (( equal? x ( car set )) true ) ( else ( element-of-set? x ( cdr set ))))) ; Answer ( define alphabet ' (( A 2 ) ( GET 2 ) ( SHA 3 ) ( WAH 1 ) ( BOOM 1 ) ( JOB 2 ) ( NA 16 ) ( YIP 9 ))) ( define song-tree ( generate-huffman-tree alphabet )) ; ((leaf na 16) ((leaf yip 9) (((leaf a 2) ((leaf boom 1) (leaf wah 1) (boom wah) 2) ; (a boom wah) 4) ((leaf sha 3) ((leaf job 2) (leaf get 2) (job get) 4) (sha job get) ; 7) (a boom wah sha job get) 11) (yip a boom wah sha job get) 20) (na yip a boom wah ; sha job get) 36) ( define song ' ( GET A JOB SHA NA NA NA NA NA NA NA NA GET A JOB SHA NA NA NA NA NA NA NA NA WAH YIP YIP YIP YIP YIP YIP YIP YIP YIP SHA BOOM )) ( define encoded-song ( encode song song-tree )) ( length encoded-song ) ;Value: 84 ; Hence \"84 bits\" are needed ; If we used fixed length encoding, we need 36 x 3 = \"108 bits\"","title":"2.70"},{"location":"SICP/ch2-abstraction-data/2.70/#270","text":"; The following eight-symbol alphabet with associated relative frequencies was ; designed to efficiently encode the lyrics of 1950s rock songs. (Note that the ; \u201csymbols\u201d of an \u201calphabet\u201d need not be individual letters.) ; ``` ; A 2 GET 2 SHA 3 WAH 1 ; BOOM 1 JOB 2 NA 16 YIP 9 ; ``` ; Use `generate-huffman-tree` (Exercise 2.69) to generate a corresponding Huffman ; tree, and use encode (Exercise 2.68) to encode the following message: ; Get a job ; Sha na na na na na na na na ; Get a job ; Sha na na na na na na na na ; Wah yip yip yip yip yip yip yip yip yip ; Sha boom ; ; How many bits are required for the encoding? What is the smallest number of bits ; that would be needed to encode this song if we used a fixed-length code for the ; eight-symbol alphabet? ; Helpers ( define ( make-leaf symbol weight ) ( list 'leaf symbol weight )) ( define ( leaf? object ) ( eq? ( car object ) 'leaf )) ( define ( symbol-leaf x ) ( cadr x )) ( define ( weight-leaf x ) ( caddr x )) ( define ( make-code-tree left right ) ( list left right ( append ( symbols left ) ( symbols right )) ( + ( weight left ) ( weight right )))) ( define ( left-branch tree ) ( car tree )) ( define ( right-branch tree ) ( cadr tree )) ( define ( symbols tree ) ( if ( leaf? tree ) ( list ( symbol-leaf tree )) ( caddr tree ))) ( define ( weight tree ) ( if ( leaf? tree ) ( weight-leaf tree ) ( cadddr tree ))) ( define ( decode bits tree ) ( define ( decode-1 bits current-branch ) ( if ( null? bits ) ' () ( let (( next-branch ( choose-branch ( car bits ) current-branch ))) ( if ( leaf? next-branch ) ( cons ( symbol-leaf next-branch ) ( decode-1 ( cdr bits ) tree )) ( decode-1 ( cdr bits ) next-branch ))))) ( decode-1 bits tree )) ( define ( choose-branch bit branch ) ( cond (( = bit 0 ) ( left-branch branch )) (( = bit 1 ) ( right-branch branch )) ( else ( error \"bad bit: CHOOSE-BRANCH\" bit )))) ( define ( adjoin-set x set ) ( cond (( null? set ) ( list x )) (( < ( weight x ) ( weight ( car set ))) ( cons x set )) ( else ( cons ( car set ) ( adjoin-set x ( cdr set )))))) ( define ( make-leaf-set pairs ) ( if ( null? pairs ) ' () ( let (( pair ( car pairs ))) ( adjoin-set ( make-leaf ( car pair ) ; symbol ( cadr pair )) ; frequency ( make-leaf-set ( cdr pairs )))))) ; Successive merge procedure ( define ( successive-merge leaf-set ) ( if ( null? ( cdr leaf-set )) ( car leaf-set ) ( successive-merge ( adjoin-set ( make-code-tree ( car leaf-set ) ( cadr leaf-set )) ( cddr leaf-set ))))) ( define ( generate-huffman-tree pairs ) ( successive-merge ( make-leaf-set pairs ))) ( define ( encode message tree ) ( if ( null? message ) ' () ( append ( encode-symbol ( car message ) tree ) ( encode ( cdr message ) tree )))) ( define ( encode-symbol symbol tree ) ( cond (( leaf? tree ) ' ()) (( element-of-set? symbol ( symbols tree )) ( let (( left ( left-branch tree )) ( right ( right-branch tree ))) ( if ( element-of-set? symbol ( symbols left )) ( cons 0 ( encode-symbol symbol left )) ( cons 1 ( encode-symbol symbol right ))))) ( else ( error \"Bad symbol\" symbol )))) ( define ( element-of-set? x set ) ( cond (( null? set ) false ) (( equal? x ( car set )) true ) ( else ( element-of-set? x ( cdr set ))))) ; Answer ( define alphabet ' (( A 2 ) ( GET 2 ) ( SHA 3 ) ( WAH 1 ) ( BOOM 1 ) ( JOB 2 ) ( NA 16 ) ( YIP 9 ))) ( define song-tree ( generate-huffman-tree alphabet )) ; ((leaf na 16) ((leaf yip 9) (((leaf a 2) ((leaf boom 1) (leaf wah 1) (boom wah) 2) ; (a boom wah) 4) ((leaf sha 3) ((leaf job 2) (leaf get 2) (job get) 4) (sha job get) ; 7) (a boom wah sha job get) 11) (yip a boom wah sha job get) 20) (na yip a boom wah ; sha job get) 36) ( define song ' ( GET A JOB SHA NA NA NA NA NA NA NA NA GET A JOB SHA NA NA NA NA NA NA NA NA WAH YIP YIP YIP YIP YIP YIP YIP YIP YIP SHA BOOM )) ( define encoded-song ( encode song song-tree )) ( length encoded-song ) ;Value: 84 ; Hence \"84 bits\" are needed ; If we used fixed length encoding, we need 36 x 3 = \"108 bits\"","title":"2.70"},{"location":"SICP/ch2-abstraction-data/2.71/","text":"2.71 \u00b6 ; Suppose we have a Huffman tree for an alphabet of n symbols, and that the ; relative frequencies of the symbols are $1, 2, 4, . . . , 2^{n\u22121}$. Sketch the ; tree for n = 5; for n = 10. In such a tree (for general n) how many bits ; are required to encode the most frequent symbol? The least frequent symbol? ; For n=5 ; (a b c d e) 31 ; / \\ ; (a b c d) 15 [e 16] ; / \\ ; (a b c) 7 [d 8] ; / \\ ; (a b) 3 [c 4] ; / \\ ; [a 1] [b 2] ; Number of bits for most frequent symbol = 1 ; Number of bits for least frequent symbol = n - 1","title":"2.71"},{"location":"SICP/ch2-abstraction-data/2.71/#271","text":"; Suppose we have a Huffman tree for an alphabet of n symbols, and that the ; relative frequencies of the symbols are $1, 2, 4, . . . , 2^{n\u22121}$. Sketch the ; tree for n = 5; for n = 10. In such a tree (for general n) how many bits ; are required to encode the most frequent symbol? The least frequent symbol? ; For n=5 ; (a b c d e) 31 ; / \\ ; (a b c d) 15 [e 16] ; / \\ ; (a b c) 7 [d 8] ; / \\ ; (a b) 3 [c 4] ; / \\ ; [a 1] [b 2] ; Number of bits for most frequent symbol = 1 ; Number of bits for least frequent symbol = n - 1","title":"2.71"},{"location":"SICP/ch2-abstraction-data/2.72/","text":"2.72 \u00b6 ; Consider the encoding procedure that you designed in Exercise 2.68. What is the ; order of growth in the number of steps needed to encode a symbol? Be sure to ; include the number of steps needed to search the symbol list at each node ; encountered. To answer this question in general is difficult. Consider the ; special case where the relative frequencies of the n symbols are as described ; in Exercise 2.71, and give the order of growth (as a function of n) of the number ; of steps needed to encode the most frequent and least frequent symbols in the ; alphabet. ; ================================================================== ; Source: http://community.schemewiki.org/?sicp-ex-2.72 ; ================================================================== ; For the encode-symbol procedure in 2.68: ; Search the symbol list at each node: O(n) time ; Then take log_n branches ; Total: O(n * log_n) ; For the special case described in 2.71: ; 1. Encoding the most frequent symbol: ; Search through symbol list: O(n) time ; Take the first single branch, since it will be at the top of the list: constant ; Total: O(n) ; 2. Encoding the least frequent symbol: ; Search through symbol list at each level: O(n) time ; Take the next branch, since we are only removing one node, it would be: O(n - 1) ; Total: O(n * (n - 1)), or O(n^2)","title":"2.72"},{"location":"SICP/ch2-abstraction-data/2.72/#272","text":"; Consider the encoding procedure that you designed in Exercise 2.68. What is the ; order of growth in the number of steps needed to encode a symbol? Be sure to ; include the number of steps needed to search the symbol list at each node ; encountered. To answer this question in general is difficult. Consider the ; special case where the relative frequencies of the n symbols are as described ; in Exercise 2.71, and give the order of growth (as a function of n) of the number ; of steps needed to encode the most frequent and least frequent symbols in the ; alphabet. ; ================================================================== ; Source: http://community.schemewiki.org/?sicp-ex-2.72 ; ================================================================== ; For the encode-symbol procedure in 2.68: ; Search the symbol list at each node: O(n) time ; Then take log_n branches ; Total: O(n * log_n) ; For the special case described in 2.71: ; 1. Encoding the most frequent symbol: ; Search through symbol list: O(n) time ; Take the first single branch, since it will be at the top of the list: constant ; Total: O(n) ; 2. Encoding the least frequent symbol: ; Search through symbol list at each level: O(n) time ; Take the next branch, since we are only removing one node, it would be: O(n - 1) ; Total: O(n * (n - 1)), or O(n^2)","title":"2.72"},{"location":"SICP/ch2-abstraction-data/2.73/","text":"2.73 \u00b6 ; Section 2.3.2 described a program that performs symbolic differentiation: ( define ( deriv exp var ) ( cond (( number? exp ) 0 ) (( variable? exp ) ( if ( same-variable? exp var ) 1 0 )) (( sum? exp ) ( make-sum ( deriv ( addend exp ) var ) ( deriv ( augend exp ) var ))) (( product? exp ) ( make-sum ( make-product ( multiplier exp ) ( deriv ( multiplicand exp ) var )) ( make-product ( deriv ( multiplier exp ) var ) ( multiplicand exp )))) ( else ( error \"unknown expression type: DERIV\" exp )))) ; We can regard this program as performing a dispatch on the type of the expression ; to be differentiated. In this situation the \u201ctype tag\u201d of the datum is the ; algebraic operator symbol (such as +) and the operation being performed is deriv. ; We can transform this program into data-directed style by rewriting the basic ; derivative procedure as ( define ( deriv exp var ) ( cond (( number? exp ) 0 ) (( variable? exp ) ( if ( same-variable? exp var ) 1 0 )) ( else (( get 'deriv ( operator exp )) ( operands exp ) var )))) ( define ( operator exp ) ( car exp )) ( define ( operands exp ) ( cdr exp )) ; (a) Explain what was done above. Why can\u2019t we assimilate the predicates number? ; and variable? into the data-directed dispatch? ; Ans: ; number? and variable? do not use any operator or operands. Hence there's no need ; of dispatch method ; (b) Write the procedures for derivatives of sums and products, and the auxiliary ; code required to install them in the table used by the program above ; Ans: ( define ( deriv-sum exp var ) ( make-sum ( deriv ( addend exp ) var ) ( deriv ( augend exp ) var ))) ( define ( deriv-product exp var ) ( make-sum ( make-product ( multiplier exp ) ( deriv ( multiplicand exp ) var )) ( make-product ( deriv ( multiplier exp ) var ) ( multiplicand exp )))) ( deriv ( install-deriv ) ( put 'deriv '+ deriv-sum ) ( put 'deriv '* deriv-product ) 'done ) ; (c) Choose any additional differentiation rule that you like, such as the one for ; exponents (Exercise 2.56), and install it in this data-directed system. ; Ans: ( define ( deriv-expo exp var ) ( define b ( base exp )) ( define e ( exponent exp )) ( make-product e ( make-product ( make-exp b ( make-sum e -1 )) ( deriv b var )))) ( define ( install-expo ) ( put 'deriv '** deriv-expo )) ; (d) In this simple algebraic manipulator the type of an expression is the algebraic ; operator that binds it together. Suppose, however, we indexed the procedures ; in the opposite way, so that the dispatch line in `deriv` looked like ; ; ((get (operator exp) 'deriv) (operands exp) var) ; ; What corresponding changes to the derivative system are required? ; Ans: ; We need to reverse the map ( put '+ 'deriv deriv-sum ) ( put '* 'deriv deriv-product )","title":"2.73"},{"location":"SICP/ch2-abstraction-data/2.73/#273","text":"; Section 2.3.2 described a program that performs symbolic differentiation: ( define ( deriv exp var ) ( cond (( number? exp ) 0 ) (( variable? exp ) ( if ( same-variable? exp var ) 1 0 )) (( sum? exp ) ( make-sum ( deriv ( addend exp ) var ) ( deriv ( augend exp ) var ))) (( product? exp ) ( make-sum ( make-product ( multiplier exp ) ( deriv ( multiplicand exp ) var )) ( make-product ( deriv ( multiplier exp ) var ) ( multiplicand exp )))) ( else ( error \"unknown expression type: DERIV\" exp )))) ; We can regard this program as performing a dispatch on the type of the expression ; to be differentiated. In this situation the \u201ctype tag\u201d of the datum is the ; algebraic operator symbol (such as +) and the operation being performed is deriv. ; We can transform this program into data-directed style by rewriting the basic ; derivative procedure as ( define ( deriv exp var ) ( cond (( number? exp ) 0 ) (( variable? exp ) ( if ( same-variable? exp var ) 1 0 )) ( else (( get 'deriv ( operator exp )) ( operands exp ) var )))) ( define ( operator exp ) ( car exp )) ( define ( operands exp ) ( cdr exp )) ; (a) Explain what was done above. Why can\u2019t we assimilate the predicates number? ; and variable? into the data-directed dispatch? ; Ans: ; number? and variable? do not use any operator or operands. Hence there's no need ; of dispatch method ; (b) Write the procedures for derivatives of sums and products, and the auxiliary ; code required to install them in the table used by the program above ; Ans: ( define ( deriv-sum exp var ) ( make-sum ( deriv ( addend exp ) var ) ( deriv ( augend exp ) var ))) ( define ( deriv-product exp var ) ( make-sum ( make-product ( multiplier exp ) ( deriv ( multiplicand exp ) var )) ( make-product ( deriv ( multiplier exp ) var ) ( multiplicand exp )))) ( deriv ( install-deriv ) ( put 'deriv '+ deriv-sum ) ( put 'deriv '* deriv-product ) 'done ) ; (c) Choose any additional differentiation rule that you like, such as the one for ; exponents (Exercise 2.56), and install it in this data-directed system. ; Ans: ( define ( deriv-expo exp var ) ( define b ( base exp )) ( define e ( exponent exp )) ( make-product e ( make-product ( make-exp b ( make-sum e -1 )) ( deriv b var )))) ( define ( install-expo ) ( put 'deriv '** deriv-expo )) ; (d) In this simple algebraic manipulator the type of an expression is the algebraic ; operator that binds it together. Suppose, however, we indexed the procedures ; in the opposite way, so that the dispatch line in `deriv` looked like ; ; ((get (operator exp) 'deriv) (operands exp) var) ; ; What corresponding changes to the derivative system are required? ; Ans: ; We need to reverse the map ( put '+ 'deriv deriv-sum ) ( put '* 'deriv deriv-product )","title":"2.73"},{"location":"SICP/ch2-abstraction-data/2.74/","text":"2.74 \u00b6 ; Insatiable Enterprises, Inc., is a highly decentralized conglomerate company ; consisting of a large number of independent divisions located all over the world. ; The company\u2019s computer facilities have just been interconnected by means of a ; clever network-interfacing scheme that makes the entire network appear to any user ; to be a single computer. Insatiable\u2019s president, in her first attempt to exploit ; the ability of the network to extract administrative information from division ; files, is dismayed to discover that, although all the division files have been ; implemented as data structures in Scheme, the particular data structure used ; varies from division to division. A meeting of division managers is hastily called ; to search for a strategy to integrate the files that will satisfy headquarters\u2019 ; needs while preserving the existing autonomy of the divisions. ; Show how such a strategy can be implemented with data- directed programming. As an ; example, suppose that each division\u2019s personnel records consist of a single file, ; which contains a set of records keyed on employees\u2019 names. The structure of the set ; varies from division to division. Furthermore, each employee\u2019s record is itself a ; set (structured differently from division to division) that contains information ; keyed under identifiers such as address and salary. In particular: ; (a) Implement for headquarters a `get-record` procedure that retrieves a specified ; employee\u2019s record from a specified personnel file. The procedure should be ; applicable to any division\u2019s file. Explain how the individual divisions\u2019 files ; should be structured. In particular, what type information must be supplied? ; Ans: ; Headquarter should have the following structure with division name and file ( define ( make-hq-file division file ) ( cons division file )) ( define ( get-division file ) ( car file )) ( define ( get-file file ) ( cdr file )) ; `get-record` method ( define ( get-record name file ) (( get 'get-record ( get-division file )) name ( get-file file ))) ; (b) Implement for headquarters a `get-salary` procedure that returns the salary ; information from a given employee\u2019s record from any division\u2019s personnel file. ; How should the record be structured in order to make this operation work? ( define ( make-hq-record division record ) ( cons division record )) ( define ( get-record-division record ) ( car record )) ( define ( get-record-hq record ) ( cdr record )) ( define ( get-salary file ) (( get 'get-salary ( get-division file )) ( get-record-hq file ))) ; (c) Implement for headquarters a `find-employee-record` procedure. This should ; search all the divisions\u2019 files for the record of a given employee and return ; the record. Assume that this procedure takes as arguments an employee\u2019s name ; and a list of all the divisions\u2019 files. ( define ( find-employee-record name files ) ( cond (( null? files ) ' ()) (( not ( null? ( get-record name ( car files )))) ( get-record name ( car files ))) ( else ( find-employee-record name ( cdr files ))))) ; (d) When Insatiable takes over a new company, what changes must be made in order ; to incorporate the new personnel information into the central system? ; Ans: ; The new division's methods should be installed like pacakge ( define ( install-new-company ) ( put 'new-company 'get-record new-company-get-record ) ( put 'new-company 'get-salary new-company-get-salary ) 'done )","title":"2.74"},{"location":"SICP/ch2-abstraction-data/2.74/#274","text":"; Insatiable Enterprises, Inc., is a highly decentralized conglomerate company ; consisting of a large number of independent divisions located all over the world. ; The company\u2019s computer facilities have just been interconnected by means of a ; clever network-interfacing scheme that makes the entire network appear to any user ; to be a single computer. Insatiable\u2019s president, in her first attempt to exploit ; the ability of the network to extract administrative information from division ; files, is dismayed to discover that, although all the division files have been ; implemented as data structures in Scheme, the particular data structure used ; varies from division to division. A meeting of division managers is hastily called ; to search for a strategy to integrate the files that will satisfy headquarters\u2019 ; needs while preserving the existing autonomy of the divisions. ; Show how such a strategy can be implemented with data- directed programming. As an ; example, suppose that each division\u2019s personnel records consist of a single file, ; which contains a set of records keyed on employees\u2019 names. The structure of the set ; varies from division to division. Furthermore, each employee\u2019s record is itself a ; set (structured differently from division to division) that contains information ; keyed under identifiers such as address and salary. In particular: ; (a) Implement for headquarters a `get-record` procedure that retrieves a specified ; employee\u2019s record from a specified personnel file. The procedure should be ; applicable to any division\u2019s file. Explain how the individual divisions\u2019 files ; should be structured. In particular, what type information must be supplied? ; Ans: ; Headquarter should have the following structure with division name and file ( define ( make-hq-file division file ) ( cons division file )) ( define ( get-division file ) ( car file )) ( define ( get-file file ) ( cdr file )) ; `get-record` method ( define ( get-record name file ) (( get 'get-record ( get-division file )) name ( get-file file ))) ; (b) Implement for headquarters a `get-salary` procedure that returns the salary ; information from a given employee\u2019s record from any division\u2019s personnel file. ; How should the record be structured in order to make this operation work? ( define ( make-hq-record division record ) ( cons division record )) ( define ( get-record-division record ) ( car record )) ( define ( get-record-hq record ) ( cdr record )) ( define ( get-salary file ) (( get 'get-salary ( get-division file )) ( get-record-hq file ))) ; (c) Implement for headquarters a `find-employee-record` procedure. This should ; search all the divisions\u2019 files for the record of a given employee and return ; the record. Assume that this procedure takes as arguments an employee\u2019s name ; and a list of all the divisions\u2019 files. ( define ( find-employee-record name files ) ( cond (( null? files ) ' ()) (( not ( null? ( get-record name ( car files )))) ( get-record name ( car files ))) ( else ( find-employee-record name ( cdr files ))))) ; (d) When Insatiable takes over a new company, what changes must be made in order ; to incorporate the new personnel information into the central system? ; Ans: ; The new division's methods should be installed like pacakge ( define ( install-new-company ) ( put 'new-company 'get-record new-company-get-record ) ( put 'new-company 'get-salary new-company-get-salary ) 'done )","title":"2.74"},{"location":"SICP/ch2-abstraction-data/2.75/","text":"2.75 \u00b6 ; Implement the constructor `make-from-mag-ang` in message-passing style. This ; procedure should be analogous to the `make-from-real-imag` procedure given above. ( define ( make-from-mag-ang r a ) ( define ( dispatch op ) ( cond (( eq? op 'real-part ) ( * r ( cos a ))) (( eq? op 'imag-part ) ( * r ( sin a ))) (( eq? op 'magnitude ) r ) (( eq? op 'angle ) a ) ( else ( error \"Unknown op: MAKE-FROM-MAG-ANG\" op )))))","title":"2.75"},{"location":"SICP/ch2-abstraction-data/2.75/#275","text":"; Implement the constructor `make-from-mag-ang` in message-passing style. This ; procedure should be analogous to the `make-from-real-imag` procedure given above. ( define ( make-from-mag-ang r a ) ( define ( dispatch op ) ( cond (( eq? op 'real-part ) ( * r ( cos a ))) (( eq? op 'imag-part ) ( * r ( sin a ))) (( eq? op 'magnitude ) r ) (( eq? op 'angle ) a ) ( else ( error \"Unknown op: MAKE-FROM-MAG-ANG\" op )))))","title":"2.75"},{"location":"SICP/ch2-abstraction-data/2.76/","text":"2.76 \u00b6 ; As a large system with generic operations evolves, new types of data objects or ; new operations may be needed. For each of the three strategies \u2014 generic operations ; with explicit dispatch, data-directed style, and message-passing-style \u2014 describe ; the changes that must be made to a system in order to add new types or new ; operations. Which organization would be most appropriate for a system in which ; new types must often be added? Which would be most appropriate for a system in ; which new operations must often be added? ; Ans ; * Use data-directed approach when new operations are added ; * Use message-passing approach when new types are added","title":"2.76"},{"location":"SICP/ch2-abstraction-data/2.76/#276","text":"; As a large system with generic operations evolves, new types of data objects or ; new operations may be needed. For each of the three strategies \u2014 generic operations ; with explicit dispatch, data-directed style, and message-passing-style \u2014 describe ; the changes that must be made to a system in order to add new types or new ; operations. Which organization would be most appropriate for a system in which ; new types must often be added? Which would be most appropriate for a system in ; which new operations must often be added? ; Ans ; * Use data-directed approach when new operations are added ; * Use message-passing approach when new types are added","title":"2.76"},{"location":"SICP/ch2-abstraction-data/2.77/","text":"2.77 \u00b6 ; Louis Reasoner tries to evaluate the expression (magnitude z) where z is the ; object shown in Figure 2.24. To his surprise, instead of the answer 5 he gets ; an error message from `apply-generic`, saying there is no method for the operation ; magnitude on the types (complex). He shows this interaction to Alyssa P. Hacker, ; who says \u201cThe problem is that the complex-number selectors were never defined for ; complex numbers, just for polar and rectangular numbers. All you have to do to make ; this work is add the following to the complex package:\u201d ; ``` ; (put 'real-part '(complex) real-part) ; (put 'imag-part '(complex) imag-part) ; (put 'magnitude '(complex) magnitude) ; (put 'angle '(complex) angle) ; ``` ; Describe in detail why this works. As an example, trace through all the procedures ; called in evaluating the expression `(magnitude z)` where `z` is the object shown in ; Figure 2.24. In particular, how many times is `apply-generic` invoked? What procedure ; is dispatched to in each case? ; Testing ( load \"arithmetic-package.scm\" ) ( put 'real-part ' ( complex ) real-part ) ( put 'imag-part ' ( complex ) imag-part ) ( put 'magnitude ' ( complex ) magnitude ) ( put 'angle ' ( complex ) angle ) ( define z ( make-complex-from-real-imag 3 4 )) ( magnitude z ) ;Value: 5 ; Answer ; --------------- ; We cannot interact with methods not defined as interface in the \"arithmetic-package\" ; Hence, adding the above lines makes it accessible for complex type ; (make-complex-from-real-imag 3 4) ; => (complex rectangular 3 4) ; ; (magnitude z) ; => (magnitude '(complex rectangular 3 4)) ; => (apply-generic 'magnitude '(complex rectangular 3 4)) ; => (apply magnitude '(rectangular 3 4)) ; => (magnitude '(rectangular 3 4)) ; => (apply-generic 'magnitude '(rectangular 3 4)) ; => (apply (lambda (z) (sqrt (+ (square (real-part z)) (square (imag-part z))))) ; '(3 4)) ; => 5 ; `apply-generic` is calle twice","title":"2.77"},{"location":"SICP/ch2-abstraction-data/2.77/#277","text":"; Louis Reasoner tries to evaluate the expression (magnitude z) where z is the ; object shown in Figure 2.24. To his surprise, instead of the answer 5 he gets ; an error message from `apply-generic`, saying there is no method for the operation ; magnitude on the types (complex). He shows this interaction to Alyssa P. Hacker, ; who says \u201cThe problem is that the complex-number selectors were never defined for ; complex numbers, just for polar and rectangular numbers. All you have to do to make ; this work is add the following to the complex package:\u201d ; ``` ; (put 'real-part '(complex) real-part) ; (put 'imag-part '(complex) imag-part) ; (put 'magnitude '(complex) magnitude) ; (put 'angle '(complex) angle) ; ``` ; Describe in detail why this works. As an example, trace through all the procedures ; called in evaluating the expression `(magnitude z)` where `z` is the object shown in ; Figure 2.24. In particular, how many times is `apply-generic` invoked? What procedure ; is dispatched to in each case? ; Testing ( load \"arithmetic-package.scm\" ) ( put 'real-part ' ( complex ) real-part ) ( put 'imag-part ' ( complex ) imag-part ) ( put 'magnitude ' ( complex ) magnitude ) ( put 'angle ' ( complex ) angle ) ( define z ( make-complex-from-real-imag 3 4 )) ( magnitude z ) ;Value: 5 ; Answer ; --------------- ; We cannot interact with methods not defined as interface in the \"arithmetic-package\" ; Hence, adding the above lines makes it accessible for complex type ; (make-complex-from-real-imag 3 4) ; => (complex rectangular 3 4) ; ; (magnitude z) ; => (magnitude '(complex rectangular 3 4)) ; => (apply-generic 'magnitude '(complex rectangular 3 4)) ; => (apply magnitude '(rectangular 3 4)) ; => (magnitude '(rectangular 3 4)) ; => (apply-generic 'magnitude '(rectangular 3 4)) ; => (apply (lambda (z) (sqrt (+ (square (real-part z)) (square (imag-part z))))) ; '(3 4)) ; => 5 ; `apply-generic` is calle twice","title":"2.77"},{"location":"SICP/ch2-abstraction-data/2.78/","text":"2.78 \u00b6 ; THe internal procedures in the scheme-number package are essentially nothing more ; than calls to the primitive procedures +, -, etc. It was not possible to use the ; primitives of the language directly because our `type-tag` system requires that ; each data object have a type attached to it. In fact, however, all Lisp ; implementations do have a type system, which they use internally. Primitive ; predicates such as `symbol?` and `number?` determine whether data objects have ; particular types. Modify the definitions of `type-tag`, `contents`, and `attach-tag` ; from Section 2.4.2 so that our generic system takes advantage of Scheme\u2019s ; internal type system. That is to say, the system should work as before except that ; ordinary numbers should be represented simply as Scheme numbers rather than as ; pairs whose car is the symbol `scheme-number` ( define ( attach-tag type-tag contents ) ( if ( eq? type-tag 'scheme-number ) contents ( cons type-tag contents ))) ( define ( type-tag datum ) ( cond (( number? datum ) datum ) (( pair? datum ) ( car datum )) ( else ( error \"Wrong datum TYPE-TAG\" datum )))) ( define ( contents datum ) ( cond (( number? datum ) datum ) (( pair? datum ) ( cdr datum )) ( else ( error \"Wrong datum CONTENGS\" datum )))) ; Testing ( attach-tag 'cos 0.5 ) ;Value 2: (cos . .5) ( attach-tag 'scheme-number 10 ) ;Value: 10 ( type-tag ( attach-tag 'cos 0.5 )) ;Value: cos ( type-tag ( attach-tag 'scheme-number 10 )) ;Value: 10 ( contents ( attach-tag 'cos 0.5 )) ;Value: .5 ( contents ( attach-tag 'scheme-number 10 )) ;Value: 10","title":"2.78"},{"location":"SICP/ch2-abstraction-data/2.78/#278","text":"; THe internal procedures in the scheme-number package are essentially nothing more ; than calls to the primitive procedures +, -, etc. It was not possible to use the ; primitives of the language directly because our `type-tag` system requires that ; each data object have a type attached to it. In fact, however, all Lisp ; implementations do have a type system, which they use internally. Primitive ; predicates such as `symbol?` and `number?` determine whether data objects have ; particular types. Modify the definitions of `type-tag`, `contents`, and `attach-tag` ; from Section 2.4.2 so that our generic system takes advantage of Scheme\u2019s ; internal type system. That is to say, the system should work as before except that ; ordinary numbers should be represented simply as Scheme numbers rather than as ; pairs whose car is the symbol `scheme-number` ( define ( attach-tag type-tag contents ) ( if ( eq? type-tag 'scheme-number ) contents ( cons type-tag contents ))) ( define ( type-tag datum ) ( cond (( number? datum ) datum ) (( pair? datum ) ( car datum )) ( else ( error \"Wrong datum TYPE-TAG\" datum )))) ( define ( contents datum ) ( cond (( number? datum ) datum ) (( pair? datum ) ( cdr datum )) ( else ( error \"Wrong datum CONTENGS\" datum )))) ; Testing ( attach-tag 'cos 0.5 ) ;Value 2: (cos . .5) ( attach-tag 'scheme-number 10 ) ;Value: 10 ( type-tag ( attach-tag 'cos 0.5 )) ;Value: cos ( type-tag ( attach-tag 'scheme-number 10 )) ;Value: 10 ( contents ( attach-tag 'cos 0.5 )) ;Value: .5 ( contents ( attach-tag 'scheme-number 10 )) ;Value: 10","title":"2.78"},{"location":"SICP/ch2-abstraction-data/2.79/","text":"2.79 \u00b6 ; Define a generic equality predicate `equ?` that tests the equality of two numbers, ; and install it in the generic arithmetic package. This operation should work for ; ordinary numbers, rational numbers, and complex numbers. ( load \"arithmetic-package.scm\" ) ; (define (numer x) (apply-generic 'numer x)) ; (define (denom x) (apply-generic 'denom x)) ( define ( equ? x y ) ( apply-generic 'equ? x y )) ; Define `equ?` for each type ( put 'equ? ' ( scheme-number scheme-number ) = ) ; Equality operator for number ( put 'equ? ' ( rational_ rational_ ) ; => Defined inside arithmetic-package itself ( lambda ( x y ) ( and ( = ( numer x ) ( numer y )) ( = ( denom x ) ( denom y ))))) ( put 'equ? ' ( complex complex ) ( lambda ( z1 z2 ) ( and ( = ( real-part z1 ) ( real-part z2 )) ( = ( imag-part z1 ) ( imag-part z2 ))))) ; Testing ( equ? ( make-scheme-number 42 ) ( make-scheme-number 42 )) ;#t ( equ? ( make-scheme-number 42 ) ( make-scheme-number 0 )) ;#f ( equ? ( make-rational 5 10 ) ( make-rational 100 200 )) ;#t ( equ? ( make-complex-from-real-imag 1 2 ) ( make-complex-from-real-imag 1 2 )) ;#t","title":"2.79"},{"location":"SICP/ch2-abstraction-data/2.79/#279","text":"; Define a generic equality predicate `equ?` that tests the equality of two numbers, ; and install it in the generic arithmetic package. This operation should work for ; ordinary numbers, rational numbers, and complex numbers. ( load \"arithmetic-package.scm\" ) ; (define (numer x) (apply-generic 'numer x)) ; (define (denom x) (apply-generic 'denom x)) ( define ( equ? x y ) ( apply-generic 'equ? x y )) ; Define `equ?` for each type ( put 'equ? ' ( scheme-number scheme-number ) = ) ; Equality operator for number ( put 'equ? ' ( rational_ rational_ ) ; => Defined inside arithmetic-package itself ( lambda ( x y ) ( and ( = ( numer x ) ( numer y )) ( = ( denom x ) ( denom y ))))) ( put 'equ? ' ( complex complex ) ( lambda ( z1 z2 ) ( and ( = ( real-part z1 ) ( real-part z2 )) ( = ( imag-part z1 ) ( imag-part z2 ))))) ; Testing ( equ? ( make-scheme-number 42 ) ( make-scheme-number 42 )) ;#t ( equ? ( make-scheme-number 42 ) ( make-scheme-number 0 )) ;#f ( equ? ( make-rational 5 10 ) ( make-rational 100 200 )) ;#t ( equ? ( make-complex-from-real-imag 1 2 ) ( make-complex-from-real-imag 1 2 )) ;#t","title":"2.79"},{"location":"SICP/ch2-abstraction-data/2.80/","text":"2.80 \u00b6 ; Define a generic predicate `=zero?` that tests if its argument is zero, and ; install it in the generic arithmetic package. This operation should work for ; ordinary numbers, rational numbers, and complex numbers. ( load \"arithmetic-package.scm\" ) ( define ( =zero? x ) ( apply-generic '=zero? x )) ; Define `=zero?` in each package ( put '=zero? 'scheme-number ( lambda ( x ) ( = x 0 ))) ( put '=zero? 'rational_ ( lambda ( x ) ( = ( numer x ) 0 ))) ( put '=zero? 'complex ( lambda ( z ) ( = ( real-part z ) ( imag-part z ) 0 ))) ; Testing ( =zero? ( make-scheme-number 0 )) ;#t ( =zero? ( make-rational 0 10 )) ;#t ( =zero? ( make-rational 1 10 )) ;#f ( =zero? ( make-complex-from-real-imag 0 0 )) ;#t ( =zero? ( make-complex-from-real-imag 0 1 )) ;#f","title":"2.80"},{"location":"SICP/ch2-abstraction-data/2.80/#280","text":"; Define a generic predicate `=zero?` that tests if its argument is zero, and ; install it in the generic arithmetic package. This operation should work for ; ordinary numbers, rational numbers, and complex numbers. ( load \"arithmetic-package.scm\" ) ( define ( =zero? x ) ( apply-generic '=zero? x )) ; Define `=zero?` in each package ( put '=zero? 'scheme-number ( lambda ( x ) ( = x 0 ))) ( put '=zero? 'rational_ ( lambda ( x ) ( = ( numer x ) 0 ))) ( put '=zero? 'complex ( lambda ( z ) ( = ( real-part z ) ( imag-part z ) 0 ))) ; Testing ( =zero? ( make-scheme-number 0 )) ;#t ( =zero? ( make-rational 0 10 )) ;#t ( =zero? ( make-rational 1 10 )) ;#f ( =zero? ( make-complex-from-real-imag 0 0 )) ;#t ( =zero? ( make-complex-from-real-imag 0 1 )) ;#f","title":"2.80"},{"location":"SICP/ch2-abstraction-data/2.81/","text":"2.81 \u00b6 ; Louis Reasoner has noticed that `apply-generic` may try to coerce the arguments to ; each other\u2019s type even if they already have the same type. Therefore, he reasons, ; we need to put procedures in the coercion table to coerce arguments of each type to ; their own type. For example, in addition to the `scheme-number->complex` coercion ; shown above, he would do: ( define ( scheme-number->scheme-number n ) n ) ( define ( complex->complex z ) z ) ( put-coercion 'scheme-number 'scheme-number scheme-number->scheme-number ) ( put-coercion 'complex 'complex complex->complex ) ; (a) With Louis\u2019s coercion procedures installed, what hap-pens if apply-generic is ; called with two arguments of type `scheme-number` or two arguments of type ; `complex` for an operation that is not found in the table for those types? ; For example, assume that we\u2019ve defined a generic exponentiation operation: ( define ( exp x y ) ( apply-generic 'exp x y )) ; and have put a procedure for exponentiation in the Scheme-number package but not ; in any other package: ;; following added to Scheme-number package ( put 'exp ' ( scheme-number scheme-number ) ( lambda ( x y ) ( tag ( expt x y )))) ; using primitive expt ; What happens if we call exp with two complex numbers as arguments? ; Ans ; `apply-generic` procedure will be called infinitely ; (b) Is Louis correct that something had to be done about coercion with arguments ; of the same type, or does `apply-generic` work correctly as is? ; Ans ; `apply-generic` works fine as it is. ; (c) Modify `apply-generic` so that it doesn\u2019t try coercion if the two arguments ; have the same type. ( define ( apply-generic op . args ) ( let (( type-tags ( map type-tag args ))) ( let (( proc ( get op type-tags ))) ( if proc ( apply proc ( map contents args )) ( if ( = ( length args ) 2 ) ( let (( type1 ( car type-tags )) ( type2 ( cadr type-tags )) ( a1 ( car args )) ( a2 ( cadr args ))) ( if ( eq? type1 type2 ) ( error \"No method for these types\" ( list op type-tags )) ( let (( t1->t2 ( get-coercion type1 type2 )) ( t2->t1 ( get-coercion type2 type1 ))) ( cond ( t1->t2 ( apply-generic op ( t1->t2 a1 ) a2 )) ( t2->t1 ( apply-generic op a1 ( t2->t1 a2 ))) ( else ( error \"No method for these types\" ( list op type-tags ))))))) ( error \"No method for these types\" ( list op type-tags )))))))","title":"2.81"},{"location":"SICP/ch2-abstraction-data/2.81/#281","text":"; Louis Reasoner has noticed that `apply-generic` may try to coerce the arguments to ; each other\u2019s type even if they already have the same type. Therefore, he reasons, ; we need to put procedures in the coercion table to coerce arguments of each type to ; their own type. For example, in addition to the `scheme-number->complex` coercion ; shown above, he would do: ( define ( scheme-number->scheme-number n ) n ) ( define ( complex->complex z ) z ) ( put-coercion 'scheme-number 'scheme-number scheme-number->scheme-number ) ( put-coercion 'complex 'complex complex->complex ) ; (a) With Louis\u2019s coercion procedures installed, what hap-pens if apply-generic is ; called with two arguments of type `scheme-number` or two arguments of type ; `complex` for an operation that is not found in the table for those types? ; For example, assume that we\u2019ve defined a generic exponentiation operation: ( define ( exp x y ) ( apply-generic 'exp x y )) ; and have put a procedure for exponentiation in the Scheme-number package but not ; in any other package: ;; following added to Scheme-number package ( put 'exp ' ( scheme-number scheme-number ) ( lambda ( x y ) ( tag ( expt x y )))) ; using primitive expt ; What happens if we call exp with two complex numbers as arguments? ; Ans ; `apply-generic` procedure will be called infinitely ; (b) Is Louis correct that something had to be done about coercion with arguments ; of the same type, or does `apply-generic` work correctly as is? ; Ans ; `apply-generic` works fine as it is. ; (c) Modify `apply-generic` so that it doesn\u2019t try coercion if the two arguments ; have the same type. ( define ( apply-generic op . args ) ( let (( type-tags ( map type-tag args ))) ( let (( proc ( get op type-tags ))) ( if proc ( apply proc ( map contents args )) ( if ( = ( length args ) 2 ) ( let (( type1 ( car type-tags )) ( type2 ( cadr type-tags )) ( a1 ( car args )) ( a2 ( cadr args ))) ( if ( eq? type1 type2 ) ( error \"No method for these types\" ( list op type-tags )) ( let (( t1->t2 ( get-coercion type1 type2 )) ( t2->t1 ( get-coercion type2 type1 ))) ( cond ( t1->t2 ( apply-generic op ( t1->t2 a1 ) a2 )) ( t2->t1 ( apply-generic op a1 ( t2->t1 a2 ))) ( else ( error \"No method for these types\" ( list op type-tags ))))))) ( error \"No method for these types\" ( list op type-tags )))))))","title":"2.81"},{"location":"SICP/ch2-abstraction-data/2.82/","text":"2.82 \u00b6 ; Show how to generalize `apply-generic` to handle coercion in the general case of ; multiple arguments. One strategy is to attempt to coerce all the arguments to ; the type of the first argument, then to the type of the second argument, and so ; on. Give an example of a situation where this strategy (and likewise the ; two-argument version given above) is not sufficiently general. (Hint: Consider ; the case where there are some suitable mixed-type operations present in the table ; that will not be tried.) ; Source: [https://wizardbook.wordpress.com/2010/12/08/exercise-2-82/](https://wizardbook.wordpress.com/2010/12/08/exercise-2-82/) ( define ( apply-generic op . args ) ( define ( all-coercable? coerce-procs ) ( not ( member #f coerce-procs ))) ( define ( coerce-args coercion-procs args ) ( map ( lambda ( coerce-proc arg ) ( coerce-proc arg )) coercion-procs args )) ; attempt to coerce all args into a common type among the args ( define ( apply-with-coercion arg-types ) ; attempt to coerce all args using each tag-type in turn ; it's a scoped procedure to keep the original arguments (arg-types) for error reporting ( define ( coerce-types tags ) ( if ( null? tags ) ; all targets exhausted ( error \"No method for these types - APPLY-GENERIC\" ( list op arg-types )) ( let* (( target-type ( car tags )) ( arg-coercions ( map ; get all the coercion procedures from the target ( lambda ( coerce-from ) ( if ( eq? coerce-from target-type ) identity ( get-coercion coerce-from target-type ))) arg-types ))) ( if ( all-coercable? arg-coercions ) ; the target type is valid if all the args can be coerced ( apply apply-generic op ( coerce-args arg-coercions args )) ; target-type is not valid, so try the next one in the list ( coerce-types ( cdr tags )))))) ; try the next target type ( coerce-types arg-types )) ( let* (( type-tags ( map type-tag args )) ( proc ( get op type-tags ))) ( if proc ( apply proc ( map contents args )) ( apply-with-coercion type-tags ))))","title":"2.82"},{"location":"SICP/ch2-abstraction-data/2.82/#282","text":"; Show how to generalize `apply-generic` to handle coercion in the general case of ; multiple arguments. One strategy is to attempt to coerce all the arguments to ; the type of the first argument, then to the type of the second argument, and so ; on. Give an example of a situation where this strategy (and likewise the ; two-argument version given above) is not sufficiently general. (Hint: Consider ; the case where there are some suitable mixed-type operations present in the table ; that will not be tried.) ; Source: [https://wizardbook.wordpress.com/2010/12/08/exercise-2-82/](https://wizardbook.wordpress.com/2010/12/08/exercise-2-82/) ( define ( apply-generic op . args ) ( define ( all-coercable? coerce-procs ) ( not ( member #f coerce-procs ))) ( define ( coerce-args coercion-procs args ) ( map ( lambda ( coerce-proc arg ) ( coerce-proc arg )) coercion-procs args )) ; attempt to coerce all args into a common type among the args ( define ( apply-with-coercion arg-types ) ; attempt to coerce all args using each tag-type in turn ; it's a scoped procedure to keep the original arguments (arg-types) for error reporting ( define ( coerce-types tags ) ( if ( null? tags ) ; all targets exhausted ( error \"No method for these types - APPLY-GENERIC\" ( list op arg-types )) ( let* (( target-type ( car tags )) ( arg-coercions ( map ; get all the coercion procedures from the target ( lambda ( coerce-from ) ( if ( eq? coerce-from target-type ) identity ( get-coercion coerce-from target-type ))) arg-types ))) ( if ( all-coercable? arg-coercions ) ; the target type is valid if all the args can be coerced ( apply apply-generic op ( coerce-args arg-coercions args )) ; target-type is not valid, so try the next one in the list ( coerce-types ( cdr tags )))))) ; try the next target type ( coerce-types arg-types )) ( let* (( type-tags ( map type-tag args )) ( proc ( get op type-tags ))) ( if proc ( apply proc ( map contents args )) ( apply-with-coercion type-tags ))))","title":"2.82"},{"location":"SICP/ch2-abstraction-data/2.83/","text":"2.83 \u00b6 ; Suppose you are designing a generic arithmetic system for dealing with the tower ; of types shown in Figure 2.25: integer, rational, real, complex. For each type ; (except complex), design a procedure that raises objects of that type one level ; in the tower. Show how to install a generic raise operation that will work for ; each type (except complex). ; Source: [https://wizardbook.wordpress.com/2010/12/08/exercise-2-83/](https://wizardbook.wordpress.com/2010/12/08/exercise-2-83/) ( define ( raise x ) ( apply-generic 'raise x )) ; Integer package ( put 'raise ' ( integer ) ( lambda ( n ) ( make-rational n 1 ))) ; Rational package ( define ( rational->real r ) ( make-real ( / ( numer r ) ( denom r )))) ( put 'raise ' ( rational ) rational->real ) ; Real package ( define ( real->complex r ) ( make-complex-from-real-imag r 0 )) ( put 'raise ' ( real ) real->complex )","title":"2.83"},{"location":"SICP/ch2-abstraction-data/2.83/#283","text":"; Suppose you are designing a generic arithmetic system for dealing with the tower ; of types shown in Figure 2.25: integer, rational, real, complex. For each type ; (except complex), design a procedure that raises objects of that type one level ; in the tower. Show how to install a generic raise operation that will work for ; each type (except complex). ; Source: [https://wizardbook.wordpress.com/2010/12/08/exercise-2-83/](https://wizardbook.wordpress.com/2010/12/08/exercise-2-83/) ( define ( raise x ) ( apply-generic 'raise x )) ; Integer package ( put 'raise ' ( integer ) ( lambda ( n ) ( make-rational n 1 ))) ; Rational package ( define ( rational->real r ) ( make-real ( / ( numer r ) ( denom r )))) ( put 'raise ' ( rational ) rational->real ) ; Real package ( define ( real->complex r ) ( make-complex-from-real-imag r 0 )) ( put 'raise ' ( real ) real->complex )","title":"2.83"},{"location":"SICP/ch2-abstraction-data/2.84/","text":"2.84 \u00b6 ; Using the raise operation of Exercise 2.83, modify the apply-generic procedure so ; that it coerces its arguments to have the same type by the method of successive ; raising, as discussed in this section. You will need to devise a way to test which ; of two types is higher in the tower. Do this in a manner that is \u201ccompatible\u201d with ; the rest of the system and will not lead to problems in adding new levels to the ; tower. ; Source: [https://wizardbook.wordpress.com/2010/12/08/exercise-2-84/](https://wizardbook.wordpress.com/2010/12/08/exercise-2-84/) ( define ( apply-generic op . args ) ; find the highest type level of a list of arguments ( define ( highest-type-level args ) ( if ( null? args ) 0 ( let (( level ( type-level ( car args ))) ( highest ( highest-type-level ( cdr args )))) ( if ( > level highest ) level highest )))) ; raise arg to the same level as target-type-level ( define ( raise-to arg target-type-level ) ( define ( raise-iter current-arg ) ( let (( arg-level ( type-level current-arg ))) ( cond (( = arg-level target-type-level ) current-arg ) (( < arg-level target-type-level ) ( raise-iter ( apply-generic 'raise current-arg ))) ( else ( error \"Cannot raise argument to a lower type target\" arg target-type-level ))))) ( raise-iter arg )) ; raise all args to a common type (the highest in the tower of types) ; and apply the operator to them ( define ( apply-with-raised-types args ) ( let (( target-type-level ( highest-type-level args ))) ( apply apply-generic op ( map ( lambda ( arg ) ( raise-to arg target-type-level )) args )))) ( let* (( type-tags ( map type-tag args )) ( proc ( get op type-tags ))) ( if proc ( apply proc ( map contents args )) ( apply-with-raised-types args )))) ; This uses a new top-level generic procedure to find the level of the number type ; and a new procedure for each of the number types. ( define ( type-level z ) ( apply-generic 'type-level z )) ( put 'type-level ' ( integer ) ( lambda ( x ) 1 )) ( put 'type-level ' ( rational ) ( lambda ( x ) 2 )) ( put 'type-level ' ( real ) ( lambda ( x ) 3 )) ( put 'type-level ' ( complex ) ( lambda ( x ) 4 ))","title":"2.84"},{"location":"SICP/ch2-abstraction-data/2.84/#284","text":"; Using the raise operation of Exercise 2.83, modify the apply-generic procedure so ; that it coerces its arguments to have the same type by the method of successive ; raising, as discussed in this section. You will need to devise a way to test which ; of two types is higher in the tower. Do this in a manner that is \u201ccompatible\u201d with ; the rest of the system and will not lead to problems in adding new levels to the ; tower. ; Source: [https://wizardbook.wordpress.com/2010/12/08/exercise-2-84/](https://wizardbook.wordpress.com/2010/12/08/exercise-2-84/) ( define ( apply-generic op . args ) ; find the highest type level of a list of arguments ( define ( highest-type-level args ) ( if ( null? args ) 0 ( let (( level ( type-level ( car args ))) ( highest ( highest-type-level ( cdr args )))) ( if ( > level highest ) level highest )))) ; raise arg to the same level as target-type-level ( define ( raise-to arg target-type-level ) ( define ( raise-iter current-arg ) ( let (( arg-level ( type-level current-arg ))) ( cond (( = arg-level target-type-level ) current-arg ) (( < arg-level target-type-level ) ( raise-iter ( apply-generic 'raise current-arg ))) ( else ( error \"Cannot raise argument to a lower type target\" arg target-type-level ))))) ( raise-iter arg )) ; raise all args to a common type (the highest in the tower of types) ; and apply the operator to them ( define ( apply-with-raised-types args ) ( let (( target-type-level ( highest-type-level args ))) ( apply apply-generic op ( map ( lambda ( arg ) ( raise-to arg target-type-level )) args )))) ( let* (( type-tags ( map type-tag args )) ( proc ( get op type-tags ))) ( if proc ( apply proc ( map contents args )) ( apply-with-raised-types args )))) ; This uses a new top-level generic procedure to find the level of the number type ; and a new procedure for each of the number types. ( define ( type-level z ) ( apply-generic 'type-level z )) ( put 'type-level ' ( integer ) ( lambda ( x ) 1 )) ( put 'type-level ' ( rational ) ( lambda ( x ) 2 )) ( put 'type-level ' ( real ) ( lambda ( x ) 3 )) ( put 'type-level ' ( complex ) ( lambda ( x ) 4 ))","title":"2.84"},{"location":"SICP/ch2-abstraction-data/2.85/","text":"2.85 \u00b6 ; This section mentioned a method for \u201csimplifying\u201d a data object by lowering it in ; the tower of types as far as possible. Design a procedure drop that accomplishes ; this for the tower described in Exercise 2.83. The key is to decide, in some ; general way, whether an object can be lowered. For example, the complex number ; 1.5 + 0i can be lowered as far as real, the complex number 1 + 0i can be lowered ; as far as integer, and the complex number 2 + 3i cannot be lowered at all. Here is ; a plan for determining whether an object can be lowered: Begin by defining a ; generic operation project that \u201cpushes\u201d an object down in the tower. For example, ; projecting a complex number would involve throwing away the imaginary part. Then a ; number can be dropped if, when we project it and raise the result back to the type ; we started with, we end up with something equal to what we started with. Show how ; to implement this idea in detail, by writing a drop procedure that drops an object ; as far as possible. You will need to design the various projection operations and ; install project as a generic operation in the system. You will also need to make ; use of a generic equality predicate, such as described in Exercise 2.79. Finally, ; use drop to rewrite `apply-generic` from Exercise 2.84 so that it \u201csimplifies\u201d its ; answers. ; Source: [https://wizardbook.wordpress.com/2010/12/08/exercise-2-85/](https://wizardbook.wordpress.com/2010/12/08/exercise-2-85/) ; There are 3 changes to make. The first is for apply-generic to use the new drop ; procedure. Note that it doesn\u2019t make sense to drop the result of all generic ; operations, for example predicates, and that drop is only called after any type ; coercion using raise has completed. ( define ( apply-generic op . args ) ; only certain operations will result in an answer that can be ; projected e.g. it makes no sense to project the answer to zero? ( define ( reduce-type x ) ( cond (( eq? op 'add ) ( drop x )) (( eq? op 'sub ) ( drop x )) (( eq? op 'mul ) ( drop x )) (( eq? op 'div ) ( drop x )) ( else x ))) ; find the highest type level of a list of arguments ( define ( highest-type-level args ) ( if ( null? args ) 0 ( let (( level ( type-level ( car args ))) ( highest ( highest-type-level ( cdr args )))) ( if ( > level highest ) level highest )))) ; raise arg to the same level as target-type-level ( define ( raise-to arg target-type-level ) ( define ( raise-iter current-arg ) ( let (( arg-level ( type-level current-arg ))) ( cond (( = arg-level target-type-level ) current-arg ) (( < arg-level target-type-level ) ( raise-iter ( apply-generic 'raise current-arg ))) ( else ( error \"Cannot raise argument to a lower type target\" arg target-type-level ))))) ( raise-iter arg )) ; raise all args to a common type (the highest in the tower of types) ; and apply the operator to them ( define ( apply-with-raised-types args ) ( let (( target-type-level ( highest-type-level args ))) ( apply apply-generic op ( map ( lambda ( arg ) ( raise-to arg target-type-level )) args )))) ( let* (( type-tags ( map type-tag args )) ( proc ( get op type-tags ))) ( if proc ( reduce-type ( apply proc ( map contents args ))) ( apply-with-raised-types args )))) ; Second implement drop and the top-level generic project. ( define ( project z ) ( apply-generic 'project z )) ( define ( drop z ) ( if ( = ( type-level z ) 1 ) z ( let (( projected ( project z ))) ( if ( equ? z ( raise projected )) ( drop projected ) z )))) ; Third, add type specific project procedures for each type that can project. ; in the rational package ( define ( project r ) ( make-integer ( truncate ( / ( numer r ) ( denom r ))))) ( put 'project ' ( rational ) ( lambda ( x ) ( project x ))) ; in the real package - this is a bit messy because real numbers can be either ; integers, rational or irrational. ( define ( project r ) ( let (( exact ( inexact->exact r ))) ( cond (( integer? exact ) ( make-rational exact 1 )) (( rational? exact ) ( make-rational ( numerator exact ) ( denominator exact ))) ( else ( make-rational ( truncate exact ) 1 ))))) ( put 'project ' ( real ) ( lambda ( x ) ( project x ))) ; in the complex package ( define ( project z1 ) ( make-real ( real-part z1 ))) ( put 'project ' ( complex ) ( lambda ( x ) ( project x )))","title":"2.85"},{"location":"SICP/ch2-abstraction-data/2.85/#285","text":"; This section mentioned a method for \u201csimplifying\u201d a data object by lowering it in ; the tower of types as far as possible. Design a procedure drop that accomplishes ; this for the tower described in Exercise 2.83. The key is to decide, in some ; general way, whether an object can be lowered. For example, the complex number ; 1.5 + 0i can be lowered as far as real, the complex number 1 + 0i can be lowered ; as far as integer, and the complex number 2 + 3i cannot be lowered at all. Here is ; a plan for determining whether an object can be lowered: Begin by defining a ; generic operation project that \u201cpushes\u201d an object down in the tower. For example, ; projecting a complex number would involve throwing away the imaginary part. Then a ; number can be dropped if, when we project it and raise the result back to the type ; we started with, we end up with something equal to what we started with. Show how ; to implement this idea in detail, by writing a drop procedure that drops an object ; as far as possible. You will need to design the various projection operations and ; install project as a generic operation in the system. You will also need to make ; use of a generic equality predicate, such as described in Exercise 2.79. Finally, ; use drop to rewrite `apply-generic` from Exercise 2.84 so that it \u201csimplifies\u201d its ; answers. ; Source: [https://wizardbook.wordpress.com/2010/12/08/exercise-2-85/](https://wizardbook.wordpress.com/2010/12/08/exercise-2-85/) ; There are 3 changes to make. The first is for apply-generic to use the new drop ; procedure. Note that it doesn\u2019t make sense to drop the result of all generic ; operations, for example predicates, and that drop is only called after any type ; coercion using raise has completed. ( define ( apply-generic op . args ) ; only certain operations will result in an answer that can be ; projected e.g. it makes no sense to project the answer to zero? ( define ( reduce-type x ) ( cond (( eq? op 'add ) ( drop x )) (( eq? op 'sub ) ( drop x )) (( eq? op 'mul ) ( drop x )) (( eq? op 'div ) ( drop x )) ( else x ))) ; find the highest type level of a list of arguments ( define ( highest-type-level args ) ( if ( null? args ) 0 ( let (( level ( type-level ( car args ))) ( highest ( highest-type-level ( cdr args )))) ( if ( > level highest ) level highest )))) ; raise arg to the same level as target-type-level ( define ( raise-to arg target-type-level ) ( define ( raise-iter current-arg ) ( let (( arg-level ( type-level current-arg ))) ( cond (( = arg-level target-type-level ) current-arg ) (( < arg-level target-type-level ) ( raise-iter ( apply-generic 'raise current-arg ))) ( else ( error \"Cannot raise argument to a lower type target\" arg target-type-level ))))) ( raise-iter arg )) ; raise all args to a common type (the highest in the tower of types) ; and apply the operator to them ( define ( apply-with-raised-types args ) ( let (( target-type-level ( highest-type-level args ))) ( apply apply-generic op ( map ( lambda ( arg ) ( raise-to arg target-type-level )) args )))) ( let* (( type-tags ( map type-tag args )) ( proc ( get op type-tags ))) ( if proc ( reduce-type ( apply proc ( map contents args ))) ( apply-with-raised-types args )))) ; Second implement drop and the top-level generic project. ( define ( project z ) ( apply-generic 'project z )) ( define ( drop z ) ( if ( = ( type-level z ) 1 ) z ( let (( projected ( project z ))) ( if ( equ? z ( raise projected )) ( drop projected ) z )))) ; Third, add type specific project procedures for each type that can project. ; in the rational package ( define ( project r ) ( make-integer ( truncate ( / ( numer r ) ( denom r ))))) ( put 'project ' ( rational ) ( lambda ( x ) ( project x ))) ; in the real package - this is a bit messy because real numbers can be either ; integers, rational or irrational. ( define ( project r ) ( let (( exact ( inexact->exact r ))) ( cond (( integer? exact ) ( make-rational exact 1 )) (( rational? exact ) ( make-rational ( numerator exact ) ( denominator exact ))) ( else ( make-rational ( truncate exact ) 1 ))))) ( put 'project ' ( real ) ( lambda ( x ) ( project x ))) ; in the complex package ( define ( project z1 ) ( make-real ( real-part z1 ))) ( put 'project ' ( complex ) ( lambda ( x ) ( project x )))","title":"2.85"},{"location":"SICP/ch2-abstraction-data/2.86/","text":"2.86 \u00b6 ; Suppose we want to handle complex numbers whose real parts, imaginary parts, ; magnitudes, and angles can be either ordinary numbers, rational numbers, or ; other numbers we might wish to add to the system. Describe and implement the ; changes to the system needed to accommodate this. You will have to define ; operations such as sine and cosine that are generic over ordinary numbers and ; rational numbers. ; Source: [https://wizardbook.wordpress.com/2010/12/09/exercise-2-86/](https://wizardbook.wordpress.com/2010/12/09/exercise-2-86/) ; Previously, the arithmetic operators needed to convert between polar and ; rectangular representations of complex numbers only needed to work on scheme\u2019s ; built in number values. Now those values can be any of the types in the number ; system and so all the operators used in those conversions need to use generic ; procedures. ; in the polar package ( define ( real-part z ) ( mul ( magnitude z ) ( cosine ( angle z )))) ( define ( imag-part z ) ( mul ( magnitude z ) ( sine ( angle z )))) ( define ( make-from-real-imag x y ) ( make-from-mag-ang ( sq-root ( add ( square x ) ( square y ))) ( arctan y x ))) ; in the rectangular package ( define ( magnitude z ) ( sq-root ( add ( square ( real-part z )) ( square ( imag-part z ))))) ( define ( angle z ) ( arctan ( imag-part z ) ( real-part z ))) ( define ( make-from-mag-ang r a ) ( cons ( mul r ( cosine a )) ( mul r ( sine a )))) ; This means we need new top-level generic procedures: ( define ( square x ) ( apply-generic 'square x )) ( define ( sq-root x ) ( apply-generic 'sq-root x )) ( define ( sine x ) ( apply-generic 'sine x )) ( define ( cosine x ) ( apply-generic 'cosine x )) ( define ( arctan x y ) ( apply-generic 'arctan x y )) ; These procedures need to be implemented by the real, rational and integer packages ; and to be installed into the operations table. ; in the integer package ; does it make any sense to have sine, cosine, sq-root and arctan for integer? ( put 'sq-root ' ( integer ) ( lambda ( x ) ( make-real ( sqrt x )))) ( put 'square ' ( integer ) ( lambda ( x ) ( tag ( * x x )))) ( put 'sine ' ( integer ) ( lambda ( x ) ( make-real ( sin x )))) ( put 'cosine ' ( integer ) ( lambda ( x ) ( make-real ( cos x )))) ( put 'arctan ' ( integer integer ) ( lambda ( x y ) ( make-real ( atan x y )))) ; in the rational package ( define ( ratio x ) ( / ( numer x ) ( denom x ))) ( put 'sq-root ' ( rational ) ( lambda ( x ) ( make-real ( sqrt ( ratio x ))))) ( put 'square ' ( rational ) ( lambda ( x ) ( tag ( mul-rat x x )))) ( put 'sine ' ( rational ) ( lambda ( x ) ( make-real ( sin ( ratio x ))))) ( put 'cosine ' ( rational ) ( lambda ( x ) ( make-real ( cos ( ratio x ))))) ( put 'arctan ' ( rational rational ) ( lambda ( x y ) ( make-real ( atan ( ratio x ) ( ratio y ))))) ; in the real package ( put 'sq-root ' ( real ) ( lambda ( x ) ( tag ( sqrt x )))) ( put 'square ' ( real ) ( lambda ( x ) ( tag ( * x x )))) ( put 'sine ' ( real ) ( lambda ( x ) ( tag ( sin x )))) ( put 'cosine ' ( real ) ( lambda ( x ) ( tag ( cos x )))) ( put 'arctan ' ( real real ) ( lambda ( x y ) ( tag ( atan x y )))) ; Finally `apply-generic` needs to be able to reduce the result of these new operators ; by calling drop on them. ( define ( apply-generic op . args ) ( define ( reduce-type x ) ( cond (( eq? op 'add ) ( drop x )) (( eq? op 'sub ) ( drop x )) (( eq? op 'mul ) ( drop x )) (( eq? op 'div ) ( drop x )) (( eq? op 'square ) ( drop x )) (( eq? op 'sq-root ) ( drop x )) (( eq? op 'sine ) ( drop x )) (( eq? op 'cosine ) ( drop x )) (( eq? op 'arctan ) ( drop x )) ( else x ))) ; find the highest type level of a list of arguments ( define ( highest-type-level args ) ( if ( null? args ) 0 ( let (( level ( type-level ( car args ))) ( highest ( highest-type-level ( cdr args )))) ( if ( > level highest ) level highest )))) ; raise arg to the same level as target-type-level ( define ( raise-to arg target-type-level ) ( define ( raise-iter current-arg ) ( let (( arg-level ( type-level current-arg ))) ( cond (( = arg-level target-type-level ) current-arg ) (( < arg-level target-type-level ) ( raise-iter ( apply-generic 'raise current-arg ))) ( else ( error \"Cannot raise argument to a lower type target\" arg target-type-level ))))) ( raise-iter arg )) ; raise all args to a common type (the highest in the tower of types) ; and apply the operator to them ( define ( apply-with-raised-types args ) ( let (( target-type-level ( highest-type-level args ))) ( apply apply-generic op ( map ( lambda ( arg ) ( raise-to arg target-type-level )) args )))) ( let* (( type-tags ( map type-tag args )) ( proc ( get op type-tags ))) ( if proc ( reduce-type ( apply proc ( map contents args ))) ( apply-with-raised-types args ))))","title":"2.86"},{"location":"SICP/ch2-abstraction-data/2.86/#286","text":"; Suppose we want to handle complex numbers whose real parts, imaginary parts, ; magnitudes, and angles can be either ordinary numbers, rational numbers, or ; other numbers we might wish to add to the system. Describe and implement the ; changes to the system needed to accommodate this. You will have to define ; operations such as sine and cosine that are generic over ordinary numbers and ; rational numbers. ; Source: [https://wizardbook.wordpress.com/2010/12/09/exercise-2-86/](https://wizardbook.wordpress.com/2010/12/09/exercise-2-86/) ; Previously, the arithmetic operators needed to convert between polar and ; rectangular representations of complex numbers only needed to work on scheme\u2019s ; built in number values. Now those values can be any of the types in the number ; system and so all the operators used in those conversions need to use generic ; procedures. ; in the polar package ( define ( real-part z ) ( mul ( magnitude z ) ( cosine ( angle z )))) ( define ( imag-part z ) ( mul ( magnitude z ) ( sine ( angle z )))) ( define ( make-from-real-imag x y ) ( make-from-mag-ang ( sq-root ( add ( square x ) ( square y ))) ( arctan y x ))) ; in the rectangular package ( define ( magnitude z ) ( sq-root ( add ( square ( real-part z )) ( square ( imag-part z ))))) ( define ( angle z ) ( arctan ( imag-part z ) ( real-part z ))) ( define ( make-from-mag-ang r a ) ( cons ( mul r ( cosine a )) ( mul r ( sine a )))) ; This means we need new top-level generic procedures: ( define ( square x ) ( apply-generic 'square x )) ( define ( sq-root x ) ( apply-generic 'sq-root x )) ( define ( sine x ) ( apply-generic 'sine x )) ( define ( cosine x ) ( apply-generic 'cosine x )) ( define ( arctan x y ) ( apply-generic 'arctan x y )) ; These procedures need to be implemented by the real, rational and integer packages ; and to be installed into the operations table. ; in the integer package ; does it make any sense to have sine, cosine, sq-root and arctan for integer? ( put 'sq-root ' ( integer ) ( lambda ( x ) ( make-real ( sqrt x )))) ( put 'square ' ( integer ) ( lambda ( x ) ( tag ( * x x )))) ( put 'sine ' ( integer ) ( lambda ( x ) ( make-real ( sin x )))) ( put 'cosine ' ( integer ) ( lambda ( x ) ( make-real ( cos x )))) ( put 'arctan ' ( integer integer ) ( lambda ( x y ) ( make-real ( atan x y )))) ; in the rational package ( define ( ratio x ) ( / ( numer x ) ( denom x ))) ( put 'sq-root ' ( rational ) ( lambda ( x ) ( make-real ( sqrt ( ratio x ))))) ( put 'square ' ( rational ) ( lambda ( x ) ( tag ( mul-rat x x )))) ( put 'sine ' ( rational ) ( lambda ( x ) ( make-real ( sin ( ratio x ))))) ( put 'cosine ' ( rational ) ( lambda ( x ) ( make-real ( cos ( ratio x ))))) ( put 'arctan ' ( rational rational ) ( lambda ( x y ) ( make-real ( atan ( ratio x ) ( ratio y ))))) ; in the real package ( put 'sq-root ' ( real ) ( lambda ( x ) ( tag ( sqrt x )))) ( put 'square ' ( real ) ( lambda ( x ) ( tag ( * x x )))) ( put 'sine ' ( real ) ( lambda ( x ) ( tag ( sin x )))) ( put 'cosine ' ( real ) ( lambda ( x ) ( tag ( cos x )))) ( put 'arctan ' ( real real ) ( lambda ( x y ) ( tag ( atan x y )))) ; Finally `apply-generic` needs to be able to reduce the result of these new operators ; by calling drop on them. ( define ( apply-generic op . args ) ( define ( reduce-type x ) ( cond (( eq? op 'add ) ( drop x )) (( eq? op 'sub ) ( drop x )) (( eq? op 'mul ) ( drop x )) (( eq? op 'div ) ( drop x )) (( eq? op 'square ) ( drop x )) (( eq? op 'sq-root ) ( drop x )) (( eq? op 'sine ) ( drop x )) (( eq? op 'cosine ) ( drop x )) (( eq? op 'arctan ) ( drop x )) ( else x ))) ; find the highest type level of a list of arguments ( define ( highest-type-level args ) ( if ( null? args ) 0 ( let (( level ( type-level ( car args ))) ( highest ( highest-type-level ( cdr args )))) ( if ( > level highest ) level highest )))) ; raise arg to the same level as target-type-level ( define ( raise-to arg target-type-level ) ( define ( raise-iter current-arg ) ( let (( arg-level ( type-level current-arg ))) ( cond (( = arg-level target-type-level ) current-arg ) (( < arg-level target-type-level ) ( raise-iter ( apply-generic 'raise current-arg ))) ( else ( error \"Cannot raise argument to a lower type target\" arg target-type-level ))))) ( raise-iter arg )) ; raise all args to a common type (the highest in the tower of types) ; and apply the operator to them ( define ( apply-with-raised-types args ) ( let (( target-type-level ( highest-type-level args ))) ( apply apply-generic op ( map ( lambda ( arg ) ( raise-to arg target-type-level )) args )))) ( let* (( type-tags ( map type-tag args )) ( proc ( get op type-tags ))) ( if proc ( reduce-type ( apply proc ( map contents args ))) ( apply-with-raised-types args ))))","title":"2.86"},{"location":"SICP/ch2-abstraction-data/2.87/","text":"2.87 \u00b6 ; Install `=zero?` for polynomials in the generic arithmetic package. This will allow ; `adjoin-term` to work for polynomials with coefficients that are themselves ; polynomials. ( load \"packages/general.scm\" ) ( load \"packages/polynomial.scm\" ) ( load \"arithmetic-package.scm\" ) ; Answer ; Inside the `polynomial` package, write the following snippet ; (already included inside `packages/polynomial.scm`) ( define ( poly-zero? term-list ) ( if ( empty-termlist? term-list ) #t ( and ( =zero? ( first-term term-list )) ( poly-zero? ( rest-term term-list ))))) ( put '=zero? ' ( polynomial ) ( lambda ( p ) ( poly-zero? p ))) ; Testing ( install-polynomial-package ) ( define p1 ( make-polynomial 'x ( list ( make-term 2 ( make-scheme-number 0 )) ( make-term 1 ( make-scheme-number 0 )) ( make-term 0 ( make-scheme-number 0 ))))) ; 0x^2 + 1x + 0 ( =zero? p1 ) ;Value: #t ( define p2 ( make-polynomial 'x ( list ( make-term 2 ( make-scheme-number 0 )) ( make-term 1 ( make-scheme-number 2 )) ( make-term 0 ( make-scheme-number 0 ))))) ( =zero? p2 ) ;Value: #f","title":"2.87"},{"location":"SICP/ch2-abstraction-data/2.87/#287","text":"; Install `=zero?` for polynomials in the generic arithmetic package. This will allow ; `adjoin-term` to work for polynomials with coefficients that are themselves ; polynomials. ( load \"packages/general.scm\" ) ( load \"packages/polynomial.scm\" ) ( load \"arithmetic-package.scm\" ) ; Answer ; Inside the `polynomial` package, write the following snippet ; (already included inside `packages/polynomial.scm`) ( define ( poly-zero? term-list ) ( if ( empty-termlist? term-list ) #t ( and ( =zero? ( first-term term-list )) ( poly-zero? ( rest-term term-list ))))) ( put '=zero? ' ( polynomial ) ( lambda ( p ) ( poly-zero? p ))) ; Testing ( install-polynomial-package ) ( define p1 ( make-polynomial 'x ( list ( make-term 2 ( make-scheme-number 0 )) ( make-term 1 ( make-scheme-number 0 )) ( make-term 0 ( make-scheme-number 0 ))))) ; 0x^2 + 1x + 0 ( =zero? p1 ) ;Value: #t ( define p2 ( make-polynomial 'x ( list ( make-term 2 ( make-scheme-number 0 )) ( make-term 1 ( make-scheme-number 2 )) ( make-term 0 ( make-scheme-number 0 ))))) ( =zero? p2 ) ;Value: #f","title":"2.87"},{"location":"SICP/ch2-abstraction-data/2.88/","text":"2.88 \u00b6 ; Extend the polynomial system to include subtraction of polynomials. (Hint: You may ; find it helpful to define a generic negation operation.) ( load \"packages/general.scm\" ) ; Add the following genric negation operations ; (i) scheme-numer ( put 'negate ' ( scheme-number ) ( lambda ( x ) ( tag ( - x )))) ; (ii) rational ( put 'negate ' ( rational ) ( lambda ( r ) ( make-rat ( - numer r ) ( denom r )))) ; (iii) complex ( put 'negate ' ( complex ) ( lambda ( z ) ( make-from-real-imag ( - ( real-part z )) ( - ( imag-part z ))))) ; (iv) Polynomial package ( define ( negate-terms term-list ) ( if ( empty-termlist? term-list ) the-empty-termlist ( adjoin-term ( make-term ( order ( first-term term-list )) ( negate ( coeff ( first-term term-list )))) ( negate-terms ( rest-terms term-list ))))) ( define ( sub-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( add-terms ( term-list p1 ) ( negate-terms ( term-list p2 )))) ( error \"Polys not in same var: SUB-POLY\" ( list p1 p2 )))) ( put 'negate ' ( polynomial ) ( lambda ( p ) ( make-polynomial ( variable p ) ( negate-terms ( term-list p ))))) ( put 'sub ' ( polynomial polynomial ) ( lambda ( p1 p2 ) ( tag ( sub-poly p1 p2 )))) ( load \"packages/polynomial.scm\" ) ( load \"arithmetic-package.scm\" ) ( install-polynomial-package ) ; Testing ( define p1 ( make-polynomial 'x ( list ( make-term 2 ( make-scheme-number 2 )) ( make-term 1 ( make-scheme-number 5 )) ( make-term 0 ( make-scheme-number 3 ))))) ; 2x^2 + 5x + 3 ( define p2 ( make-polynomial 'x ( list ( make-term 3 ( make-scheme-number 1 )) ( make-term 1 ( make-scheme-number 4 )) ( make-term 0 ( make-scheme-number 2 ))))) ; x^3 + 4x + 2 ( sub p2 p1 ) ; (polynomial x ; (3 (scheme-number . 1)) ; (2 (scheme-number . -2)) ; (1 (scheme-number . -1)) ; (0 (scheme-number . -1)) -> x^3 - 2x^2 - c - 1","title":"2.88"},{"location":"SICP/ch2-abstraction-data/2.88/#288","text":"; Extend the polynomial system to include subtraction of polynomials. (Hint: You may ; find it helpful to define a generic negation operation.) ( load \"packages/general.scm\" ) ; Add the following genric negation operations ; (i) scheme-numer ( put 'negate ' ( scheme-number ) ( lambda ( x ) ( tag ( - x )))) ; (ii) rational ( put 'negate ' ( rational ) ( lambda ( r ) ( make-rat ( - numer r ) ( denom r )))) ; (iii) complex ( put 'negate ' ( complex ) ( lambda ( z ) ( make-from-real-imag ( - ( real-part z )) ( - ( imag-part z ))))) ; (iv) Polynomial package ( define ( negate-terms term-list ) ( if ( empty-termlist? term-list ) the-empty-termlist ( adjoin-term ( make-term ( order ( first-term term-list )) ( negate ( coeff ( first-term term-list )))) ( negate-terms ( rest-terms term-list ))))) ( define ( sub-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( add-terms ( term-list p1 ) ( negate-terms ( term-list p2 )))) ( error \"Polys not in same var: SUB-POLY\" ( list p1 p2 )))) ( put 'negate ' ( polynomial ) ( lambda ( p ) ( make-polynomial ( variable p ) ( negate-terms ( term-list p ))))) ( put 'sub ' ( polynomial polynomial ) ( lambda ( p1 p2 ) ( tag ( sub-poly p1 p2 )))) ( load \"packages/polynomial.scm\" ) ( load \"arithmetic-package.scm\" ) ( install-polynomial-package ) ; Testing ( define p1 ( make-polynomial 'x ( list ( make-term 2 ( make-scheme-number 2 )) ( make-term 1 ( make-scheme-number 5 )) ( make-term 0 ( make-scheme-number 3 ))))) ; 2x^2 + 5x + 3 ( define p2 ( make-polynomial 'x ( list ( make-term 3 ( make-scheme-number 1 )) ( make-term 1 ( make-scheme-number 4 )) ( make-term 0 ( make-scheme-number 2 ))))) ; x^3 + 4x + 2 ( sub p2 p1 ) ; (polynomial x ; (3 (scheme-number . 1)) ; (2 (scheme-number . -2)) ; (1 (scheme-number . -1)) ; (0 (scheme-number . -1)) -> x^3 - 2x^2 - c - 1","title":"2.88"},{"location":"SICP/ch2-abstraction-data/2.89/","text":"2.89 \u00b6 ; Define procedures that implement the `term-list` representation described above as ; appropriate for dense polynomials. ; Representation of 2x^3 + 5x + 7 will be, ; (2 0 5 7) ; We essentially need to change `adjoin-term` to store internally ; in the above representation while preserving the same data structure as before ( define ( adjoin-term term term-list ) ( cond (( =zero? term ) term-list ) (( = ( order term ) ( length term-list )) ( cons ( coeff term ) term-list )) ( else ( adjoin-term term ( cons 0 term-list ))))) ( define ( first-term term-list ) ( make-term ( - ( length term-list ) 1 ) ( car term-list ))) ; Attaching 4x^4 to (2x^3 + 5x + 7) will be, ; (adjoin-term (4 3) (2 0 5 7)) ; => (3 2 0 5 7) ; Attaching 3x^5 to (2x^3 + 5x + 7) will be, ; (adjoin-term (5 3) (2 0 5 7)) ; => (adjoin-term (5 3) (0 2 0 5 7)) ; => (3 0 2 0 5 7)","title":"2.89"},{"location":"SICP/ch2-abstraction-data/2.89/#289","text":"; Define procedures that implement the `term-list` representation described above as ; appropriate for dense polynomials. ; Representation of 2x^3 + 5x + 7 will be, ; (2 0 5 7) ; We essentially need to change `adjoin-term` to store internally ; in the above representation while preserving the same data structure as before ( define ( adjoin-term term term-list ) ( cond (( =zero? term ) term-list ) (( = ( order term ) ( length term-list )) ( cons ( coeff term ) term-list )) ( else ( adjoin-term term ( cons 0 term-list ))))) ( define ( first-term term-list ) ( make-term ( - ( length term-list ) 1 ) ( car term-list ))) ; Attaching 4x^4 to (2x^3 + 5x + 7) will be, ; (adjoin-term (4 3) (2 0 5 7)) ; => (3 2 0 5 7) ; Attaching 3x^5 to (2x^3 + 5x + 7) will be, ; (adjoin-term (5 3) (2 0 5 7)) ; => (adjoin-term (5 3) (0 2 0 5 7)) ; => (3 0 2 0 5 7)","title":"2.89"},{"location":"SICP/ch2-abstraction-data/2.90/","text":"2.90 \u00b6 ; Suppose we want to have a polynomial system that is efficient for both sparse and ; dense polynomials. One way to do this is to allow both kinds of term-list ; representations in our system. The situation is analogous to the complex-number ; example of Section 2.4, where we allowed both rectangular and polar representations. ; To do this we must distinguish different types of term lists and make the ; operations on term lists generic. Redesign the polynomial system to implement this ; generalization. This is a major effort, not a local change. ; Dense package ( define ( install-polynomial-package-dense ) ;; internal procedures ;; representation of poly ( define ( make-poly variable term-list ) ( cons variable term-list )) ( define ( variable p ) ( car p )) ( define ( term-list p ) ( cdr p )) ; \u27e8procedures same-variable? and variable? from section 2.3.2\u27e9 ( define ( variable? x ) ( symbol? x )) ( define ( same-variable? v1 v2 ) ( and ( variable? v1 ) ( variable? v2 ) ( eq? v1 v2 ))) ;; representation of terms ( define ( adjoin-term term term-list ) ( cond (( =zero? term ) term-list ) (( = ( order term ) ( length term-list )) ( cons ( coeff term ) term-list )) ( else ( adjoin-term term ( cons 0 term-list ))))) ( define ( the-empty-termlist ) ' ()) ( define ( first-term term-list ) ( make-term ( - ( length term-list ) 1 ) ( car term-list ))) ( define ( rest-term term-list ) ( cdr term-list )) ( define ( empty-termlist? term-list ) ( null? term-list )) ( define ( make-term order coeff ) ( list order coeff )) ( define ( order term ) ( car term )) ( define ( coeff term ) ( cadr term )) ;; Add ( define ( add-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( add-terms ( term-list p1 ) ( term-list p2 ))) ( error \"Polys not in same var: ADD-POLY\" ( list p1 p2 )))) ( define ( add-terms L1 L2 ) ( cond (( empty-termlist? L1 ) L2 ) (( empty-termlist? L2 ) L1 ) ( else ( let (( t1 ( first-term L1 )) ( t2 ( first-term L2 ))) ( cond (( > ( order t1 ) ( order t2 )) ( adjoin-term t1 ( add-terms ( rest-terms L1 ) L2 ))) (( < ( order t1 ) ( order t2 )) ( adjoin-term t2 ( add-terms L1 ( rest-terms L2 )))) ( else ( adjoin-term ( make-term ( order t1 ) ( add ( coeff t1 ) ( coeff t2 ))) ( add-terms ( rest-terms L1 ) ( rest-terms L2 ))))))))) ;; Multiply ( define ( mul-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( mul-terms ( term-list p1 ) ( term-list p2 ))) ( error \"Polys not in same var: MUL-POLY\" ( list p1 p2 )))) ( define ( mul-terms L1 L2 ) ( if ( empty-termlist? L1 ) ( the-empty-termlist ) ( add-terms ( mul-term-by-all-terms ( first-term L1 ) L2 ) ( mul-terms ( rest-terms ) L2 )))) ( define ( mul-term-by-all-terms t1 L ) ( if ( empty-termlist? L ) ( the-empty-termlist ) ( let (( t2 ( first-term L ))) ( adjoin-term ( make-term ( + ( order t1 ) ( order t2 )) ( mul ( coeff t1 ) ( coeff t2 ))) ( mul-term-by-all-terms t1 ( rest-terms L )))))) ;; interface to rest of the system ( define ( tag p ) ( attach-tag 'polynomial-dense p )) ( put 'add ' ( polynomial-dense polynomial-dense ) ( lambda ( p1 p2 ) ( tag ( add-poly p1 p2 )))) ( put 'mul ' ( polynomial-dense polynomial-dense ) ( lambda ( p1 p2 ) ( tag ( mul-poly p1 p2 )))) ( put 'make 'polynomial-dense ( lambda ( var terms ) ( tag ( make-poly var terms )))) 'done ) ; Sparse package ( define ( install-polynomial-package-sparse ) ;; internal procedures ;; representation of poly ( define ( make-poly variable term-list ) ( cons variable term-list )) ( define ( variable p ) ( car p )) ( define ( term-list p ) ( cdr p )) ; \u27e8procedures same-variable? and variable? from section 2.3.2\u27e9 ( define ( variable? x ) ( symbol? x )) ( define ( same-variable? v1 v2 ) ( and ( variable? v1 ) ( variable? v2 ) ( eq? v1 v2 ))) ;; representation of terms ( define ( adjoin-term term term-list ) ( if ( =zero? ( coeff term )) term-list ( cons term term-list ))) ( define ( the-empty-termlist ) ' ()) ( define ( first-term term-list ) ( car term-list )) ( define ( rest-terms term-list ) ( cdr term-list )) ( define ( empty-termlist? term-list ) ( null? term-list )) ( define ( make-term order coeff ) ( list order coeff )) ( define ( order term ) ( car term )) ( define ( coeff term ) ( cadr term )) ;; Add ( define ( add-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( add-terms ( term-list p1 ) ( term-list p2 ))) ( error \"Polys not in same var: ADD-POLY\" ( list p1 p2 )))) ( define ( add-terms L1 L2 ) ( cond (( empty-termlist? L1 ) L2 ) (( empty-termlist? L2 ) L1 ) ( else ( let (( t1 ( first-term L1 )) ( t2 ( first-term L2 ))) ( cond (( > ( order t1 ) ( order t2 )) ( adjoin-term t1 ( add-terms ( rest-terms L1 ) L2 ))) (( < ( order t1 ) ( order t2 )) ( adjoin-term t2 ( add-terms L1 ( rest-terms L2 )))) ( else ( adjoin-term ( make-term ( order t1 ) ( add ( coeff t1 ) ( coeff t2 ))) ( add-terms ( rest-terms L1 ) ( rest-terms L2 ))))))))) ;; Multiply ( define ( mul-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( mul-terms ( term-list p1 ) ( term-list p2 ))) ( error \"Polys not in same var: MUL-POLY\" ( list p1 p2 )))) ( define ( mul-terms L1 L2 ) ( if ( empty-termlist? L1 ) ( the-empty-termlist ) ( add-terms ( mul-term-by-all-terms ( first-term L1 ) L2 ) ( mul-terms ( rest-terms ) L2 )))) ( define ( mul-term-by-all-terms t1 L ) ( if ( empty-termlist? L ) ( the-empty-termlist ) ( let (( t2 ( first-term L ))) ( adjoin-term ( make-term ( + ( order t1 ) ( order t2 )) ( mul ( coeff t1 ) ( coeff t2 ))) ( mul-term-by-all-terms t1 ( rest-terms L )))))) ;; interface to rest of the system ( define ( tag p ) ( attach-tag 'polynomial-sparse p )) ( put 'add ' ( polynomial-sparse polynomial-sparse ) ( lambda ( p1 p2 ) ( tag ( add-poly p1 p2 )))) ( put 'mul ' ( polynomial-sparse polynomial-sparse ) ( lambda ( p1 p2 ) ( tag ( mul-poly p1 p2 )))) ( put 'make 'polynomial-sparse ( lambda ( var terms ) ( tag ( make-poly var terms )))) 'done )","title":"2.90"},{"location":"SICP/ch2-abstraction-data/2.90/#290","text":"; Suppose we want to have a polynomial system that is efficient for both sparse and ; dense polynomials. One way to do this is to allow both kinds of term-list ; representations in our system. The situation is analogous to the complex-number ; example of Section 2.4, where we allowed both rectangular and polar representations. ; To do this we must distinguish different types of term lists and make the ; operations on term lists generic. Redesign the polynomial system to implement this ; generalization. This is a major effort, not a local change. ; Dense package ( define ( install-polynomial-package-dense ) ;; internal procedures ;; representation of poly ( define ( make-poly variable term-list ) ( cons variable term-list )) ( define ( variable p ) ( car p )) ( define ( term-list p ) ( cdr p )) ; \u27e8procedures same-variable? and variable? from section 2.3.2\u27e9 ( define ( variable? x ) ( symbol? x )) ( define ( same-variable? v1 v2 ) ( and ( variable? v1 ) ( variable? v2 ) ( eq? v1 v2 ))) ;; representation of terms ( define ( adjoin-term term term-list ) ( cond (( =zero? term ) term-list ) (( = ( order term ) ( length term-list )) ( cons ( coeff term ) term-list )) ( else ( adjoin-term term ( cons 0 term-list ))))) ( define ( the-empty-termlist ) ' ()) ( define ( first-term term-list ) ( make-term ( - ( length term-list ) 1 ) ( car term-list ))) ( define ( rest-term term-list ) ( cdr term-list )) ( define ( empty-termlist? term-list ) ( null? term-list )) ( define ( make-term order coeff ) ( list order coeff )) ( define ( order term ) ( car term )) ( define ( coeff term ) ( cadr term )) ;; Add ( define ( add-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( add-terms ( term-list p1 ) ( term-list p2 ))) ( error \"Polys not in same var: ADD-POLY\" ( list p1 p2 )))) ( define ( add-terms L1 L2 ) ( cond (( empty-termlist? L1 ) L2 ) (( empty-termlist? L2 ) L1 ) ( else ( let (( t1 ( first-term L1 )) ( t2 ( first-term L2 ))) ( cond (( > ( order t1 ) ( order t2 )) ( adjoin-term t1 ( add-terms ( rest-terms L1 ) L2 ))) (( < ( order t1 ) ( order t2 )) ( adjoin-term t2 ( add-terms L1 ( rest-terms L2 )))) ( else ( adjoin-term ( make-term ( order t1 ) ( add ( coeff t1 ) ( coeff t2 ))) ( add-terms ( rest-terms L1 ) ( rest-terms L2 ))))))))) ;; Multiply ( define ( mul-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( mul-terms ( term-list p1 ) ( term-list p2 ))) ( error \"Polys not in same var: MUL-POLY\" ( list p1 p2 )))) ( define ( mul-terms L1 L2 ) ( if ( empty-termlist? L1 ) ( the-empty-termlist ) ( add-terms ( mul-term-by-all-terms ( first-term L1 ) L2 ) ( mul-terms ( rest-terms ) L2 )))) ( define ( mul-term-by-all-terms t1 L ) ( if ( empty-termlist? L ) ( the-empty-termlist ) ( let (( t2 ( first-term L ))) ( adjoin-term ( make-term ( + ( order t1 ) ( order t2 )) ( mul ( coeff t1 ) ( coeff t2 ))) ( mul-term-by-all-terms t1 ( rest-terms L )))))) ;; interface to rest of the system ( define ( tag p ) ( attach-tag 'polynomial-dense p )) ( put 'add ' ( polynomial-dense polynomial-dense ) ( lambda ( p1 p2 ) ( tag ( add-poly p1 p2 )))) ( put 'mul ' ( polynomial-dense polynomial-dense ) ( lambda ( p1 p2 ) ( tag ( mul-poly p1 p2 )))) ( put 'make 'polynomial-dense ( lambda ( var terms ) ( tag ( make-poly var terms )))) 'done ) ; Sparse package ( define ( install-polynomial-package-sparse ) ;; internal procedures ;; representation of poly ( define ( make-poly variable term-list ) ( cons variable term-list )) ( define ( variable p ) ( car p )) ( define ( term-list p ) ( cdr p )) ; \u27e8procedures same-variable? and variable? from section 2.3.2\u27e9 ( define ( variable? x ) ( symbol? x )) ( define ( same-variable? v1 v2 ) ( and ( variable? v1 ) ( variable? v2 ) ( eq? v1 v2 ))) ;; representation of terms ( define ( adjoin-term term term-list ) ( if ( =zero? ( coeff term )) term-list ( cons term term-list ))) ( define ( the-empty-termlist ) ' ()) ( define ( first-term term-list ) ( car term-list )) ( define ( rest-terms term-list ) ( cdr term-list )) ( define ( empty-termlist? term-list ) ( null? term-list )) ( define ( make-term order coeff ) ( list order coeff )) ( define ( order term ) ( car term )) ( define ( coeff term ) ( cadr term )) ;; Add ( define ( add-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( add-terms ( term-list p1 ) ( term-list p2 ))) ( error \"Polys not in same var: ADD-POLY\" ( list p1 p2 )))) ( define ( add-terms L1 L2 ) ( cond (( empty-termlist? L1 ) L2 ) (( empty-termlist? L2 ) L1 ) ( else ( let (( t1 ( first-term L1 )) ( t2 ( first-term L2 ))) ( cond (( > ( order t1 ) ( order t2 )) ( adjoin-term t1 ( add-terms ( rest-terms L1 ) L2 ))) (( < ( order t1 ) ( order t2 )) ( adjoin-term t2 ( add-terms L1 ( rest-terms L2 )))) ( else ( adjoin-term ( make-term ( order t1 ) ( add ( coeff t1 ) ( coeff t2 ))) ( add-terms ( rest-terms L1 ) ( rest-terms L2 ))))))))) ;; Multiply ( define ( mul-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( mul-terms ( term-list p1 ) ( term-list p2 ))) ( error \"Polys not in same var: MUL-POLY\" ( list p1 p2 )))) ( define ( mul-terms L1 L2 ) ( if ( empty-termlist? L1 ) ( the-empty-termlist ) ( add-terms ( mul-term-by-all-terms ( first-term L1 ) L2 ) ( mul-terms ( rest-terms ) L2 )))) ( define ( mul-term-by-all-terms t1 L ) ( if ( empty-termlist? L ) ( the-empty-termlist ) ( let (( t2 ( first-term L ))) ( adjoin-term ( make-term ( + ( order t1 ) ( order t2 )) ( mul ( coeff t1 ) ( coeff t2 ))) ( mul-term-by-all-terms t1 ( rest-terms L )))))) ;; interface to rest of the system ( define ( tag p ) ( attach-tag 'polynomial-sparse p )) ( put 'add ' ( polynomial-sparse polynomial-sparse ) ( lambda ( p1 p2 ) ( tag ( add-poly p1 p2 )))) ( put 'mul ' ( polynomial-sparse polynomial-sparse ) ( lambda ( p1 p2 ) ( tag ( mul-poly p1 p2 )))) ( put 'make 'polynomial-sparse ( lambda ( var terms ) ( tag ( make-poly var terms )))) 'done )","title":"2.90"},{"location":"SICP/ch2-abstraction-data/2.91/","text":"2.91 \u00b6 ; A univariate polynomial can be divided by another one to produce a polynomial ; quotient and a polynomial remainder. For example, ; ; $\\frac{x^5 - 1}{x^2 - 1} = x^3 + x$, remainder $x-1$ ; ; Division can be performed via long division. That is, divide the highest-order ; term of the dividend by the highest-order term of the divisor. The result is the ; first term of the quotient. Next, multiply the result by the divisor, subtract ; that from the dividend, and produce the rest of the answer by recursively dividing ; the difference by the divisor. Stop when the order of the divisor exceeds the order ; of the dividend and declare the dividend to be the remainder. Also, if the dividend ; ever becomes zero, return zero as both quotient and remainder. ; ; We can design a div-poly procedure on the model of add- poly and mul-poly. The ; procedure checks to see if the two polys have the same variable. If so, div-poly ; strips off the variable and passes the problem to div-terms, which performs the ; division operation on term lists. div-poly finally reattaches the variable to the ; result supplied by div-terms. It is convenient to design div-terms to compute both ; the quotient and the remainder of a division. div-terms can take two term lists as ; arguments and return a list of the quotient term list and the remainder term list. ; ; Complete the following definition of div-terms by filling in the missing expressions. ; Use this to implement div-poly, which takes two polys as arguments and returns a ; list of the quotient and remainder polys. ; Add the following to `polynomial` package ( define ( div-terms L1 L2 ) ( if ( empty-termlist? L1 ) ( list ( the-empty-termlist ) ( the-empty-termlist )) ( let (( t1 ( first-term L1 )) ( t2 ( first-term L2 ))) ( if ( > ( order t2 ) ( order t1 )) ( list ( the-empty-termlist ) L1 ) ( let (( new-c ( div ( coeff t1 ) ( coeff t2 ))) ( new-o ( - ( order t1 ) ( order t2 )))) ( let (( rest-of-result ( div-terms ( add-terms L1 ( negate-terms ( mul-term-by-all-terms ( make-term new-o new-c ) L2 ))) L2 ))) ( cons ( adjoin-term ( make-term new-o new-c ) ( car rest-of-result )) ( cdr rest-of-result )))))))) ; Redefining the polynomial package ( define ( install-polynomial-package ) ;; internal procedures ;; representation of poly ( define ( make-poly variable term-list ) ( cons variable term-list )) ( define ( variable p ) ( car p )) ( define ( term-list p ) ( cdr p )) ; \u27e8procedures same-variable? and variable? from section 2.3.2\u27e9 ( define ( variable? x ) ( symbol? x )) ( define ( same-variable? v1 v2 ) ( and ( variable? v1 ) ( variable? v2 ) ( eq? v1 v2 ))) ;; representation of terms and term lists ;; \u27e8procedures adjoin-term . . . coeff from text below\u27e9 ;; Add ( define ( add-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( add-terms ( term-list p1 ) ( term-list p2 ))) ( error \"Polys not in same var: ADD-POLY\" ( list p1 p2 )))) ( define ( add-terms L1 L2 ) ( cond (( empty-termlist? L1 ) L2 ) (( empty-termlist? L2 ) L1 ) ( else ( let (( t1 ( first-term L1 )) ( t2 ( first-term L2 ))) ( cond (( > ( order t1 ) ( order t2 )) ( adjoin-term t1 ( add-terms ( rest-terms L1 ) L2 ))) (( < ( order t1 ) ( order t2 )) ( adjoin-term t2 ( add-terms L1 ( rest-terms L2 )))) ( else ( adjoin-term ( make-term ( order t1 ) ( add ( coeff t1 ) ( coeff t2 ))) ( add-terms ( rest-terms L1 ) ( rest-terms L2 ))))))))) ;; Multiply ( define ( mul-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( mul-terms ( term-list p1 ) ( term-list p2 ))) ( error \"Polys not in same var: MUL-POLY\" ( list p1 p2 )))) ( define ( mul-terms L1 L2 ) ( if ( empty-termlist? L1 ) ( the-empty-termlist ) ( add-terms ( mul-term-by-all-terms ( first-term L1 ) L2 ) ( mul-terms ( rest-terms ) L2 )))) ( define ( mul-term-by-all-terms t1 L ) ( if ( empty-termlist? L ) ( the-empty-termlist ) ( let (( t2 ( first-term L ))) ( adjoin-term ( make-term ( + ( order t1 ) ( order t2 )) ( mul ( coeff t1 ) ( coeff t2 ))) ( mul-term-by-all-terms t1 ( rest-terms L )))))) ( define ( poly-zero? term-list ) ( if ( empty-termlist? term-list ) #t ( and ( =zero? ( coeff ( first-term term-list ))) ( poly-zero? ( rest-terms term-list ))))) ;; Subtraction ( define ( negate-terms term-list ) ( if ( empty-termlist? term-list ) the-empty-termlist ( adjoin-term ( make-term ( order ( first-term term-list )) ( negate ( coeff ( first-term term-list )))) ( negate-terms ( rest-terms term-list ))))) ( define ( sub-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( add-terms ( term-list p1 ) ( negate-terms ( term-list p2 )))) ( error \"Polys not in same var: SUB-POLY\" ( list p1 p2 )))) ;; Division ( define ( div-terms L1 L2 ) ( if ( empty-termlist? L1 ) ( list ( the-empty-termlist ) ( the-empty-termlist )) ( let (( t1 ( first-term L1 )) ( t2 ( first-term L2 ))) ( if ( > ( order t2 ) ( order t1 )) ( list ( the-empty-termlist ) L1 ) ( let (( new-c ( div ( coeff t1 ) ( coeff t2 ))) ( new-o ( - ( order t1 ) ( order t2 )))) ( let (( rest-of-result ( div-terms ( add-terms L1 ( negate-terms ( mul-term-by-all-terms ( make-term new-o new-c ) L2 ))) L2 ))) ( list ( adjoin-term ( make-term new-o new-c ) ( car rest-of-result )) ( cadr rest-of-result )))))))) ( define ( div-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( let (( ans ( div-terms ( term-list p1 ) ( term-list p2 )))) ( list ( make-poly ( variable p1 ) ( car ans )) ( make-poly ( variable p1 ) ( cadr ans )))) ( error \"Polys not in same var: DIV-POLY\" ( list p1 p2 )))) ;; interface to rest of the system ( define ( tag p ) ( attach-tag 'polynomial p )) ( put '=zero? ' ( polynomial ) ( lambda ( p ) ( poly-zero? ( term-list p )))) ( put 'add ' ( polynomial polynomial ) ( lambda ( p1 p2 ) ( tag ( add-poly p1 p2 )))) ( put 'mul ' ( polynomial polynomial ) ( lambda ( p1 p2 ) ( tag ( mul-poly p1 p2 )))) ( put 'div ' ( polynomial polynomial ) ( lambda ( p1 p2 ) ( tag ( div-poly p1 p2 )))) ( put 'make 'polynomial ( lambda ( var terms ) ( tag ( make-poly var terms )))) ( put 'negate ' ( polynomial ) ( lambda ( p ) ( make-polynomial ( variable p ) ( negate-terms ( term-list p ))))) ( put 'sub ' ( polynomial polynomial ) ( lambda ( p1 p2 ) ( tag ( sub-poly p1 p2 )))) 'done ) ;; representation of terms ( define ( adjoin-term term term-list ) ( if ( =zero? ( coeff term )) term-list ( cons term term-list ))) ( define ( the-empty-termlist ) ' ()) ( define ( first-term term-list ) ( car term-list )) ( define ( rest-terms term-list ) ( cdr term-list )) ( define ( empty-termlist? term-list ) ( null? term-list )) ( define ( make-term order coeff ) ( list order coeff )) ( define ( order term ) ( car term )) ( define ( coeff term ) ( cadr term )) ( define ( make-polynomial var terms ) (( get 'make 'polynomial ) var terms )) ; Testing ( load \"arithmetic-package.scm\" ) ( install-polynomial-package ) ( define p1 ( make-polynomial 'x ( list ( make-term 5 ( make-scheme-number 1 )) ( make-term 0 ( make-scheme-number -1 ))))) ; x^5 - 1 ( define p2 ( make-polynomial 'x ( list ( make-term 2 ( make-scheme-number 1 )) ( make-term 0 ( make-scheme-number -1 ))))) ; x^2 - 1 ( div p1 p2 ) ; Note: This returns an error, couldn't get this working :/","title":"2.91"},{"location":"SICP/ch2-abstraction-data/2.91/#291","text":"; A univariate polynomial can be divided by another one to produce a polynomial ; quotient and a polynomial remainder. For example, ; ; $\\frac{x^5 - 1}{x^2 - 1} = x^3 + x$, remainder $x-1$ ; ; Division can be performed via long division. That is, divide the highest-order ; term of the dividend by the highest-order term of the divisor. The result is the ; first term of the quotient. Next, multiply the result by the divisor, subtract ; that from the dividend, and produce the rest of the answer by recursively dividing ; the difference by the divisor. Stop when the order of the divisor exceeds the order ; of the dividend and declare the dividend to be the remainder. Also, if the dividend ; ever becomes zero, return zero as both quotient and remainder. ; ; We can design a div-poly procedure on the model of add- poly and mul-poly. The ; procedure checks to see if the two polys have the same variable. If so, div-poly ; strips off the variable and passes the problem to div-terms, which performs the ; division operation on term lists. div-poly finally reattaches the variable to the ; result supplied by div-terms. It is convenient to design div-terms to compute both ; the quotient and the remainder of a division. div-terms can take two term lists as ; arguments and return a list of the quotient term list and the remainder term list. ; ; Complete the following definition of div-terms by filling in the missing expressions. ; Use this to implement div-poly, which takes two polys as arguments and returns a ; list of the quotient and remainder polys. ; Add the following to `polynomial` package ( define ( div-terms L1 L2 ) ( if ( empty-termlist? L1 ) ( list ( the-empty-termlist ) ( the-empty-termlist )) ( let (( t1 ( first-term L1 )) ( t2 ( first-term L2 ))) ( if ( > ( order t2 ) ( order t1 )) ( list ( the-empty-termlist ) L1 ) ( let (( new-c ( div ( coeff t1 ) ( coeff t2 ))) ( new-o ( - ( order t1 ) ( order t2 )))) ( let (( rest-of-result ( div-terms ( add-terms L1 ( negate-terms ( mul-term-by-all-terms ( make-term new-o new-c ) L2 ))) L2 ))) ( cons ( adjoin-term ( make-term new-o new-c ) ( car rest-of-result )) ( cdr rest-of-result )))))))) ; Redefining the polynomial package ( define ( install-polynomial-package ) ;; internal procedures ;; representation of poly ( define ( make-poly variable term-list ) ( cons variable term-list )) ( define ( variable p ) ( car p )) ( define ( term-list p ) ( cdr p )) ; \u27e8procedures same-variable? and variable? from section 2.3.2\u27e9 ( define ( variable? x ) ( symbol? x )) ( define ( same-variable? v1 v2 ) ( and ( variable? v1 ) ( variable? v2 ) ( eq? v1 v2 ))) ;; representation of terms and term lists ;; \u27e8procedures adjoin-term . . . coeff from text below\u27e9 ;; Add ( define ( add-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( add-terms ( term-list p1 ) ( term-list p2 ))) ( error \"Polys not in same var: ADD-POLY\" ( list p1 p2 )))) ( define ( add-terms L1 L2 ) ( cond (( empty-termlist? L1 ) L2 ) (( empty-termlist? L2 ) L1 ) ( else ( let (( t1 ( first-term L1 )) ( t2 ( first-term L2 ))) ( cond (( > ( order t1 ) ( order t2 )) ( adjoin-term t1 ( add-terms ( rest-terms L1 ) L2 ))) (( < ( order t1 ) ( order t2 )) ( adjoin-term t2 ( add-terms L1 ( rest-terms L2 )))) ( else ( adjoin-term ( make-term ( order t1 ) ( add ( coeff t1 ) ( coeff t2 ))) ( add-terms ( rest-terms L1 ) ( rest-terms L2 ))))))))) ;; Multiply ( define ( mul-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( mul-terms ( term-list p1 ) ( term-list p2 ))) ( error \"Polys not in same var: MUL-POLY\" ( list p1 p2 )))) ( define ( mul-terms L1 L2 ) ( if ( empty-termlist? L1 ) ( the-empty-termlist ) ( add-terms ( mul-term-by-all-terms ( first-term L1 ) L2 ) ( mul-terms ( rest-terms ) L2 )))) ( define ( mul-term-by-all-terms t1 L ) ( if ( empty-termlist? L ) ( the-empty-termlist ) ( let (( t2 ( first-term L ))) ( adjoin-term ( make-term ( + ( order t1 ) ( order t2 )) ( mul ( coeff t1 ) ( coeff t2 ))) ( mul-term-by-all-terms t1 ( rest-terms L )))))) ( define ( poly-zero? term-list ) ( if ( empty-termlist? term-list ) #t ( and ( =zero? ( coeff ( first-term term-list ))) ( poly-zero? ( rest-terms term-list ))))) ;; Subtraction ( define ( negate-terms term-list ) ( if ( empty-termlist? term-list ) the-empty-termlist ( adjoin-term ( make-term ( order ( first-term term-list )) ( negate ( coeff ( first-term term-list )))) ( negate-terms ( rest-terms term-list ))))) ( define ( sub-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( add-terms ( term-list p1 ) ( negate-terms ( term-list p2 )))) ( error \"Polys not in same var: SUB-POLY\" ( list p1 p2 )))) ;; Division ( define ( div-terms L1 L2 ) ( if ( empty-termlist? L1 ) ( list ( the-empty-termlist ) ( the-empty-termlist )) ( let (( t1 ( first-term L1 )) ( t2 ( first-term L2 ))) ( if ( > ( order t2 ) ( order t1 )) ( list ( the-empty-termlist ) L1 ) ( let (( new-c ( div ( coeff t1 ) ( coeff t2 ))) ( new-o ( - ( order t1 ) ( order t2 )))) ( let (( rest-of-result ( div-terms ( add-terms L1 ( negate-terms ( mul-term-by-all-terms ( make-term new-o new-c ) L2 ))) L2 ))) ( list ( adjoin-term ( make-term new-o new-c ) ( car rest-of-result )) ( cadr rest-of-result )))))))) ( define ( div-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( let (( ans ( div-terms ( term-list p1 ) ( term-list p2 )))) ( list ( make-poly ( variable p1 ) ( car ans )) ( make-poly ( variable p1 ) ( cadr ans )))) ( error \"Polys not in same var: DIV-POLY\" ( list p1 p2 )))) ;; interface to rest of the system ( define ( tag p ) ( attach-tag 'polynomial p )) ( put '=zero? ' ( polynomial ) ( lambda ( p ) ( poly-zero? ( term-list p )))) ( put 'add ' ( polynomial polynomial ) ( lambda ( p1 p2 ) ( tag ( add-poly p1 p2 )))) ( put 'mul ' ( polynomial polynomial ) ( lambda ( p1 p2 ) ( tag ( mul-poly p1 p2 )))) ( put 'div ' ( polynomial polynomial ) ( lambda ( p1 p2 ) ( tag ( div-poly p1 p2 )))) ( put 'make 'polynomial ( lambda ( var terms ) ( tag ( make-poly var terms )))) ( put 'negate ' ( polynomial ) ( lambda ( p ) ( make-polynomial ( variable p ) ( negate-terms ( term-list p ))))) ( put 'sub ' ( polynomial polynomial ) ( lambda ( p1 p2 ) ( tag ( sub-poly p1 p2 )))) 'done ) ;; representation of terms ( define ( adjoin-term term term-list ) ( if ( =zero? ( coeff term )) term-list ( cons term term-list ))) ( define ( the-empty-termlist ) ' ()) ( define ( first-term term-list ) ( car term-list )) ( define ( rest-terms term-list ) ( cdr term-list )) ( define ( empty-termlist? term-list ) ( null? term-list )) ( define ( make-term order coeff ) ( list order coeff )) ( define ( order term ) ( car term )) ( define ( coeff term ) ( cadr term )) ( define ( make-polynomial var terms ) (( get 'make 'polynomial ) var terms )) ; Testing ( load \"arithmetic-package.scm\" ) ( install-polynomial-package ) ( define p1 ( make-polynomial 'x ( list ( make-term 5 ( make-scheme-number 1 )) ( make-term 0 ( make-scheme-number -1 ))))) ; x^5 - 1 ( define p2 ( make-polynomial 'x ( list ( make-term 2 ( make-scheme-number 1 )) ( make-term 0 ( make-scheme-number -1 ))))) ; x^2 - 1 ( div p1 p2 ) ; Note: This returns an error, couldn't get this working :/","title":"2.91"},{"location":"SICP/ch2-abstraction-data/arithmetic-package/","text":"arithmetic-package \u00b6 ( load \"packages/general.scm\" ) ( load \"packages/polar.scm\" ) ( load \"packages/rectangular.scm\" ) ; Generic arithmetic packages ( define ( add x y ) ( apply-generic 'add x y )) ( define ( sub x y ) ( apply-generic 'sub x y )) ( define ( mul x y ) ( apply-generic 'mul x y )) ( define ( div x y ) ( apply-generic 'div x y )) ( define ( =zero? x ) ( apply-generic '=zero? x )) ( define ( negate x ) ( apply-generic 'negate x )) ; Primitive package ( define ( install-scheme-number-package ) ( define ( tag x ) ( attach-tag 'scheme-number x )) ( put 'add ' ( scheme-number scheme-number ) ( lambda ( x y ) ( tag ( + x y )))) ( put 'sub ' ( scheme-number scheme-number ) ( lambda ( x y ) ( tag ( - x y )))) ( put 'mul ' ( scheme-number scheme-number ) ( lambda ( x y ) ( tag ( * x y )))) ( put 'div ' ( scheme-number scheme-number ) ( lambda ( x y ) ( tag ( / x y )))) ( put 'equ? ' ( scheme-number scheme-number ) = ) ( put '=zero? ' ( scheme-number ) ( lambda ( x ) ( = x 0 ))) ( put 'negate ' ( scheme-number ) ( lambda ( x ) ( tag ( - x )))) ( put 'make 'scheme-number ( lambda ( x ) ( tag x ))) 'done ) ( define ( make-scheme-number n ) (( get 'make 'scheme-number ) n )) ; Rational number package ( define ( install-rational-package ) ;; internal procedures ( define ( numer x ) ( car x )) ( define ( denom x ) ( cdr x )) ( define ( make-rat n d ) ( let (( g ( gcd n d ))) ( cons ( / n g ) ( / d g )))) ( define ( add-rat x y ) ( make-rat ( + ( * ( numer x ) ( denom y )) ( * ( numer y ) ( denom x ))) ( * ( denom x ) ( denom y )))) ( define ( sub-rat x y ) ( make-rat ( - ( * ( numer x ) ( denom y )) ( * ( numer y ) ( denom x ))) ( * ( denom x ) ( denom y )))) ( define ( mul-rat x y ) ( make-rat ( * ( numer x ) ( numer y )) ( * ( denom x ) ( denom y )))) ( define ( div-rat x y ) ( make-rat ( * ( numer x ) ( denom y )) ( * ( denom x ) ( numer y )))) ;; interface to rest of the system ( define ( tag x ) ( attach-tag 'rational x )) ( put 'add ' ( rational rational ) ( lambda ( x y ) ( tag ( add-rat x y )))) ( put 'sub ' ( rational rational ) ( lambda ( x y ) ( tag ( sub-rat x y )))) ( put 'mul ' ( rational rational ) ( lambda ( x y ) ( tag ( mul-rat x y )))) ( put 'div ' ( rational rational ) ( lambda ( x y ) ( tag ( div-rat x y )))) ( put 'equ? ' ( rational rational ) ( lambda ( x y ) ( and ( = ( numer x ) ( numer y )) ( = ( denom x ) ( denom y ))))) ( put '=zero? ' ( rational ) ( lambda ( x ) ( = ( numer x ) 0 ))) ( put 'negate ' ( rational ) ( lambda ( x ) ( make-rat ( - numer x ) ( denom x )))) ( put 'make 'rational ( lambda ( n d ) ( tag ( make-rat n d )))) 'done ) ( define ( make-rational n d ) (( get 'make 'rational ) n d )) ; Complex number package ( define ( install-complex-package ) ;; imported procedures from rectangular and polar packages ( define ( make-from-real-imag x y ) (( get 'make-from-real-imag 'rectangular ) x y )) ( define ( make-from-mag-ang r a ) (( get 'make-from-mag-ang 'polar ) r a )) ;; internal procedures ( define ( add-complex z1 z2 ) ( make-from-real-imag ( + ( real-part z1 ) ( real-part z2 )) ( + ( imag-part z1 ) ( imag-part z2 )))) ( define ( sub-complex z1 z2 ) ( make-from-real-imag ( - ( real-part z1 ) ( real-part z2 )) ( - ( imag-part z1 ) ( imag-part z2 )))) ( define ( mul-complex z1 z2 ) ( make-from-mag-ang ( * ( magnitude z1 ) ( magnitude z2 )) ( + ( angle z1 ) ( angle z2 )))) ( define ( div-complex z1 z2 ) ( make-from-mag-ang ( / ( magnitude z1 ) ( magnitude z2 )) ( - ( angle z1 ) ( angle z2 )))) ;; interface to rest of the system ( define ( tag z ) ( attach-tag 'complex z )) ( put 'add ' ( complex complex ) ( lambda ( z1 z2 ) ( tag ( add-complex z1 z2 )))) ( put 'sub ' ( complex complex ) ( lambda ( z1 z2 ) ( tag ( sub-complex z1 z2 )))) ( put 'mul ' ( complex complex ) ( lambda ( z1 z2 ) ( tag ( mul-complex z1 z2 )))) ( put 'div ' ( complex complex ) ( lambda ( z1 z2 ) ( tag ( div-complex z1 z2 )))) ( put 'equ? ' ( complex complex ) ( lambda ( z1 z2 ) ( and ( = ( real-part z1 ) ( real-part z2 )) ( = ( imag-part z1 ) ( imag-part z2 ))))) ( put '=zero? ' ( complex ) ( lambda ( z ) ( = ( real-part z ) ( imag-part z ) 0 ))) ( put 'negate ' ( complex ) ( lambda ( z ) ( make-from-real-imag ( - ( real-part z )) ( - ( imag-part z ))))) ( put 'make-from-real-imag 'complex ( lambda ( x y ) ( tag ( make-from-real-imag x y )))) ( put 'make-from-mag-ang 'complex ( lambda ( r a ) ( tag ( make-from-mag-ang r a )))) 'done ) ( install-scheme-number-package ) ( install-rectangular-package ) ( install-polar-package ) ( install-complex-package ) ( install-rational-package ) ( define ( make-complex-from-real-imag x y ) (( get 'make-from-real-imag 'complex ) x y )) ( define ( make-complex-from-mag-ang r a ) (( get 'make-from-mag-ang 'complex ) r a ))","title":"arithmetic-package"},{"location":"SICP/ch2-abstraction-data/arithmetic-package/#arithmetic-package","text":"( load \"packages/general.scm\" ) ( load \"packages/polar.scm\" ) ( load \"packages/rectangular.scm\" ) ; Generic arithmetic packages ( define ( add x y ) ( apply-generic 'add x y )) ( define ( sub x y ) ( apply-generic 'sub x y )) ( define ( mul x y ) ( apply-generic 'mul x y )) ( define ( div x y ) ( apply-generic 'div x y )) ( define ( =zero? x ) ( apply-generic '=zero? x )) ( define ( negate x ) ( apply-generic 'negate x )) ; Primitive package ( define ( install-scheme-number-package ) ( define ( tag x ) ( attach-tag 'scheme-number x )) ( put 'add ' ( scheme-number scheme-number ) ( lambda ( x y ) ( tag ( + x y )))) ( put 'sub ' ( scheme-number scheme-number ) ( lambda ( x y ) ( tag ( - x y )))) ( put 'mul ' ( scheme-number scheme-number ) ( lambda ( x y ) ( tag ( * x y )))) ( put 'div ' ( scheme-number scheme-number ) ( lambda ( x y ) ( tag ( / x y )))) ( put 'equ? ' ( scheme-number scheme-number ) = ) ( put '=zero? ' ( scheme-number ) ( lambda ( x ) ( = x 0 ))) ( put 'negate ' ( scheme-number ) ( lambda ( x ) ( tag ( - x )))) ( put 'make 'scheme-number ( lambda ( x ) ( tag x ))) 'done ) ( define ( make-scheme-number n ) (( get 'make 'scheme-number ) n )) ; Rational number package ( define ( install-rational-package ) ;; internal procedures ( define ( numer x ) ( car x )) ( define ( denom x ) ( cdr x )) ( define ( make-rat n d ) ( let (( g ( gcd n d ))) ( cons ( / n g ) ( / d g )))) ( define ( add-rat x y ) ( make-rat ( + ( * ( numer x ) ( denom y )) ( * ( numer y ) ( denom x ))) ( * ( denom x ) ( denom y )))) ( define ( sub-rat x y ) ( make-rat ( - ( * ( numer x ) ( denom y )) ( * ( numer y ) ( denom x ))) ( * ( denom x ) ( denom y )))) ( define ( mul-rat x y ) ( make-rat ( * ( numer x ) ( numer y )) ( * ( denom x ) ( denom y )))) ( define ( div-rat x y ) ( make-rat ( * ( numer x ) ( denom y )) ( * ( denom x ) ( numer y )))) ;; interface to rest of the system ( define ( tag x ) ( attach-tag 'rational x )) ( put 'add ' ( rational rational ) ( lambda ( x y ) ( tag ( add-rat x y )))) ( put 'sub ' ( rational rational ) ( lambda ( x y ) ( tag ( sub-rat x y )))) ( put 'mul ' ( rational rational ) ( lambda ( x y ) ( tag ( mul-rat x y )))) ( put 'div ' ( rational rational ) ( lambda ( x y ) ( tag ( div-rat x y )))) ( put 'equ? ' ( rational rational ) ( lambda ( x y ) ( and ( = ( numer x ) ( numer y )) ( = ( denom x ) ( denom y ))))) ( put '=zero? ' ( rational ) ( lambda ( x ) ( = ( numer x ) 0 ))) ( put 'negate ' ( rational ) ( lambda ( x ) ( make-rat ( - numer x ) ( denom x )))) ( put 'make 'rational ( lambda ( n d ) ( tag ( make-rat n d )))) 'done ) ( define ( make-rational n d ) (( get 'make 'rational ) n d )) ; Complex number package ( define ( install-complex-package ) ;; imported procedures from rectangular and polar packages ( define ( make-from-real-imag x y ) (( get 'make-from-real-imag 'rectangular ) x y )) ( define ( make-from-mag-ang r a ) (( get 'make-from-mag-ang 'polar ) r a )) ;; internal procedures ( define ( add-complex z1 z2 ) ( make-from-real-imag ( + ( real-part z1 ) ( real-part z2 )) ( + ( imag-part z1 ) ( imag-part z2 )))) ( define ( sub-complex z1 z2 ) ( make-from-real-imag ( - ( real-part z1 ) ( real-part z2 )) ( - ( imag-part z1 ) ( imag-part z2 )))) ( define ( mul-complex z1 z2 ) ( make-from-mag-ang ( * ( magnitude z1 ) ( magnitude z2 )) ( + ( angle z1 ) ( angle z2 )))) ( define ( div-complex z1 z2 ) ( make-from-mag-ang ( / ( magnitude z1 ) ( magnitude z2 )) ( - ( angle z1 ) ( angle z2 )))) ;; interface to rest of the system ( define ( tag z ) ( attach-tag 'complex z )) ( put 'add ' ( complex complex ) ( lambda ( z1 z2 ) ( tag ( add-complex z1 z2 )))) ( put 'sub ' ( complex complex ) ( lambda ( z1 z2 ) ( tag ( sub-complex z1 z2 )))) ( put 'mul ' ( complex complex ) ( lambda ( z1 z2 ) ( tag ( mul-complex z1 z2 )))) ( put 'div ' ( complex complex ) ( lambda ( z1 z2 ) ( tag ( div-complex z1 z2 )))) ( put 'equ? ' ( complex complex ) ( lambda ( z1 z2 ) ( and ( = ( real-part z1 ) ( real-part z2 )) ( = ( imag-part z1 ) ( imag-part z2 ))))) ( put '=zero? ' ( complex ) ( lambda ( z ) ( = ( real-part z ) ( imag-part z ) 0 ))) ( put 'negate ' ( complex ) ( lambda ( z ) ( make-from-real-imag ( - ( real-part z )) ( - ( imag-part z ))))) ( put 'make-from-real-imag 'complex ( lambda ( x y ) ( tag ( make-from-real-imag x y )))) ( put 'make-from-mag-ang 'complex ( lambda ( r a ) ( tag ( make-from-mag-ang r a )))) 'done ) ( install-scheme-number-package ) ( install-rectangular-package ) ( install-polar-package ) ( install-complex-package ) ( install-rational-package ) ( define ( make-complex-from-real-imag x y ) (( get 'make-from-real-imag 'complex ) x y )) ( define ( make-complex-from-mag-ang r a ) (( get 'make-from-mag-ang 'complex ) r a ))","title":"arithmetic-package"},{"location":"SICP/ch2-abstraction-data/complex-numbers/","text":"complex-numbers \u00b6 ; Arithmetic ( define ( add-complex z1 z2 ) ( make-from-real-imag ( + ( real-part z1 ) ( real-part z2 )) ( + ( imag-part z1 ) ( imag-part z2 )))) ( define ( sub-complex z1 z2 ) ( make-from-real-imag ( - ( real-part z1 ) ( real-part z2 )) ( - ( imag-part z1 ) ( imag-part z2 )))) ( define ( mul-complex z1 z2 ) ( make-from-mag-ang ( * ( magnitude z1 ) ( magnitude z2 )) ( + ( angle z1 ) ( * angle z2 )))) ( define ( div-complex z1 z2 ) ( make-from-mag-ang ( / ( magnitude z1 ) ( magnitude z2 )) ( - ( angle z1 ) ( * angle z2 )))) ; Representation ; (1) In Coordinate form ( define ( real-part z ) ( car z )) ( define ( imag-part z ) ( cdr z )) ( define ( magnitude z ) ( sqrt ( + ( square ( real-part z )) ( square ( imag-part z ))))) ( define ( angle z ) ( atan ( imag-part z ) ( real-part z ))) ( define ( make-from-real-imag x y ) ( cons x y )) ( define ( make-from-mag-ang r a ) ( cons ( * r ( cos a )) ( * r ( sin a )))) ; (2) In polar form ( define ( real-part z ) ( * ( magnitude z ) ( cos ( angle z )))) ( define ( imag-part z ) ( * ( magnitude z ) ( sin ( angle z )))) ( define ( magnitude z ) ( car z )) ( define ( angle z ) ( cdr z )) ( define ( make-from-real-imag x y ) ( cons ( sqrt ( + ( square x ) ( square y ))) ( atan y x ))) ( define ( make-from-mag-ang r a ) ( cons r a )) ; Tagged data ( define ( attach-tag type-tag contents ) ( cons type-tag contents )) ( define ( type-tag datum ) ( if ( pair? datum ) ( car datum ) ( error \"Bad tagged datum: TYPE-TAG\" datum ))) ( define ( contents datum ) ( if ( pair? datum ) ( cdr datum ) ( error \"Bad tagged datum: CONTENTS\" datum ))) ( define ( rectangular? z ) ( eq? ( type-tag z ) 'rectangular )) ( define ( polar? z ) ( eq? ( type-tag z ) 'polar )) ; Ben's revised rectangular representation ( define ( real-part-rectangular z ) ( car z )) ( define ( imag-part-rectangular z ) ( cdr z )) ( define ( magnitude-rectangular z ) ( sqrt ( + ( square ( real-part-rectangular z )) ( square ( imag-part-rectangular z ))))) ( define ( angle-rectangular z ) ( atan ( imag-part-rectangular z ) ( real-part-rectangular z ))) ( define ( make-from-real-imag-rectangular x y ) ( attach-tag 'rectangular ( cons x y ))) ( define ( make-from-mag-ang-rectangular r a ) ( attach-tag 'rectangular ( cons ( * r ( cos a )) ( * r ( sin a ))))) ; Alyssa's revised polar representation ( define ( real-part-polar z ) ( * ( magnitude-polar z ) ( cos ( angle-polar z )))) ( define ( imag-part-polar z ) ( * ( magnitude-polar z ) ( sin ( angle-polar z )))) ( define ( magnitude-polar z ) ( car z )) ( define ( angle-polar z ) ( cdr z )) ( define ( make-from-real-imag-polar x y ) ( attach-tag 'polar ( cons ( sqrt ( + ( square x ) ( square y ))) ( atan y x )))) ( define ( make-from-mag-ang-polar r a ) ( attach-tag 'polar ( cons r a ))) ; Generic selectors ( define ( real-part z ) ( cond (( rectangular? z ) ( real-part-rectangular ( contents z ))) (( polar? z ) ( real-part-polar ( contents z ))) ( else ( error \"Unknown type: REAL-PART\" z )))) ( define ( imag-part z ) ( cond (( rectangular? z ) ( imag-part-rectangular ( contents z ))) (( polar? z ) ( imag-part-polar ( contents z ))) ( else ( error \"Unknown type: IMAG-PART\" z )))) ( define ( magnitude z ) ( cond (( rectangular? z ) ( magnitude-rectangular ( contents z ))) (( polar? z ) ( magnitude-polar ( contents z ))) ( else ( error \"Unknown type: MAGNITUDE\" z )))) ( define ( angle z ) ( cond (( rectangular? z ) ( angle-rectangular ( contents z ))) (( polar? z ) ( angle-polar ( contents z ))) ( else ( error \"Unknown type: ANGLE\" z )))) ( define ( make-from-real-imag x y ) ( make-from-real-imag-rectangular x y )) ( define ( make-from-mag-ang r a ) ( make-from-mag-ang-polar r a ))","title":"complex-numbers"},{"location":"SICP/ch2-abstraction-data/complex-numbers/#complex-numbers","text":"; Arithmetic ( define ( add-complex z1 z2 ) ( make-from-real-imag ( + ( real-part z1 ) ( real-part z2 )) ( + ( imag-part z1 ) ( imag-part z2 )))) ( define ( sub-complex z1 z2 ) ( make-from-real-imag ( - ( real-part z1 ) ( real-part z2 )) ( - ( imag-part z1 ) ( imag-part z2 )))) ( define ( mul-complex z1 z2 ) ( make-from-mag-ang ( * ( magnitude z1 ) ( magnitude z2 )) ( + ( angle z1 ) ( * angle z2 )))) ( define ( div-complex z1 z2 ) ( make-from-mag-ang ( / ( magnitude z1 ) ( magnitude z2 )) ( - ( angle z1 ) ( * angle z2 )))) ; Representation ; (1) In Coordinate form ( define ( real-part z ) ( car z )) ( define ( imag-part z ) ( cdr z )) ( define ( magnitude z ) ( sqrt ( + ( square ( real-part z )) ( square ( imag-part z ))))) ( define ( angle z ) ( atan ( imag-part z ) ( real-part z ))) ( define ( make-from-real-imag x y ) ( cons x y )) ( define ( make-from-mag-ang r a ) ( cons ( * r ( cos a )) ( * r ( sin a )))) ; (2) In polar form ( define ( real-part z ) ( * ( magnitude z ) ( cos ( angle z )))) ( define ( imag-part z ) ( * ( magnitude z ) ( sin ( angle z )))) ( define ( magnitude z ) ( car z )) ( define ( angle z ) ( cdr z )) ( define ( make-from-real-imag x y ) ( cons ( sqrt ( + ( square x ) ( square y ))) ( atan y x ))) ( define ( make-from-mag-ang r a ) ( cons r a )) ; Tagged data ( define ( attach-tag type-tag contents ) ( cons type-tag contents )) ( define ( type-tag datum ) ( if ( pair? datum ) ( car datum ) ( error \"Bad tagged datum: TYPE-TAG\" datum ))) ( define ( contents datum ) ( if ( pair? datum ) ( cdr datum ) ( error \"Bad tagged datum: CONTENTS\" datum ))) ( define ( rectangular? z ) ( eq? ( type-tag z ) 'rectangular )) ( define ( polar? z ) ( eq? ( type-tag z ) 'polar )) ; Ben's revised rectangular representation ( define ( real-part-rectangular z ) ( car z )) ( define ( imag-part-rectangular z ) ( cdr z )) ( define ( magnitude-rectangular z ) ( sqrt ( + ( square ( real-part-rectangular z )) ( square ( imag-part-rectangular z ))))) ( define ( angle-rectangular z ) ( atan ( imag-part-rectangular z ) ( real-part-rectangular z ))) ( define ( make-from-real-imag-rectangular x y ) ( attach-tag 'rectangular ( cons x y ))) ( define ( make-from-mag-ang-rectangular r a ) ( attach-tag 'rectangular ( cons ( * r ( cos a )) ( * r ( sin a ))))) ; Alyssa's revised polar representation ( define ( real-part-polar z ) ( * ( magnitude-polar z ) ( cos ( angle-polar z )))) ( define ( imag-part-polar z ) ( * ( magnitude-polar z ) ( sin ( angle-polar z )))) ( define ( magnitude-polar z ) ( car z )) ( define ( angle-polar z ) ( cdr z )) ( define ( make-from-real-imag-polar x y ) ( attach-tag 'polar ( cons ( sqrt ( + ( square x ) ( square y ))) ( atan y x )))) ( define ( make-from-mag-ang-polar r a ) ( attach-tag 'polar ( cons r a ))) ; Generic selectors ( define ( real-part z ) ( cond (( rectangular? z ) ( real-part-rectangular ( contents z ))) (( polar? z ) ( real-part-polar ( contents z ))) ( else ( error \"Unknown type: REAL-PART\" z )))) ( define ( imag-part z ) ( cond (( rectangular? z ) ( imag-part-rectangular ( contents z ))) (( polar? z ) ( imag-part-polar ( contents z ))) ( else ( error \"Unknown type: IMAG-PART\" z )))) ( define ( magnitude z ) ( cond (( rectangular? z ) ( magnitude-rectangular ( contents z ))) (( polar? z ) ( magnitude-polar ( contents z ))) ( else ( error \"Unknown type: MAGNITUDE\" z )))) ( define ( angle z ) ( cond (( rectangular? z ) ( angle-rectangular ( contents z ))) (( polar? z ) ( angle-polar ( contents z ))) ( else ( error \"Unknown type: ANGLE\" z )))) ( define ( make-from-real-imag x y ) ( make-from-real-imag-rectangular x y )) ( define ( make-from-mag-ang r a ) ( make-from-mag-ang-polar r a ))","title":"complex-numbers"},{"location":"SICP/ch2-abstraction-data/conventional-interface/","text":"conventional-interface \u00b6 ; Sum of squares of odd tree leaves ( define ( sum-odd-squares tree ) ( cond (( null? tree ) 0 ) (( not ( pair? tree )) ( if ( odd? tree ) ( square tree ) 0 )) ( else ( + ( sum-odd-squares ( car tree )) ( sum-odd-squares ( cdr tree )))))) ( sum-odd-squares ( list 1 ( list 2 ( list 3 4 ) 5 ) ( list 6 7 ))) ;Value: 84 (1 + 9 + 25 + 49) ; Even fibonacci numbers ( define ( fib n ) ( define ( iter a b count ) ( if ( = count 0 ) b ( iter ( + a b ) a ( - count 1 )))) ( iter 1 0 n )) ( define nil ' ()) ( define ( even-fibs n ) ( define ( next k ) ( if ( > k n ) nil ( let (( f ( fib k ))) ( if ( even? f ) ( cons f ( next ( + k 1 ))) ( next ( + k 1 )))))) ( next 0 )) ( even-fibs 10 ) ; (0 2 8 34) ; Sequence operations ; Defining filter ( define ( fitler predicate sequence ) ( cond (( null? sequence ) nil ) (( predicate ( car sequence )) ( cons ( car sequence ) ( filter predicate ( cdr sequence )))) ( else ( filter predicate sequence )))) ( filter odd? ( list 1 2 3 4 5 6 )) ; (1 3 5) ; Defining accumulation ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( accumulate + 0 ( list 1 2 3 4 )) ;Value: 10 ( accumulate * 1 ( list 1 2 3 4 )) ;Value: 24 ( accumulate cons nil ( list 1 2 3 4 5 )) ;(1 2 3 4 5) ; Enumerating integers ( define ( enumarate-interval low high ) ( if ( > low high ) nil ( cons low ( enumarate-interval ( + low 1 ) high )))) ( enumarate-interval 2 7 ) ; (2 3 4 5 6 7) ; Enumerating tree ( define ( enumerate-tree tree ) ( cond (( null? tree ) nil ) (( not ( pair? tree )) ( list tree )) ( else ( append ( enumerate-tree ( car tree )) ( enumerate-tree ( cdr tree )))))) ( enumerate-tree ( list 1 ( list 2 ( list 3 4 )) 5 )) ; (1 2 3 4 5) ; Rewriting `sum-odd-squares` ( define ( sum-odd-squares tree ) ( accumulate + 0 ( map square ( filter odd? ( enumerate-tree tree ))))) ( sum-odd-squares ( list 1 ( list 2 ( list 3 4 ) 5 ) ( list 6 7 ))) ;Value: 84 ; Rewriting `even-fibs` ( define ( even-fibs k ) ( accumulate cons nil ( filter even? ( map fib ( enumarate-interval 0 k ))))) ( even-fibs 10 ) ; (0 2 8 34) ( define ( list-fib-squares n ) ( accumulate cons nil ( map square ( map fib ( enumarate-interval 0 n ))))) ( list-fib-squares 10 ) ; (0 1 1 4 9 25 64 169 441 1156 3025)","title":"conventional-interface"},{"location":"SICP/ch2-abstraction-data/conventional-interface/#conventional-interface","text":"; Sum of squares of odd tree leaves ( define ( sum-odd-squares tree ) ( cond (( null? tree ) 0 ) (( not ( pair? tree )) ( if ( odd? tree ) ( square tree ) 0 )) ( else ( + ( sum-odd-squares ( car tree )) ( sum-odd-squares ( cdr tree )))))) ( sum-odd-squares ( list 1 ( list 2 ( list 3 4 ) 5 ) ( list 6 7 ))) ;Value: 84 (1 + 9 + 25 + 49) ; Even fibonacci numbers ( define ( fib n ) ( define ( iter a b count ) ( if ( = count 0 ) b ( iter ( + a b ) a ( - count 1 )))) ( iter 1 0 n )) ( define nil ' ()) ( define ( even-fibs n ) ( define ( next k ) ( if ( > k n ) nil ( let (( f ( fib k ))) ( if ( even? f ) ( cons f ( next ( + k 1 ))) ( next ( + k 1 )))))) ( next 0 )) ( even-fibs 10 ) ; (0 2 8 34) ; Sequence operations ; Defining filter ( define ( fitler predicate sequence ) ( cond (( null? sequence ) nil ) (( predicate ( car sequence )) ( cons ( car sequence ) ( filter predicate ( cdr sequence )))) ( else ( filter predicate sequence )))) ( filter odd? ( list 1 2 3 4 5 6 )) ; (1 3 5) ; Defining accumulation ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( accumulate + 0 ( list 1 2 3 4 )) ;Value: 10 ( accumulate * 1 ( list 1 2 3 4 )) ;Value: 24 ( accumulate cons nil ( list 1 2 3 4 5 )) ;(1 2 3 4 5) ; Enumerating integers ( define ( enumarate-interval low high ) ( if ( > low high ) nil ( cons low ( enumarate-interval ( + low 1 ) high )))) ( enumarate-interval 2 7 ) ; (2 3 4 5 6 7) ; Enumerating tree ( define ( enumerate-tree tree ) ( cond (( null? tree ) nil ) (( not ( pair? tree )) ( list tree )) ( else ( append ( enumerate-tree ( car tree )) ( enumerate-tree ( cdr tree )))))) ( enumerate-tree ( list 1 ( list 2 ( list 3 4 )) 5 )) ; (1 2 3 4 5) ; Rewriting `sum-odd-squares` ( define ( sum-odd-squares tree ) ( accumulate + 0 ( map square ( filter odd? ( enumerate-tree tree ))))) ( sum-odd-squares ( list 1 ( list 2 ( list 3 4 ) 5 ) ( list 6 7 ))) ;Value: 84 ; Rewriting `even-fibs` ( define ( even-fibs k ) ( accumulate cons nil ( filter even? ( map fib ( enumarate-interval 0 k ))))) ( even-fibs 10 ) ; (0 2 8 34) ( define ( list-fib-squares n ) ( accumulate cons nil ( map square ( map fib ( enumarate-interval 0 n ))))) ( list-fib-squares 10 ) ; (0 1 1 4 9 25 64 169 441 1156 3025)","title":"conventional-interface"},{"location":"SICP/ch2-abstraction-data/huffman-tree/","text":"huffman-tree \u00b6 ; Huffman-trees ; Representation ( define ( make-leaf symbol weight ) ( list 'leaf symbol weight )) ( define ( leaf? object ) ( eq? ( car object ) 'leaf )) ( define ( symbol-leaf x ) ( cadr x )) ( define ( weight-leaf x ) ( caddr x )) ( define ( make-code-tree left right ) ( list left right ( append ( symbols left ) ( symbols right )) ( + ( weight left ) ( weight right )))) ( define ( left-branch tree ) ( car tree )) ( define ( right-branch tree ) ( cadr tree )) ( define ( symbols tree ) ( if ( leaf? tree ) ( list ( symbol-leaf tree )) ( caddr tree ))) ( define ( weight tree ) ( if ( leaf? tree ) ( weight-leaf tree ) ( cadddr tree ))) ; Decoding ( define ( decode bits tree ) ( define ( decode-1 bits current-branch ) ( if ( null? bits ) ' () ( let (( next-branch ( choose-branch ( car bits ) current-branch ))) ( if ( leaf? next-branch ) ( cons ( symbol-leaf next-branch ) ( decode-1 ( cdr bits ) tree )) ( decode-1 ( cdr bits ) next-branch ))))) ( decode-1 bits tree )) ( define ( choose-branch bit branch ) ( cond (( = bit 0 ) ( left-branch branch )) (( = bit 1 ) ( right-branch branch )) ( else ( error \"bad bit: CHOOSE-BRANCH\" bit )))) ; Sets of weighted elements ( define ( adjoin-set x set ) ( cond (( null? set ) ( list x )) (( < ( weight x ) ( weight ( car set ))) ( cons x set )) ( else ( cons ( car set ) ( adjoin-set x ( cdr set )))))) ( define ( make-leaf-set pairs ) ( if ( null? pairs ) ' () ( let (( pair ( car pairs ))) ( adjoin-set ( make-leaf ( car pair ) ; symbol ( cadr pair )) ; frequency ( make-leaf-set ( cdr pairs )))))) ; Testing ( make-leaf-set ' (( A 4 ) ( B 2 ) ( C 1 ) ( D 1 ))) ; ((leaf d 1) (leaf c 1) (leaf b 2) (leaf a 4))","title":"huffman-tree"},{"location":"SICP/ch2-abstraction-data/huffman-tree/#huffman-tree","text":"; Huffman-trees ; Representation ( define ( make-leaf symbol weight ) ( list 'leaf symbol weight )) ( define ( leaf? object ) ( eq? ( car object ) 'leaf )) ( define ( symbol-leaf x ) ( cadr x )) ( define ( weight-leaf x ) ( caddr x )) ( define ( make-code-tree left right ) ( list left right ( append ( symbols left ) ( symbols right )) ( + ( weight left ) ( weight right )))) ( define ( left-branch tree ) ( car tree )) ( define ( right-branch tree ) ( cadr tree )) ( define ( symbols tree ) ( if ( leaf? tree ) ( list ( symbol-leaf tree )) ( caddr tree ))) ( define ( weight tree ) ( if ( leaf? tree ) ( weight-leaf tree ) ( cadddr tree ))) ; Decoding ( define ( decode bits tree ) ( define ( decode-1 bits current-branch ) ( if ( null? bits ) ' () ( let (( next-branch ( choose-branch ( car bits ) current-branch ))) ( if ( leaf? next-branch ) ( cons ( symbol-leaf next-branch ) ( decode-1 ( cdr bits ) tree )) ( decode-1 ( cdr bits ) next-branch ))))) ( decode-1 bits tree )) ( define ( choose-branch bit branch ) ( cond (( = bit 0 ) ( left-branch branch )) (( = bit 1 ) ( right-branch branch )) ( else ( error \"bad bit: CHOOSE-BRANCH\" bit )))) ; Sets of weighted elements ( define ( adjoin-set x set ) ( cond (( null? set ) ( list x )) (( < ( weight x ) ( weight ( car set ))) ( cons x set )) ( else ( cons ( car set ) ( adjoin-set x ( cdr set )))))) ( define ( make-leaf-set pairs ) ( if ( null? pairs ) ' () ( let (( pair ( car pairs ))) ( adjoin-set ( make-leaf ( car pair ) ; symbol ( cadr pair )) ; frequency ( make-leaf-set ( cdr pairs )))))) ; Testing ( make-leaf-set ' (( A 4 ) ( B 2 ) ( C 1 ) ( D 1 ))) ; ((leaf d 1) (leaf c 1) (leaf b 2) (leaf a 4))","title":"huffman-tree"},{"location":"SICP/ch2-abstraction-data/list-transform/","text":"list-transform \u00b6 ; Apply scaling operation ( define ( scale-list items factor ) ( if ( null? items ) items ( cons ( * ( car items ) factor ) ( scale-list ( cdr items ) factor )))) ( scale-list ( list 1 2 3 4 5 ) 10 ) ; (10 20 30 40 50) ; Abstracting the higher level idea `map` ( define ( map proc items ) ( if ( null? items ) items ( cons ( proc ( car items )) ( map proc ( cdr items ))))) ( map abs ( list -10 2.5 -11.6 17 )) ; (10 2.5 11.6 17) ( map square ( list 4 5 6 10 )) ; (16 25 36 100) ( map ( lambda ( x ) ( + x 1 )) ( list 1 4 7 9 )) ; (2 5 8 10) ; scale-list in terms of map ( define ( scale-list items factor ) ( map ( lambda ( x ) ( * x factor )) items )) ( scale-list ( list 1 2 3 4 5 ) 5 ) ; (5 10 15 20 25)","title":"list-transform"},{"location":"SICP/ch2-abstraction-data/list-transform/#list-transform","text":"; Apply scaling operation ( define ( scale-list items factor ) ( if ( null? items ) items ( cons ( * ( car items ) factor ) ( scale-list ( cdr items ) factor )))) ( scale-list ( list 1 2 3 4 5 ) 10 ) ; (10 20 30 40 50) ; Abstracting the higher level idea `map` ( define ( map proc items ) ( if ( null? items ) items ( cons ( proc ( car items )) ( map proc ( cdr items ))))) ( map abs ( list -10 2.5 -11.6 17 )) ; (10 2.5 11.6 17) ( map square ( list 4 5 6 10 )) ; (16 25 36 100) ( map ( lambda ( x ) ( + x 1 )) ( list 1 4 7 9 )) ; (2 5 8 10) ; scale-list in terms of map ( define ( scale-list items factor ) ( map ( lambda ( x ) ( * x factor )) items )) ( scale-list ( list 1 2 3 4 5 ) 5 ) ; (5 10 15 20 25)","title":"list-transform"},{"location":"SICP/ch2-abstraction-data/nested-mappings/","text":"nested-mappings \u00b6 ( define nil ' ()) ( define ( enumarate-interval low high ) ( if ( > low high ) nil ( cons low ( enumarate-interval ( + low 1 ) high )))) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( divides? a b ) ( = ( remainder b a ) 0 )) ( define ( prime? n ) ( define ( smallest-divisor n ) ( find-divisor n 2 )) ( define ( find-divisor n test-divisor ) ( cond (( > ( square test-divisor ) n ) n ) (( divides? test-divisor n ) test-divisor ) ( else ( find-divisor n ( + test-divisor 1 ))))) ( = n ( smallest-divisor n ))) ; Problem: Given positive integer n, find all ordered pairs of distinctive ; integers i, j, where 1 <= j < i <= n, such that i+j is prime ( define ( flatmap proc seq ) ( accumulate append nil ( map proc seq ))) ( define ( prime-sum? pair ) ( prime? ( + ( car pair ) ( cadr pair )))) ( define ( make-pair-sum pair ) ( list ( car pair ) ( cadr pair ) ( + ( car pair ) ( cadr pair )))) ( define ( prime-sum-pairs n ) ( map make-pair-sum ( filter prime-sum? ( flatmap ( lambda ( i ) ( map ( lambda ( j ) ( list i j )) ( enumarate-interval 1 ( - i 1 )))) ( enumarate-interval 1 n ))))) ( prime-sum-pairs 6 ) ; ((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11)) ; Problem: Permutations of a set ( define ( permutations s ) ( if ( null? s ) ( list nil ) ( flatmap ( lambda ( x ) ( map ( lambda ( p ) ( cons x p )) ( permutations ( remove x s )))) s ))) ( define ( remove item sequence ) ( filter ( lambda ( x ) ( not ( = x item ))) sequence )) ( permutations ( list 1 2 3 )) ;Value 3: ((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))","title":"nested-mappings"},{"location":"SICP/ch2-abstraction-data/nested-mappings/#nested-mappings","text":"( define nil ' ()) ( define ( enumarate-interval low high ) ( if ( > low high ) nil ( cons low ( enumarate-interval ( + low 1 ) high )))) ( define ( accumulate op initial sequence ) ( if ( null? sequence ) initial ( op ( car sequence ) ( accumulate op initial ( cdr sequence ))))) ( define ( divides? a b ) ( = ( remainder b a ) 0 )) ( define ( prime? n ) ( define ( smallest-divisor n ) ( find-divisor n 2 )) ( define ( find-divisor n test-divisor ) ( cond (( > ( square test-divisor ) n ) n ) (( divides? test-divisor n ) test-divisor ) ( else ( find-divisor n ( + test-divisor 1 ))))) ( = n ( smallest-divisor n ))) ; Problem: Given positive integer n, find all ordered pairs of distinctive ; integers i, j, where 1 <= j < i <= n, such that i+j is prime ( define ( flatmap proc seq ) ( accumulate append nil ( map proc seq ))) ( define ( prime-sum? pair ) ( prime? ( + ( car pair ) ( cadr pair )))) ( define ( make-pair-sum pair ) ( list ( car pair ) ( cadr pair ) ( + ( car pair ) ( cadr pair )))) ( define ( prime-sum-pairs n ) ( map make-pair-sum ( filter prime-sum? ( flatmap ( lambda ( i ) ( map ( lambda ( j ) ( list i j )) ( enumarate-interval 1 ( - i 1 )))) ( enumarate-interval 1 n ))))) ( prime-sum-pairs 6 ) ; ((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11)) ; Problem: Permutations of a set ( define ( permutations s ) ( if ( null? s ) ( list nil ) ( flatmap ( lambda ( x ) ( map ( lambda ( p ) ( cons x p )) ( permutations ( remove x s )))) s ))) ( define ( remove item sequence ) ( filter ( lambda ( x ) ( not ( = x item ))) sequence )) ( permutations ( list 1 2 3 )) ;Value 3: ((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))","title":"nested-mappings"},{"location":"SICP/ch2-abstraction-data/paint-higher-order/","text":"paint-higher-order \u00b6 # lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ( define wave einstein ) ; Make compatible with the text book ; Square of four higher order procedure ( define ( square-of-four tl tr bl br ) ( lambda ( painter ) ( let (( top ( beside ( tl painter ) ( tr painter ))) ( bottom ( beside ( bl painter ) ( br painter )))) ( below bottom top )))) ; Flipped pair in terms of `square-of-four` ( define ( flipped-pairs painter ) ( let (( combine4 ( square-of-four identity flip-vert identity flip-vert ))) ( combine4 painter ))) ( define f1 ( flipped-pairs wave )) ( display \"Flipped pair\\n\" ) ( paint f1 ) ; Square limit in terms of `square-of-four` ( define ( square-limit painter n ) ( let (( combine4 ( square-of-four flip-horiz identity rotate180 flip-vert ))) ( combine4 ( corner-split painter n )))) ( define ( up-split painter n ) ( if ( = n 0 ) painter ( let (( smaller ( up-split painter ( - n 1 )))) ( below painter ( beside smaller smaller ))))) ( define ( right-split painter n ) ( if ( = n 0 ) painter ( let (( smaller ( right-split painter ( - n 1 )))) ( beside painter ( below smaller smaller ))))) ( define ( corner-split painter n ) ( if ( = n 0 ) painter ( let (( up ( up-split painter ( - n 1 ))) ( right ( right-split painter ( - n 1 )))) ( let (( top-left ( beside up up )) ( bottom-right ( below right right )) ( corner ( corner-split painter ( - n 1 )))) ( beside ( below painter top-left ) ( below bottom-right corner )))))) ( define sl1 ( square-limit wave 3 )) ( display \"\\nSquare limit 3\\n\" ) ( paint sl1 )","title":"paint-higher-order"},{"location":"SICP/ch2-abstraction-data/paint-higher-order/#paint-higher-order","text":"# lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ( define wave einstein ) ; Make compatible with the text book ; Square of four higher order procedure ( define ( square-of-four tl tr bl br ) ( lambda ( painter ) ( let (( top ( beside ( tl painter ) ( tr painter ))) ( bottom ( beside ( bl painter ) ( br painter )))) ( below bottom top )))) ; Flipped pair in terms of `square-of-four` ( define ( flipped-pairs painter ) ( let (( combine4 ( square-of-four identity flip-vert identity flip-vert ))) ( combine4 painter ))) ( define f1 ( flipped-pairs wave )) ( display \"Flipped pair\\n\" ) ( paint f1 ) ; Square limit in terms of `square-of-four` ( define ( square-limit painter n ) ( let (( combine4 ( square-of-four flip-horiz identity rotate180 flip-vert ))) ( combine4 ( corner-split painter n )))) ( define ( up-split painter n ) ( if ( = n 0 ) painter ( let (( smaller ( up-split painter ( - n 1 )))) ( below painter ( beside smaller smaller ))))) ( define ( right-split painter n ) ( if ( = n 0 ) painter ( let (( smaller ( right-split painter ( - n 1 )))) ( beside painter ( below smaller smaller ))))) ( define ( corner-split painter n ) ( if ( = n 0 ) painter ( let (( up ( up-split painter ( - n 1 ))) ( right ( right-split painter ( - n 1 )))) ( let (( top-left ( beside up up )) ( bottom-right ( below right right )) ( corner ( corner-split painter ( - n 1 )))) ( beside ( below painter top-left ) ( below bottom-right corner )))))) ( define sl1 ( square-limit wave 3 )) ( display \"\\nSquare limit 3\\n\" ) ( paint sl1 )","title":"paint-higher-order"},{"location":"SICP/ch2-abstraction-data/paint/","text":"paint \u00b6 # lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ( define wave einstein ) ; Make compatible with the text book ( define wave2 ( beside wave ( flip-vert wave ))) ( define wave4 ( below wave2 wave2 )) ( display \"beside wave \\n\" ) ( paint wave2 ) ( display \"\\nbeside below wave \\n\" ) ( paint wave4 ) ; Creating abstraction for `wave4` ( define ( flipped-pairs painter ) ( let (( painter2 ( beside painter ( flip-vert painter )))) ( below painter2 painter2 ))) ( define wave5 ( flipped-pairs wave )) ( display \"\\nflipped-pairs\\n\" ) ( paint wave5 ) ; Right split procedure ( define ( right-split painter n ) ( if ( = n 0 ) painter ( let (( smaller ( right-split painter ( - n 1 )))) ( beside painter ( below smaller smaller ))))) ( define rs4 ( right-split wave 4 )) ( display \"\\nRight split 4\\n\" ) ( paint rs4 ) ; Up split procedure ( define ( up-split painter n ) ( if ( = n 0 ) painter ( let (( smaller ( up-split painter ( - n 1 )))) ( below painter ( beside smaller smaller ))))) ; Defining `corner-split` procedure ( define ( corner-split painter n ) ( if ( = n 0 ) painter ( let (( up ( up-split painter ( - n 1 ))) ( right ( right-split painter ( - n 1 )))) ( let (( top-left ( beside up up )) ( bottom-right ( below right right )) ( corner ( corner-split painter ( - n 1 )))) ( beside ( below painter top-left ) ( below bottom-right corner )))))) ( define cs3 ( corner-split wave 3 )) ( display \"\\nCorner split 3\\n\" ) ( paint cs3 ) ; Define `square-limit` pattern ( define ( square-limit painter n ) ( let (( quarter ( corner-split painter n ))) ( let (( half ( beside ( flip-horiz quarter ) quarter ))) ( below ( flip-vert half ) half )))) ( define sl3 ( square-limit wave 3 )) ( display \"\\nSquare limit pattern 3\\n\" ) ( paint sl3 )","title":"paint"},{"location":"SICP/ch2-abstraction-data/paint/#paint","text":"# lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ( define wave einstein ) ; Make compatible with the text book ( define wave2 ( beside wave ( flip-vert wave ))) ( define wave4 ( below wave2 wave2 )) ( display \"beside wave \\n\" ) ( paint wave2 ) ( display \"\\nbeside below wave \\n\" ) ( paint wave4 ) ; Creating abstraction for `wave4` ( define ( flipped-pairs painter ) ( let (( painter2 ( beside painter ( flip-vert painter )))) ( below painter2 painter2 ))) ( define wave5 ( flipped-pairs wave )) ( display \"\\nflipped-pairs\\n\" ) ( paint wave5 ) ; Right split procedure ( define ( right-split painter n ) ( if ( = n 0 ) painter ( let (( smaller ( right-split painter ( - n 1 )))) ( beside painter ( below smaller smaller ))))) ( define rs4 ( right-split wave 4 )) ( display \"\\nRight split 4\\n\" ) ( paint rs4 ) ; Up split procedure ( define ( up-split painter n ) ( if ( = n 0 ) painter ( let (( smaller ( up-split painter ( - n 1 )))) ( below painter ( beside smaller smaller ))))) ; Defining `corner-split` procedure ( define ( corner-split painter n ) ( if ( = n 0 ) painter ( let (( up ( up-split painter ( - n 1 ))) ( right ( right-split painter ( - n 1 )))) ( let (( top-left ( beside up up )) ( bottom-right ( below right right )) ( corner ( corner-split painter ( - n 1 )))) ( beside ( below painter top-left ) ( below bottom-right corner )))))) ( define cs3 ( corner-split wave 3 )) ( display \"\\nCorner split 3\\n\" ) ( paint cs3 ) ; Define `square-limit` pattern ( define ( square-limit painter n ) ( let (( quarter ( corner-split painter n ))) ( let (( half ( beside ( flip-horiz quarter ) quarter ))) ( below ( flip-vert half ) half )))) ( define sl3 ( square-limit wave 3 )) ( display \"\\nSquare limit pattern 3\\n\" ) ( paint sl3 )","title":"paint"},{"location":"SICP/ch2-abstraction-data/painter-transform/","text":"painter-transform \u00b6 # lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ; NOTE: \"frame-coord-map\", \"make-vect\", \"make-frame\", \"make-segment\", \"segments->painter\" ; are defined in \"soegaard\" ; Define helpers ( define ( xcor-vect v ) ( car v )) ( define ( ycor-vect v ) ( cdr v )) ( define ( sub-vect v1 v2 ) ( make-vect ( - ( xcor-vect v1 ) ( xcor-vect v2 )) ( - ( ycor-vect v1 ) ( ycor-vect v2 )))) ; Transform painter ( define ( transform-painter painter origin corner1 corner2 ) ( lambda ( frame ) ( let (( m ( frame-coord-map frame ))) ( let (( new-origin ( m origin ))) ( painter ( make-frame new-origin ( sub-vect ( m corner1 ) new-origin ) ( sub-vect ( m corner2 ) new-origin ))))))) ; Flip-vertically ( define ( flip-vert painter ) ( transform-painter painter ( make-vect 0 1 ) ; new origin ( make-vect 1 1 ) ; new end of edge1 ( make-vect 0 0 ))) ; new end of edge2 ; Test vertical flip ( define f1-list ( list ( make-segment ( make-vect 0.3 0.3 ) ( make-vect 0.5 0.7 )) ( make-segment ( make-vect 0.5 0.7 ) ( make-vect 0.8 0.3 )))) ( define f1 ( segments->painter f1-list )) ( display \"\\nFrame f1\\n\" ) ( paint f1 ) ( display \"\\nFrame Flipped f1\\n\" ) ( paint ( flip-vert f1 )) ; Shrink image to upper-right-corner ( define ( shrink-to-upper-right painter ) ( transform-painter painter ( make-vect 0.5 0.5 ) ( make-vect 1.0 0.5 ) ( make-vect 0.5 1.0 ))) ( display \"\\nFrame Shrink upper right corner f1\\n\" ) ( paint ( shrink-to-upper-right f1 )) ; Rotate 90 degrees counterclockwise ( define ( rotate90 painter ) ( transform-painter painter ( make-vect 1.0 0.0 ) ( make-vect 1.0 1.0 ) ( make-vect 0.0 0.0 ))) ( display \"\\nFrame Rotate 90deg f1\\n\" ) ( paint ( rotate90 f1 )) ; Squash inwards ( define ( squash-inwards painter ) ( transform-painter painter ( make-vect 0.0 0.0 ) ( make-vect 0.65 0.35 ) ( make-vect 0.35 0.65 ))) ( display \"\\nFrame Squash inwards f1\\n\" ) ( paint ( squash-inwards f1 )) ; Beside operation by transformation ( define ( beside painter1 painter2 ) ( let (( split-point ( make-vect 0.5 0.0 ))) ( let (( paint-left ( transform-painter painter1 ( make-vect 0.0 0.0 ) split-point ( make-vect 0.0 1.0 ))) ( paint-right ( transform-painter painter2 split-point ( make-vect 1.0 0.0 ) ( make-vect 0.5 1.0 )))) ( lambda ( frame ) ( paint-left frame ) ( paint-right frame ))))) ( display \"\\nBeside f1 f1\\n\" ) ( paint ( beside f1 f1 ))","title":"painter-transform"},{"location":"SICP/ch2-abstraction-data/painter-transform/#painter-transform","text":"# lang racket ( require ( planet \"sicp.ss\" ( \"soegaard\" \"sicp.plt\" 2 1 ))) ; NOTE: \"frame-coord-map\", \"make-vect\", \"make-frame\", \"make-segment\", \"segments->painter\" ; are defined in \"soegaard\" ; Define helpers ( define ( xcor-vect v ) ( car v )) ( define ( ycor-vect v ) ( cdr v )) ( define ( sub-vect v1 v2 ) ( make-vect ( - ( xcor-vect v1 ) ( xcor-vect v2 )) ( - ( ycor-vect v1 ) ( ycor-vect v2 )))) ; Transform painter ( define ( transform-painter painter origin corner1 corner2 ) ( lambda ( frame ) ( let (( m ( frame-coord-map frame ))) ( let (( new-origin ( m origin ))) ( painter ( make-frame new-origin ( sub-vect ( m corner1 ) new-origin ) ( sub-vect ( m corner2 ) new-origin ))))))) ; Flip-vertically ( define ( flip-vert painter ) ( transform-painter painter ( make-vect 0 1 ) ; new origin ( make-vect 1 1 ) ; new end of edge1 ( make-vect 0 0 ))) ; new end of edge2 ; Test vertical flip ( define f1-list ( list ( make-segment ( make-vect 0.3 0.3 ) ( make-vect 0.5 0.7 )) ( make-segment ( make-vect 0.5 0.7 ) ( make-vect 0.8 0.3 )))) ( define f1 ( segments->painter f1-list )) ( display \"\\nFrame f1\\n\" ) ( paint f1 ) ( display \"\\nFrame Flipped f1\\n\" ) ( paint ( flip-vert f1 )) ; Shrink image to upper-right-corner ( define ( shrink-to-upper-right painter ) ( transform-painter painter ( make-vect 0.5 0.5 ) ( make-vect 1.0 0.5 ) ( make-vect 0.5 1.0 ))) ( display \"\\nFrame Shrink upper right corner f1\\n\" ) ( paint ( shrink-to-upper-right f1 )) ; Rotate 90 degrees counterclockwise ( define ( rotate90 painter ) ( transform-painter painter ( make-vect 1.0 0.0 ) ( make-vect 1.0 1.0 ) ( make-vect 0.0 0.0 ))) ( display \"\\nFrame Rotate 90deg f1\\n\" ) ( paint ( rotate90 f1 )) ; Squash inwards ( define ( squash-inwards painter ) ( transform-painter painter ( make-vect 0.0 0.0 ) ( make-vect 0.65 0.35 ) ( make-vect 0.35 0.65 ))) ( display \"\\nFrame Squash inwards f1\\n\" ) ( paint ( squash-inwards f1 )) ; Beside operation by transformation ( define ( beside painter1 painter2 ) ( let (( split-point ( make-vect 0.5 0.0 ))) ( let (( paint-left ( transform-painter painter1 ( make-vect 0.0 0.0 ) split-point ( make-vect 0.0 1.0 ))) ( paint-right ( transform-painter painter2 split-point ( make-vect 1.0 0.0 ) ( make-vect 0.5 1.0 )))) ( lambda ( frame ) ( paint-left frame ) ( paint-right frame ))))) ( display \"\\nBeside f1 f1\\n\" ) ( paint ( beside f1 f1 ))","title":"painter-transform"},{"location":"SICP/ch2-abstraction-data/rational/","text":"rational \u00b6 ; Perform arithmetic operations on rational numbers ( define ( add-rat x y ) ( make-rat ( + ( * ( numer x ) ( denom y )) ( * ( numer y ) ( denom x ))) ( * ( denom x ) ( denom y )))) ( define ( sub-rat x y ) ( make-rat ( - ( * ( numer x ) ( denom y )) ( * ( numer y ) ( denom x ))) ( * ( denom x ) ( denom y )))) ( define ( mul-rat x y ) ( make-rat ( * ( numer x ) ( numer y )) ( * ( denom x ) ( denom y )))) ( define ( div-rat x y ) ( make-rat ( * ( numer x ) ( denom y )) ( * ( denom x ) ( numer y )))) ( define ( equal-rat x y ) ( = ( * ( numer x ) ( denom y )) ( * ( numer y ) ( denom x )))) ; Define `make-rat`, `numer` and `denom` using pairs ( define ( make-rat n d ) ( cons n d )) ( define ( numer x ) ( car x )) ( define ( denom x ) ( cdr x )) ; Display rational number ( define ( print-rat x ) ( newline ) ( display ( numer x )) ( display \"/\" ) ( display ( denom x ))) ; Examples ( define one-half ( make-rat 1 2 )) ( print-rat one-half ) ; 1/2 ( define one-third ( make-rat 1 3 )) ( print-rat ( add-rat one-half one-third )) ; 5/6 ( print-rat ( mul-rat one-half one-third )) ; 1/6 ( print-rat ( add-rat one-third one-third )) ; 6/9 ; Use `gcd` to reduce to lowest terms ( define ( make-rat n d ) ( let (( g ( gcd n d ))) ( cons ( / n g ) ( / d g )))) ( print-rat ( add-rat one-third one-third )) ; 2/3","title":"rational"},{"location":"SICP/ch2-abstraction-data/rational/#rational","text":"; Perform arithmetic operations on rational numbers ( define ( add-rat x y ) ( make-rat ( + ( * ( numer x ) ( denom y )) ( * ( numer y ) ( denom x ))) ( * ( denom x ) ( denom y )))) ( define ( sub-rat x y ) ( make-rat ( - ( * ( numer x ) ( denom y )) ( * ( numer y ) ( denom x ))) ( * ( denom x ) ( denom y )))) ( define ( mul-rat x y ) ( make-rat ( * ( numer x ) ( numer y )) ( * ( denom x ) ( denom y )))) ( define ( div-rat x y ) ( make-rat ( * ( numer x ) ( denom y )) ( * ( denom x ) ( numer y )))) ( define ( equal-rat x y ) ( = ( * ( numer x ) ( denom y )) ( * ( numer y ) ( denom x )))) ; Define `make-rat`, `numer` and `denom` using pairs ( define ( make-rat n d ) ( cons n d )) ( define ( numer x ) ( car x )) ( define ( denom x ) ( cdr x )) ; Display rational number ( define ( print-rat x ) ( newline ) ( display ( numer x )) ( display \"/\" ) ( display ( denom x ))) ; Examples ( define one-half ( make-rat 1 2 )) ( print-rat one-half ) ; 1/2 ( define one-third ( make-rat 1 3 )) ( print-rat ( add-rat one-half one-third )) ; 5/6 ( print-rat ( mul-rat one-half one-third )) ; 1/6 ( print-rat ( add-rat one-third one-third )) ; 6/9 ; Use `gcd` to reduce to lowest terms ( define ( make-rat n d ) ( let (( g ( gcd n d ))) ( cons ( / n g ) ( / d g )))) ( print-rat ( add-rat one-third one-third )) ; 2/3","title":"rational"},{"location":"SICP/ch2-abstraction-data/sequences/","text":"sequences \u00b6 ; List ( define mylist ( list 1 2 3 4 )) ( car mylist ) ;Value: 1 ( cdr mylist ) ;Value 2: (2 3 4) ( cadr mylist ) ;Value: 2 ; Implementation of `list-ref` ( define ( list-ref items n ) ( if ( = n 0 ) ( car items ) ( list-ref ( cdr items ) ( - n 1 )))) ( define squares ( list 1 4 9 16 25 )) ( list-ref squares 3 ) ;Value: 16 ; Length of a list ( define ( length items ) ( if ( null? items ) 0 ( + 1 ( length ( cdr items ))))) ( define odds ( list 1 3 5 7 )) ( length odds ) ;Value: 4 ; Iterative length ( define ( length items ) ( define ( iter a count ) ( if ( null? a ) count ( iter ( cdr a ) ( + 1 count )))) ( iter items 0 )) ( define evens ( list 2 4 6 8 )) ( length evens ) ;Value: 4 ; Append procedure ( define ( append list1 list2 ) ( if ( null? list1 ) list2 ( cons ( car list1 ) ( append ( cdr list1 ) list2 )))) ( append odds evens ) ;(1 3 5 7 2 4 6 8)","title":"sequences"},{"location":"SICP/ch2-abstraction-data/sequences/#sequences","text":"; List ( define mylist ( list 1 2 3 4 )) ( car mylist ) ;Value: 1 ( cdr mylist ) ;Value 2: (2 3 4) ( cadr mylist ) ;Value: 2 ; Implementation of `list-ref` ( define ( list-ref items n ) ( if ( = n 0 ) ( car items ) ( list-ref ( cdr items ) ( - n 1 )))) ( define squares ( list 1 4 9 16 25 )) ( list-ref squares 3 ) ;Value: 16 ; Length of a list ( define ( length items ) ( if ( null? items ) 0 ( + 1 ( length ( cdr items ))))) ( define odds ( list 1 3 5 7 )) ( length odds ) ;Value: 4 ; Iterative length ( define ( length items ) ( define ( iter a count ) ( if ( null? a ) count ( iter ( cdr a ) ( + 1 count )))) ( iter items 0 )) ( define evens ( list 2 4 6 8 )) ( length evens ) ;Value: 4 ; Append procedure ( define ( append list1 list2 ) ( if ( null? list1 ) list2 ( cons ( car list1 ) ( append ( cdr list1 ) list2 )))) ( append odds evens ) ;(1 3 5 7 2 4 6 8)","title":"sequences"},{"location":"SICP/ch2-abstraction-data/sets-ordered/","text":"sets-ordered \u00b6 ; Sets as \"ordered\" lists ( define ( element-of-set? x set ) ( cond (( null? set ) false ) (( = x ( car set )) true ) (( < x ( car set )) false ) ( else ( element-of-set? x ( cdr set ))))) ( define ( intersection-set set1 set2 ) ( if ( or ( null? set1 ) ( null? set2 )) ' () ( let (( x1 ( car set1 )) ( x2 ( car set2 ))) ( cond (( = x1 x2 ) ( cons x1 ( intersection-set ( cdr set1 ) ( cdr set2 )))) (( < x1 x2 ) ( intersection-set ( cdr set1 ) set2 )) (( < x2 x1 ) ( intersection-set set1 ( cdr set2 )))))))","title":"sets-ordered"},{"location":"SICP/ch2-abstraction-data/sets-ordered/#sets-ordered","text":"; Sets as \"ordered\" lists ( define ( element-of-set? x set ) ( cond (( null? set ) false ) (( = x ( car set )) true ) (( < x ( car set )) false ) ( else ( element-of-set? x ( cdr set ))))) ( define ( intersection-set set1 set2 ) ( if ( or ( null? set1 ) ( null? set2 )) ' () ( let (( x1 ( car set1 )) ( x2 ( car set2 ))) ( cond (( = x1 x2 ) ( cons x1 ( intersection-set ( cdr set1 ) ( cdr set2 )))) (( < x1 x2 ) ( intersection-set ( cdr set1 ) set2 )) (( < x2 x1 ) ( intersection-set set1 ( cdr set2 )))))))","title":"sets-ordered"},{"location":"SICP/ch2-abstraction-data/sets-tree/","text":"sets-tree \u00b6 ; Sets as trees ( define ( entry tree ) ( car tree )) ( define ( left-branch tree ) ( cadr tree )) ( define ( right-branch tree ) ( caddr tree )) ( define ( make-tree entry left right ) ( list entry left right )) ; element-of-set? operation ( define ( element-of-set? x set ) ( cond (( null? set ) #f ) (( = x ( entry set )) #t ) (( < x ( entry set )) ( element-of-set? x ( left-branch set ))) (( > x ( entry set )) ( element-of-set? x ( right-branch set ))))) ; Testing `element-of-set?` ( define set1 ( list 7 ( list 3 ( list 1 ' () ' ()) ( list 5 ' () ' ())) ( list 9 ' () ( list 11 ' () ' ())))) ( entry set1 ) ;Value: 7 ( left-branch set1 ) ;(3 (1) (5)) ( right-branch set1 ) ;(9 () (11)) ( element-of-set? 7 set1 ) ;#t ( element-of-set? 1 set1 ) ;#t ( element-of-set? 11 set1 ) ;#t ( element-of-set? 12 set1 ) ;#f ; Adjoin operation ( define ( adjoin-set x set ) ( cond (( null? set ) ( make-tree x ' () ' ())) (( = x ( entry set )) set ) (( < x ( entry set )) ( make-tree ( entry set ) ( adjoin-set x ( left-branch set )) ( right-branch set ))) (( > x ( entry set )) ( make-tree ( entry set ) ( left-branch set ) ( adjoin-set x ( right-branch set )))))) ; Test adjoin ( adjoin-set 8 set1 ) ; (7 (3 (1 () ()) (5 () ())) (9 (8 () ()) (11 () ())))","title":"sets-tree"},{"location":"SICP/ch2-abstraction-data/sets-tree/#sets-tree","text":"; Sets as trees ( define ( entry tree ) ( car tree )) ( define ( left-branch tree ) ( cadr tree )) ( define ( right-branch tree ) ( caddr tree )) ( define ( make-tree entry left right ) ( list entry left right )) ; element-of-set? operation ( define ( element-of-set? x set ) ( cond (( null? set ) #f ) (( = x ( entry set )) #t ) (( < x ( entry set )) ( element-of-set? x ( left-branch set ))) (( > x ( entry set )) ( element-of-set? x ( right-branch set ))))) ; Testing `element-of-set?` ( define set1 ( list 7 ( list 3 ( list 1 ' () ' ()) ( list 5 ' () ' ())) ( list 9 ' () ( list 11 ' () ' ())))) ( entry set1 ) ;Value: 7 ( left-branch set1 ) ;(3 (1) (5)) ( right-branch set1 ) ;(9 () (11)) ( element-of-set? 7 set1 ) ;#t ( element-of-set? 1 set1 ) ;#t ( element-of-set? 11 set1 ) ;#t ( element-of-set? 12 set1 ) ;#f ; Adjoin operation ( define ( adjoin-set x set ) ( cond (( null? set ) ( make-tree x ' () ' ())) (( = x ( entry set )) set ) (( < x ( entry set )) ( make-tree ( entry set ) ( adjoin-set x ( left-branch set )) ( right-branch set ))) (( > x ( entry set )) ( make-tree ( entry set ) ( left-branch set ) ( adjoin-set x ( right-branch set )))))) ; Test adjoin ( adjoin-set 8 set1 ) ; (7 (3 (1 () ()) (5 () ())) (9 (8 () ()) (11 () ())))","title":"sets-tree"},{"location":"SICP/ch2-abstraction-data/sets-unordered/","text":"sets-unordered \u00b6 ; Sets as unordered lists ( define ( element-of-set? x set ) ( cond (( null? set ) false ) (( equal? x ( car set )) #t ) ( else ( element-of-set? x ( cdr set ))))) ; adjoin operation ( define ( adjoin-set x set ) ( if ( element-of-set? x set ) set ( cons x set ))) ; intersection ( define ( intersection-set set1 set2 ) ( cond (( or ( null? set1 ) ( null? set2 )) ' ()) (( element-of-set? ( car set1 ) set2 ) ( cons ( car set1 ) ( intersection-set ( cdr set1 ) set2 ))) ( else ( intersection-set ( cdr set1 ) set2 ))))","title":"sets-unordered"},{"location":"SICP/ch2-abstraction-data/sets-unordered/#sets-unordered","text":"; Sets as unordered lists ( define ( element-of-set? x set ) ( cond (( null? set ) false ) (( equal? x ( car set )) #t ) ( else ( element-of-set? x ( cdr set ))))) ; adjoin operation ( define ( adjoin-set x set ) ( if ( element-of-set? x set ) set ( cons x set ))) ; intersection ( define ( intersection-set set1 set2 ) ( cond (( or ( null? set1 ) ( null? set2 )) ' ()) (( element-of-set? ( car set1 ) set2 ) ( cons ( car set1 ) ( intersection-set ( cdr set1 ) set2 ))) ( else ( intersection-set ( cdr set1 ) set2 ))))","title":"sets-unordered"},{"location":"SICP/ch2-abstraction-data/symbolic-diff/","text":"symbolic-diff \u00b6 ; Derivative in terms of abstract terms ( define ( deriv exp var ) ( cond (( number? exp ) 0 ) (( variable? exp ) ( if ( same-variable? exp var ) 1 0 )) (( sum? exp ) ( make-sum ( deriv ( addend exp ) var ) ( deriv ( augend exp ) var ))) (( product? exp ) ( make-sum ( make-product ( multiplier exp ) ( deriv ( multiplicand exp ) var )) ( make-product ( deriv ( multiplier exp ) var ) ( multiplicand exp )))) ( else ( error \"unknown expression type: DERIV\" exp )))) ; Representing algebraic expressions ( define ( variable? x ) ( symbol? x )) ( define ( same-variable? v1 v2 ) ( and ( variable? v1 ) ( variable? v2 ) ( eq? v1 v2 ))) ( define ( make-sum a1 a2 ) ( list '+ a1 a2 )) ( define ( make-product m1 m2 ) ( list '* m1 m2 )) ; Sum is a list whose first element is symbol +: ( define ( sum? x ) ( and ( pair? x ) ( eq? ( car x ) '+ ))) ( define ( addend s ) ( cadr s )) ( define ( augend s ) ( caddr s )) ; Product is a list whose first element is symbol *: ( define ( product? x ) ( and ( pair? x ) ( eq? ( car x ) '* ))) ( define ( multiplier p ) ( cadr p )) ( define ( multiplicand p ) ( caddr p )) ; Basic examples ( deriv ' ( + x 3 ) 'x ) ; (+ 1 x) ( deriv ' ( * x y ) 'x ) ; (+ (* x 0) (* 1 y)) ( deriv ' ( * ( * x y ) ( + x 3 )) 'x ) ; (+ (* (* x y) (+ 1 x)) (* (+ (* x 0) (* 1 y)) (+ x 3))) ; Simplifying expressions ( define ( =number? exp num ) ( and ( number? exp ) ( = exp num ))) ( =number? 'a 0 ) ; false ( =number? 1 1 ) ; true ( define ( make-sum a1 a2 ) ( cond (( =number? a1 0 ) a2 ) (( =number? a2 0 ) a1 ) (( and ( number? a1 ) ( number? a2 )) ( + a1 a2 )) ( else ( list '+ a1 a2 )))) ( make-sum 2 3 ) ;Value: 5 ( make-sum 'x 0 ) ;Value: x ( make-sum 0 'y ) ;Value: y ( make-sum 'x 'y ) ;(+ x y) ( define ( make-product m1 m2 ) ( cond (( or ( =number? m1 0 ) ( =number? m2 0 )) 0 ) (( =number? m1 1 ) m2 ) (( =number? m2 1 ) m1 ) (( and ( number? m1 ) ( number? m2 )) ( * m1 m2 )) ( else ( list '* m1 m2 )))) ( make-product 4 8 ) ;Value: 32 ( make-product 'x 1 ) ;Value: x ( make-product 1 'x ) ;Value: x ( make-product 'y 0 ) ;Value: 0 ( make-product 0 'y ) ;Value: 0 ( make-product 'x 'y ) ;(* x y) ; Testing ( deriv ' ( + x 3 ) 'x ) ; 1 ( deriv ' ( * x y ) 'x ) ; y ( deriv ' ( * ( * x y ) ( + x 3 )) 'x ) ; (+ (* x y) (* y (+ x 3)))","title":"symbolic-diff"},{"location":"SICP/ch2-abstraction-data/symbolic-diff/#symbolic-diff","text":"; Derivative in terms of abstract terms ( define ( deriv exp var ) ( cond (( number? exp ) 0 ) (( variable? exp ) ( if ( same-variable? exp var ) 1 0 )) (( sum? exp ) ( make-sum ( deriv ( addend exp ) var ) ( deriv ( augend exp ) var ))) (( product? exp ) ( make-sum ( make-product ( multiplier exp ) ( deriv ( multiplicand exp ) var )) ( make-product ( deriv ( multiplier exp ) var ) ( multiplicand exp )))) ( else ( error \"unknown expression type: DERIV\" exp )))) ; Representing algebraic expressions ( define ( variable? x ) ( symbol? x )) ( define ( same-variable? v1 v2 ) ( and ( variable? v1 ) ( variable? v2 ) ( eq? v1 v2 ))) ( define ( make-sum a1 a2 ) ( list '+ a1 a2 )) ( define ( make-product m1 m2 ) ( list '* m1 m2 )) ; Sum is a list whose first element is symbol +: ( define ( sum? x ) ( and ( pair? x ) ( eq? ( car x ) '+ ))) ( define ( addend s ) ( cadr s )) ( define ( augend s ) ( caddr s )) ; Product is a list whose first element is symbol *: ( define ( product? x ) ( and ( pair? x ) ( eq? ( car x ) '* ))) ( define ( multiplier p ) ( cadr p )) ( define ( multiplicand p ) ( caddr p )) ; Basic examples ( deriv ' ( + x 3 ) 'x ) ; (+ 1 x) ( deriv ' ( * x y ) 'x ) ; (+ (* x 0) (* 1 y)) ( deriv ' ( * ( * x y ) ( + x 3 )) 'x ) ; (+ (* (* x y) (+ 1 x)) (* (+ (* x 0) (* 1 y)) (+ x 3))) ; Simplifying expressions ( define ( =number? exp num ) ( and ( number? exp ) ( = exp num ))) ( =number? 'a 0 ) ; false ( =number? 1 1 ) ; true ( define ( make-sum a1 a2 ) ( cond (( =number? a1 0 ) a2 ) (( =number? a2 0 ) a1 ) (( and ( number? a1 ) ( number? a2 )) ( + a1 a2 )) ( else ( list '+ a1 a2 )))) ( make-sum 2 3 ) ;Value: 5 ( make-sum 'x 0 ) ;Value: x ( make-sum 0 'y ) ;Value: y ( make-sum 'x 'y ) ;(+ x y) ( define ( make-product m1 m2 ) ( cond (( or ( =number? m1 0 ) ( =number? m2 0 )) 0 ) (( =number? m1 1 ) m2 ) (( =number? m2 1 ) m1 ) (( and ( number? m1 ) ( number? m2 )) ( * m1 m2 )) ( else ( list '* m1 m2 )))) ( make-product 4 8 ) ;Value: 32 ( make-product 'x 1 ) ;Value: x ( make-product 1 'x ) ;Value: x ( make-product 'y 0 ) ;Value: 0 ( make-product 0 'y ) ;Value: 0 ( make-product 'x 'y ) ;(* x y) ; Testing ( deriv ' ( + x 3 ) 'x ) ; 1 ( deriv ' ( * x y ) 'x ) ; y ( deriv ' ( * ( * x y ) ( + x 3 )) 'x ) ; (+ (* x y) (* y (+ x 3)))","title":"symbolic-diff"},{"location":"SICP/ch2-abstraction-data/tree-map/","text":"tree-map \u00b6 ; `scale-tree` procedure ( define ( scale-tree tree factor ) ( cond (( null? tree ) tree ) (( not ( pair? tree )) ( * factor tree )) ( else ( cons ( scale-tree ( car tree ) factor ) ( scale-tree ( cdr tree ) factor ))))) ( scale-tree ( list 1 ( list 2 ( list 3 4 ) 5 ) ( list 6 7 )) 10 ) ; (10 (20 (30 40) 50) (60 70)) ; `scale-tree` using `map` ( define ( scale-tree tree factor ) ( map ( lambda ( sub-tree ) ( if ( pair? sub-tree ) ( scale-tree sub-tree factor ) ( * sub-tree factor ))) tree )) ( scale-tree ( list 1 ( list 2 ( list 3 4 ) 5 ) ( list 6 7 )) 10 ) ; (10 (20 (30 40) 50) (60 70))","title":"tree-map"},{"location":"SICP/ch2-abstraction-data/tree-map/#tree-map","text":"; `scale-tree` procedure ( define ( scale-tree tree factor ) ( cond (( null? tree ) tree ) (( not ( pair? tree )) ( * factor tree )) ( else ( cons ( scale-tree ( car tree ) factor ) ( scale-tree ( cdr tree ) factor ))))) ( scale-tree ( list 1 ( list 2 ( list 3 4 ) 5 ) ( list 6 7 )) 10 ) ; (10 (20 (30 40) 50) (60 70)) ; `scale-tree` using `map` ( define ( scale-tree tree factor ) ( map ( lambda ( sub-tree ) ( if ( pair? sub-tree ) ( scale-tree sub-tree factor ) ( * sub-tree factor ))) tree )) ( scale-tree ( list 1 ( list 2 ( list 3 4 ) 5 ) ( list 6 7 )) 10 ) ; (10 (20 (30 40) 50) (60 70))","title":"tree-map"},{"location":"SICP/ch2-abstraction-data/tree/","text":"tree \u00b6 ; Defining hierarchical strucutre ( define x ( cons ( list 1 2 ) ( list 3 4 ))) ( length x ) ;Value: 3 (length is defined in scheme) ; Implement `count-leaves` procedure ( define ( count-leaves x ) ( cond (( null? x ) 0 ) (( not ( pair? x )) 1 ) ( else ( + ( count-leaves ( car x )) ( count-leaves ( cdr x )))))) ( count-leaves x ) ;Value: 4 ( count-leaves ( cons ( cons ( list 1 2 ) 3 ) ( cons ( list 7 8 ) ( list 4 6 )))) ;Value: 7","title":"tree"},{"location":"SICP/ch2-abstraction-data/tree/#tree","text":"; Defining hierarchical strucutre ( define x ( cons ( list 1 2 ) ( list 3 4 ))) ( length x ) ;Value: 3 (length is defined in scheme) ; Implement `count-leaves` procedure ( define ( count-leaves x ) ( cond (( null? x ) 0 ) (( not ( pair? x )) 1 ) ( else ( + ( count-leaves ( car x )) ( count-leaves ( cdr x )))))) ( count-leaves x ) ;Value: 4 ( count-leaves ( cons ( cons ( list 1 2 ) 3 ) ( cons ( list 7 8 ) ( list 4 6 )))) ;Value: 7","title":"tree"},{"location":"SICP/ch2-abstraction-data/packages/general/","text":"general \u00b6 ( define ( type-tag datum ) ( if ( pair? datum ) ( car datum ) ( error \"Bad tagged datum: TYPE-TAG\" datum ))) ( define ( contents datum ) ( if ( pair? datum ) ( cdr datum ) ( error \"Bad tagged datum: CONTENTS\" datum ))) ( define ( attach-tag type-tag contents ) ( cons type-tag contents )) ( define *op-table* ( make-hash-table )) ( define ( put op type proc ) ( hash-table/put! *op-table* ( list op type ) proc )) ( define ( get op type ) ( hash-table/get *op-table* ( list op type ) #f )) ( define ( apply-generic op . args ) ( let (( type-tags ( map type-tag args ))) ( let (( proc ( get op type-tags ))) ( if proc ( apply proc ( map contents args )) ( error \"No method for these types: APPLY-GENERIC\" ( list op type-tags )))))) ( define ( real-part z ) ( apply-generic 'real-part z )) ( define ( imag-part z ) ( apply-generic 'imag-part z )) ( define ( magnitude z ) ( apply-generic 'magnitude z )) ( define ( angle z ) ( apply-generic 'angle z ))","title":"general"},{"location":"SICP/ch2-abstraction-data/packages/general/#general","text":"( define ( type-tag datum ) ( if ( pair? datum ) ( car datum ) ( error \"Bad tagged datum: TYPE-TAG\" datum ))) ( define ( contents datum ) ( if ( pair? datum ) ( cdr datum ) ( error \"Bad tagged datum: CONTENTS\" datum ))) ( define ( attach-tag type-tag contents ) ( cons type-tag contents )) ( define *op-table* ( make-hash-table )) ( define ( put op type proc ) ( hash-table/put! *op-table* ( list op type ) proc )) ( define ( get op type ) ( hash-table/get *op-table* ( list op type ) #f )) ( define ( apply-generic op . args ) ( let (( type-tags ( map type-tag args ))) ( let (( proc ( get op type-tags ))) ( if proc ( apply proc ( map contents args )) ( error \"No method for these types: APPLY-GENERIC\" ( list op type-tags )))))) ( define ( real-part z ) ( apply-generic 'real-part z )) ( define ( imag-part z ) ( apply-generic 'imag-part z )) ( define ( magnitude z ) ( apply-generic 'magnitude z )) ( define ( angle z ) ( apply-generic 'angle z ))","title":"general"},{"location":"SICP/ch2-abstraction-data/packages/polar/","text":"polar \u00b6 ( define ( install-polar-package ) ;; internal procedures ( define ( magnitude z ) ( car z )) ( define ( angle z ) ( cdr z )) ( define ( make-from-mag-ang r a ) ( cons r a )) ( define ( real-part z ) ( * ( magnitude z ) ( cos ( angle z )))) ( define ( imag-part z ) ( * ( magnitude z ) ( sin ( angle z )))) ( define ( make-from-real-imag x y ) ( cons ( sqrt ( + ( square x ) ( square y ))) ( atan y x ))) ;; interface to the rest of the system ( define ( tag x ) ( attach-tag 'polar x )) ( put 'real-part ' ( polar ) real-part ) ( put 'imag-part ' ( polar ) imag-part ) ( put 'magnitude ' ( polar ) magnitude ) ( put 'angle ' ( polar ) angle ) ( put 'make-from-real-imag 'polar ( lambda ( x y ) ( tag ( make-from-real-imag x y )))) ( put 'make-from-mag-ang 'polar ( lambda ( r a ) ( tag ( make-from-mag-ang r a )))) 'done )","title":"polar"},{"location":"SICP/ch2-abstraction-data/packages/polar/#polar","text":"( define ( install-polar-package ) ;; internal procedures ( define ( magnitude z ) ( car z )) ( define ( angle z ) ( cdr z )) ( define ( make-from-mag-ang r a ) ( cons r a )) ( define ( real-part z ) ( * ( magnitude z ) ( cos ( angle z )))) ( define ( imag-part z ) ( * ( magnitude z ) ( sin ( angle z )))) ( define ( make-from-real-imag x y ) ( cons ( sqrt ( + ( square x ) ( square y ))) ( atan y x ))) ;; interface to the rest of the system ( define ( tag x ) ( attach-tag 'polar x )) ( put 'real-part ' ( polar ) real-part ) ( put 'imag-part ' ( polar ) imag-part ) ( put 'magnitude ' ( polar ) magnitude ) ( put 'angle ' ( polar ) angle ) ( put 'make-from-real-imag 'polar ( lambda ( x y ) ( tag ( make-from-real-imag x y )))) ( put 'make-from-mag-ang 'polar ( lambda ( r a ) ( tag ( make-from-mag-ang r a )))) 'done )","title":"polar"},{"location":"SICP/ch2-abstraction-data/packages/polynomial/","text":"polynomial \u00b6 ( define ( install-polynomial-package ) ;; internal procedures ;; representation of poly ( define ( make-poly variable term-list ) ( cons variable term-list )) ( define ( variable p ) ( car p )) ( define ( term-list p ) ( cdr p )) ; \u27e8procedures same-variable? and variable? from section 2.3.2\u27e9 ( define ( variable? x ) ( symbol? x )) ( define ( same-variable? v1 v2 ) ( and ( variable? v1 ) ( variable? v2 ) ( eq? v1 v2 ))) ;; representation of terms and term lists ;; \u27e8procedures adjoin-term . . . coeff from text below\u27e9 ;; Add ( define ( add-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( add-terms ( term-list p1 ) ( term-list p2 ))) ( error \"Polys not in same var: ADD-POLY\" ( list p1 p2 )))) ( define ( add-terms L1 L2 ) ( cond (( empty-termlist? L1 ) L2 ) (( empty-termlist? L2 ) L1 ) ( else ( let (( t1 ( first-term L1 )) ( t2 ( first-term L2 ))) ( cond (( > ( order t1 ) ( order t2 )) ( adjoin-term t1 ( add-terms ( rest-terms L1 ) L2 ))) (( < ( order t1 ) ( order t2 )) ( adjoin-term t2 ( add-terms L1 ( rest-terms L2 )))) ( else ( adjoin-term ( make-term ( order t1 ) ( add ( coeff t1 ) ( coeff t2 ))) ( add-terms ( rest-terms L1 ) ( rest-terms L2 ))))))))) ;; Multiply ( define ( mul-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( mul-terms ( term-list p1 ) ( term-list p2 ))) ( error \"Polys not in same var: MUL-POLY\" ( list p1 p2 )))) ( define ( mul-terms L1 L2 ) ( if ( empty-termlist? L1 ) ( the-empty-termlist ) ( add-terms ( mul-term-by-all-terms ( first-term L1 ) L2 ) ( mul-terms ( rest-terms ) L2 )))) ( define ( mul-term-by-all-terms t1 L ) ( if ( empty-termlist? L ) ( the-empty-termlist ) ( let (( t2 ( first-term L ))) ( adjoin-term ( make-term ( + ( order t1 ) ( order t2 )) ( mul ( coeff t1 ) ( coeff t2 ))) ( mul-term-by-all-terms t1 ( rest-terms L )))))) ( define ( poly-zero? term-list ) ( if ( empty-termlist? term-list ) #t ( and ( =zero? ( coeff ( first-term term-list ))) ( poly-zero? ( rest-terms term-list ))))) ;; Subtraction ( define ( negate-terms term-list ) ( if ( empty-termlist? term-list ) the-empty-termlist ( adjoin-term ( make-term ( order ( first-term term-list )) ( negate ( coeff ( first-term term-list )))) ( negate-terms ( rest-terms term-list ))))) ( define ( sub-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( add-terms ( term-list p1 ) ( negate-terms ( term-list p2 )))) ( error \"Polys not in same var: SUB-POLY\" ( list p1 p2 )))) ;; interface to rest of the system ( define ( tag p ) ( attach-tag 'polynomial p )) ( put '=zero? ' ( polynomial ) ( lambda ( p ) ( poly-zero? ( term-list p )))) ( put 'add ' ( polynomial polynomial ) ( lambda ( p1 p2 ) ( tag ( add-poly p1 p2 )))) ( put 'mul ' ( polynomial polynomial ) ( lambda ( p1 p2 ) ( tag ( mul-poly p1 p2 )))) ( put 'make 'polynomial ( lambda ( var terms ) ( tag ( make-poly var terms )))) ( put 'negate ' ( polynomial ) ( lambda ( p ) ( make-polynomial ( variable p ) ( negate-terms ( term-list p ))))) ( put 'sub ' ( polynomial polynomial ) ( lambda ( p1 p2 ) ( tag ( sub-poly p1 p2 )))) 'done ) ;; representation of terms ( define ( adjoin-term term term-list ) ( if ( =zero? ( coeff term )) term-list ( cons term term-list ))) ( define ( the-empty-termlist ) ' ()) ( define ( first-term term-list ) ( car term-list )) ( define ( rest-terms term-list ) ( cdr term-list )) ( define ( empty-termlist? term-list ) ( null? term-list )) ( define ( make-term order coeff ) ( list order coeff )) ( define ( order term ) ( car term )) ( define ( coeff term ) ( cadr term )) ( define ( make-polynomial var terms ) (( get 'make 'polynomial ) var terms ))","title":"polynomial"},{"location":"SICP/ch2-abstraction-data/packages/polynomial/#polynomial","text":"( define ( install-polynomial-package ) ;; internal procedures ;; representation of poly ( define ( make-poly variable term-list ) ( cons variable term-list )) ( define ( variable p ) ( car p )) ( define ( term-list p ) ( cdr p )) ; \u27e8procedures same-variable? and variable? from section 2.3.2\u27e9 ( define ( variable? x ) ( symbol? x )) ( define ( same-variable? v1 v2 ) ( and ( variable? v1 ) ( variable? v2 ) ( eq? v1 v2 ))) ;; representation of terms and term lists ;; \u27e8procedures adjoin-term . . . coeff from text below\u27e9 ;; Add ( define ( add-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( add-terms ( term-list p1 ) ( term-list p2 ))) ( error \"Polys not in same var: ADD-POLY\" ( list p1 p2 )))) ( define ( add-terms L1 L2 ) ( cond (( empty-termlist? L1 ) L2 ) (( empty-termlist? L2 ) L1 ) ( else ( let (( t1 ( first-term L1 )) ( t2 ( first-term L2 ))) ( cond (( > ( order t1 ) ( order t2 )) ( adjoin-term t1 ( add-terms ( rest-terms L1 ) L2 ))) (( < ( order t1 ) ( order t2 )) ( adjoin-term t2 ( add-terms L1 ( rest-terms L2 )))) ( else ( adjoin-term ( make-term ( order t1 ) ( add ( coeff t1 ) ( coeff t2 ))) ( add-terms ( rest-terms L1 ) ( rest-terms L2 ))))))))) ;; Multiply ( define ( mul-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( mul-terms ( term-list p1 ) ( term-list p2 ))) ( error \"Polys not in same var: MUL-POLY\" ( list p1 p2 )))) ( define ( mul-terms L1 L2 ) ( if ( empty-termlist? L1 ) ( the-empty-termlist ) ( add-terms ( mul-term-by-all-terms ( first-term L1 ) L2 ) ( mul-terms ( rest-terms ) L2 )))) ( define ( mul-term-by-all-terms t1 L ) ( if ( empty-termlist? L ) ( the-empty-termlist ) ( let (( t2 ( first-term L ))) ( adjoin-term ( make-term ( + ( order t1 ) ( order t2 )) ( mul ( coeff t1 ) ( coeff t2 ))) ( mul-term-by-all-terms t1 ( rest-terms L )))))) ( define ( poly-zero? term-list ) ( if ( empty-termlist? term-list ) #t ( and ( =zero? ( coeff ( first-term term-list ))) ( poly-zero? ( rest-terms term-list ))))) ;; Subtraction ( define ( negate-terms term-list ) ( if ( empty-termlist? term-list ) the-empty-termlist ( adjoin-term ( make-term ( order ( first-term term-list )) ( negate ( coeff ( first-term term-list )))) ( negate-terms ( rest-terms term-list ))))) ( define ( sub-poly p1 p2 ) ( if ( same-variable? ( variable p1 ) ( variable p2 )) ( make-poly ( variable p1 ) ( add-terms ( term-list p1 ) ( negate-terms ( term-list p2 )))) ( error \"Polys not in same var: SUB-POLY\" ( list p1 p2 )))) ;; interface to rest of the system ( define ( tag p ) ( attach-tag 'polynomial p )) ( put '=zero? ' ( polynomial ) ( lambda ( p ) ( poly-zero? ( term-list p )))) ( put 'add ' ( polynomial polynomial ) ( lambda ( p1 p2 ) ( tag ( add-poly p1 p2 )))) ( put 'mul ' ( polynomial polynomial ) ( lambda ( p1 p2 ) ( tag ( mul-poly p1 p2 )))) ( put 'make 'polynomial ( lambda ( var terms ) ( tag ( make-poly var terms )))) ( put 'negate ' ( polynomial ) ( lambda ( p ) ( make-polynomial ( variable p ) ( negate-terms ( term-list p ))))) ( put 'sub ' ( polynomial polynomial ) ( lambda ( p1 p2 ) ( tag ( sub-poly p1 p2 )))) 'done ) ;; representation of terms ( define ( adjoin-term term term-list ) ( if ( =zero? ( coeff term )) term-list ( cons term term-list ))) ( define ( the-empty-termlist ) ' ()) ( define ( first-term term-list ) ( car term-list )) ( define ( rest-terms term-list ) ( cdr term-list )) ( define ( empty-termlist? term-list ) ( null? term-list )) ( define ( make-term order coeff ) ( list order coeff )) ( define ( order term ) ( car term )) ( define ( coeff term ) ( cadr term )) ( define ( make-polynomial var terms ) (( get 'make 'polynomial ) var terms ))","title":"polynomial"},{"location":"SICP/ch2-abstraction-data/packages/rectangular/","text":"rectangular \u00b6 ( define ( install-rectangular-package ) ;; internal procedures ( define ( real-part z ) ( car z )) ( define ( imag-part z ) ( cdr z )) ( define ( make-from-real-imag x y ) ( cons x y )) ( define ( magnitude z ) ( sqrt ( + ( square ( real-part z )) ( square ( imag-part z ))))) ( define ( angle z ) ( atan ( imag-part z ) ( real-part z ))) ( define ( make-from-mag-ang r a ) ( cons ( * r ( cos a )) ( * r ( sin a )))) ;; interface to the rest of the system ( define ( tag x ) ( attach-tag 'rectangular x )) ( put 'real-part ' ( rectangular ) real-part ) ( put 'imag-part ' ( rectangular ) imag-part ) ( put 'magnitude ' ( rectangular ) magnitude ) ( put 'angle ' ( rectangular ) angle ) ( put 'make-from-real-imag 'rectangular ( lambda ( x y ) ( tag ( make-from-real-imag x y )))) ( put 'make-from-mag-ang 'rectangular ( lambda ( r a ) ( tag ( make-from-mag-ang r a )))) 'done ) ( install-rectangular-package )","title":"rectangular"},{"location":"SICP/ch2-abstraction-data/packages/rectangular/#rectangular","text":"( define ( install-rectangular-package ) ;; internal procedures ( define ( real-part z ) ( car z )) ( define ( imag-part z ) ( cdr z )) ( define ( make-from-real-imag x y ) ( cons x y )) ( define ( magnitude z ) ( sqrt ( + ( square ( real-part z )) ( square ( imag-part z ))))) ( define ( angle z ) ( atan ( imag-part z ) ( real-part z ))) ( define ( make-from-mag-ang r a ) ( cons ( * r ( cos a )) ( * r ( sin a )))) ;; interface to the rest of the system ( define ( tag x ) ( attach-tag 'rectangular x )) ( put 'real-part ' ( rectangular ) real-part ) ( put 'imag-part ' ( rectangular ) imag-part ) ( put 'magnitude ' ( rectangular ) magnitude ) ( put 'angle ' ( rectangular ) angle ) ( put 'make-from-real-imag 'rectangular ( lambda ( x y ) ( tag ( make-from-real-imag x y )))) ( put 'make-from-mag-ang 'rectangular ( lambda ( r a ) ( tag ( make-from-mag-ang r a )))) 'done ) ( install-rectangular-package )","title":"rectangular"}]}